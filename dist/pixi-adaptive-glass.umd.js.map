{"version":3,"file":"pixi-adaptive-glass.umd.js","sources":["../src/core/CapabilityProbe.ts","../src/core/AdaptiveQualityController.ts","../src/core/SceneRTManager.ts","../src/core/EventBus.ts","../src/materials/GlassPresets.ts","../src/panels/GlassPanel.ts","../src/GlassOverlay.ts","../src/utils/PillGeometry.ts","../src/utils/index.ts","../src/pipelines/WebGL1Pipeline.ts","../src/shaders/webgl2.ts","../src/pipelines/WebGL2Pipeline.ts","../src/system/GlassSystem.ts","../src/hud/GlassHUD.ts"],"sourcesContent":["import type { CapabilityResult, CapabilityTier } from './types.js';\n\nexport class CapabilityProbe {\n  private cached?: CapabilityResult;\n\n  constructor(private readonly gl: WebGLRenderingContext | WebGL2RenderingContext) {}\n\n  run(): CapabilityResult {\n    if (this.cached) {\n      return this.cached;\n    }\n\n    const isWebGL2 = this.isWebGL2Context(this.gl);\n    const extensions = this.queryExtensions([\n      'EXT_color_buffer_float',\n      'OES_texture_float_linear',\n      'OES_standard_derivatives',\n      'EXT_disjoint_timer_query_webgl2',\n      'EXT_disjoint_timer_query',\n    ]);\n\n    const tier: CapabilityTier = isWebGL2 && this.getMaxDrawBuffers() > 1 ? 'webgl2' : 'webgl1';\n\n    this.cached = {\n      tier,\n      maxDrawBuffers: this.getMaxDrawBuffers(),\n      extensions,\n    };\n    return this.cached;\n  }\n\n  private queryExtensions(names: string[]): Record<string, boolean> {\n    return names.reduce<Record<string, boolean>>((map, name) => {\n      map[name] = Boolean(this.gl.getExtension(name));\n      return map;\n    }, {});\n  }\n\n  private getMaxDrawBuffers(): number {\n    const ext = this.gl.getExtension('WEBGL_draw_buffers');\n    const param = this.isWebGL2Context(this.gl)\n      ? this.gl.MAX_DRAW_BUFFERS\n      : ext\n        ? ext.MAX_DRAW_BUFFERS_WEBGL\n        : 0;\n    if (!param) return 1;\n    const caps = this.gl.getParameter(param) as number | null;\n    return caps ?? 1;\n  }\n\n  private isWebGL2Context(\n    gl: WebGLRenderingContext | WebGL2RenderingContext,\n  ): gl is WebGL2RenderingContext {\n    return typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\n  }\n}\n","import type { AdaptiveAction, AdaptiveDecision, RenderQualityOptions, TelemetrySample } from './types.js';\n\nconst DEFAULT_QUALITY: RenderQualityOptions = {\n  renderScale: 1,\n  enableDispersion: true,\n  enableCaustics: true,\n  enableContactShadows: true,\n  maxBlurTaps: 9,\n  edgeSupersampling: 1,\n};\n\ntype DegradationStep = {\n  check: (q: RenderQualityOptions) => boolean;\n  apply: (q: RenderQualityOptions) => void;\n  action: AdaptiveAction;\n  reason: string;\n};\n\nconst DEGRADATION_STEPS: DegradationStep[] = [\n  { check: q => q.renderScale > 0.85, apply: q => { q.renderScale = 0.85; }, action: 'scale-rt-0-85', reason: 'Frame budget exceeded' },\n  { check: q => q.renderScale > 0.7, apply: q => { q.renderScale = 0.7; }, action: 'scale-rt-0-7', reason: 'Severe perf drop' },\n  { check: q => q.maxBlurTaps > 5, apply: q => { q.maxBlurTaps = 5; }, action: 'reduce-blur', reason: 'Sustained frame drops' },\n  { check: q => q.enableDispersion, apply: q => { q.enableDispersion = false; }, action: 'disable-dispersion', reason: 'Dispersion too expensive' },\n  { check: q => q.enableCaustics || q.enableContactShadows, apply: q => { q.enableCaustics = false; q.enableContactShadows = false; }, action: 'disable-caustics', reason: 'Optional overlays disabled' },\n];\n\nexport class AdaptiveQualityController {\n  private current: RenderQualityOptions = { ...DEFAULT_QUALITY };\n  private readonly telemetry: TelemetrySample[] = [];\n  private overrides: Partial<RenderQualityOptions> = {};\n\n  constructor(private readonly targetFrameMs = 100) {}\n\n  getQuality(): RenderQualityOptions {\n    return { ...this.current };\n  }\n\n  record(sample: TelemetrySample): void {\n    this.telemetry.push(sample);\n    if (this.telemetry.length > 120) {\n      this.telemetry.shift();\n    }\n  }\n\n  setOverrides(overrides: Partial<RenderQualityOptions>): void {\n    this.overrides = { ...this.overrides, ...overrides };\n    this.current = { ...this.current, ...this.overrides };\n  }\n\n  getTelemetry(): TelemetrySample[] {\n    return [...this.telemetry];\n  }\n\n  evaluate(): AdaptiveDecision | undefined {\n    if (this.telemetry.length < 30) return undefined;\n    const avgCpu = this.telemetry.reduce((sum, s) => sum + s.cpuMs, 0) / this.telemetry.length;\n    const avgGpu = this.telemetry.reduce((sum, s) => sum + (s.gpuMs ?? s.cpuMs), 0) / this.telemetry.length;\n    if (Math.max(avgCpu, avgGpu) <= this.targetFrameMs) return undefined;\n\n    for (const step of DEGRADATION_STEPS) {\n      if (step.check(this.current)) {\n        step.apply(this.current);\n        return { action: step.action, reason: step.reason };\n      }\n    }\n    return undefined;\n  }\n}\n","import { Rectangle, RenderTexture } from 'pixi.js';\nimport type { Renderer, WebGLRenderer } from 'pixi.js';\n\ninterface RtHandles {\n  sceneColor: RenderTexture;\n  sceneDepth?: RenderTexture;\n}\n\nexport class SceneRTManager {\n  private handles?: RtHandles;\n  private scale = 1;\n  private readonly clearRect = new Rectangle();\n\n  constructor(\n    private readonly renderer: Renderer,\n    private readonly useDepth: boolean,\n  ) {}\n\n  ensure(width: number, height: number, scale: number): RtHandles {\n    const targetResolution = this.renderer.resolution * scale;\n    if (\n      !this.handles ||\n      this.handles.sceneColor.width !== width ||\n      this.handles.sceneColor.height !== height ||\n      this.handles.sceneColor.source.resolution !== targetResolution\n    ) {\n      this.dispose();\n      this.handles = {\n        sceneColor: RenderTexture.create({\n          width,\n          height,\n          resolution: targetResolution,\n          scaleMode: 'linear',\n        }),\n        sceneDepth: this.useDepth\n          ? RenderTexture.create({\n              width,\n              height,\n              resolution: targetResolution,\n              scaleMode: 'nearest',\n            })\n          : undefined,\n      };\n      this.scale = scale;\n    }\n    return this.handles;\n  }\n\n  clearTargets(): void {\n    if (!this.handles) return;\n    this.clearRect.width = this.handles.sceneColor.width;\n    this.clearRect.height = this.handles.sceneColor.height;\n    \n    const renderer = this.renderer as WebGLRenderer;\n    renderer.renderTarget.bind(this.handles.sceneColor);\n    const gl = renderer.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    if (this.handles.sceneDepth) {\n      renderer.renderTarget.bind(this.handles.sceneDepth);\n      gl.clearColor(1, 0, 0, 1); \n      gl.clearDepth(1.0);\n      gl.clear(gl.DEPTH_BUFFER_BIT);\n    }\n  }\n\n  dispose(): void {\n    this.handles?.sceneColor.destroy(true);\n    this.handles?.sceneDepth?.destroy(true);\n    this.handles = undefined;\n  }\n}\n","type Listener<T> = (payload: T) => void;\n\ntype EventMap = Record<string, unknown>;\n\nexport class EventBus<Events extends EventMap> {\n  private listeners: { [K in keyof Events]?: Set<Listener<Events[K]>> } = {};\n\n  on<K extends keyof Events>(event: K, listener: Listener<Events[K]>): void {\n    let listeners = this.listeners[event];\n    if (!listeners) {\n      listeners = new Set();\n      this.listeners[event] = listeners;\n    }\n    listeners.add(listener);\n  }\n\n  off<K extends keyof Events>(event: K, listener: Listener<Events[K]>): void {\n    this.listeners[event]?.delete(listener);\n  }\n\n  emit<K extends keyof Events>(event: K, payload: Events[K]): void {\n    const listeners = this.listeners[event];\n    if (!listeners) return;\n    for (const listener of listeners) {\n      listener(payload);\n    }\n  }\n\n  removeAll(): void {\n    for (const key of Object.keys(this.listeners) as Array<keyof Events>) {\n      this.listeners[key]?.clear();\n    }\n  }\n}\n","import type { GlassMaterial } from '../core/types.js';\n\nconst make = (material: GlassMaterial): GlassMaterial => material;\n\nexport const GlassPresets = {\n  water(): GlassMaterial {\n    return make({\n      ior: 1.333,\n      thickness: 0.6,\n      roughness: 0.1,\n      dispersion: 0.02,\n      opacity: 1.0,\n      tint: 0x9fd9ff,\n    });\n  },\n  crownGlass(): GlassMaterial {\n    return make({\n      ior: 1.52,\n      thickness: 0.8,\n      roughness: 0.05,\n      dispersion: 0.04,\n      opacity: 1.0,\n      tint: 0xffffff,\n    });\n  },\n  acrylic(): GlassMaterial {\n    return make({\n      ior: 1.49,\n      thickness: 0.7,\n      roughness: 0.12,\n      dispersion: 0.01,\n      opacity: 1.0,\n      tint: 0xf7f7f7,\n    });\n  },\n  clear(): GlassMaterial {\n    return make({\n      ior: 1.52,\n      thickness: 0.8,\n      roughness: 0.05,\n      dispersion: 0.04,\n      opacity: 1.0,\n      tint: 0xffffff,\n    });\n  },\n  fromIOR(ior: number): GlassMaterial {\n    const clamped = Math.min(Math.max(ior, 1.0), 2.0);\n    return make({\n      ior: clamped,\n      thickness: 0.75,\n      roughness: 0.08,\n      dispersion: (clamped - 1) * 0.05,\n      opacity: 1.0,\n      tint: 0xffffff,\n    });\n  },\n};\n","  import { Mesh, MeshGeometry, Shader, State } from 'pixi.js';\nimport type { Texture } from 'pixi.js';\nimport type { CapabilityTier, GlassMaterial, GlassPanelProps } from '../core/types.js';\n\nlet PANEL_COUNTER = 0;\n\n// Use MeshGeometry which auto-maps to aPosition and aUV attributes\n// Centered geometry (-0.5 to 0.5) - position is center, scale is size\nconst QUAD_GEOMETRY = new MeshGeometry({\n  positions: new Float32Array([-0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5]),\n  uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n  indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\nconst BASIC_VERT = `\nprecision mediump float;\nattribute vec2 aPosition;\nattribute vec2 aUV;\nvarying vec2 vUv;\nuniform mat3 translationMatrix;\nuniform mat3 projectionMatrix;\nuniform mat3 uTextureMatrix;\nvoid main(void){\n  vUv = aUV;\n  gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aPosition, 1.0)).xy, 0.0, 1.0);\n}\n`;\n\nconst BASIC_FRAG = `\nprecision mediump float;\nvarying vec2 vUv;\nvoid main(void){\n  gl_FragColor = vec4(vUv, 0.0, 1.0);\n}\n`;\n\nexport class GlassPanel extends Mesh {\n  id: string;\n  glassMaterial: GlassMaterial;\n  normalMap?: Texture;\n  dudvMap?: Texture;\n  causticsAtlas?: Texture;\n  sdfShadow?: Texture;\n  private tier: CapabilityTier = 'webgl1';\n\n  constructor(props: GlassPanelProps) {\n    const state = State.for2d();\n    state.culling = false; // Disable culling to avoid winding order issues\n\n    super({\n      geometry: props.geometry ?? QUAD_GEOMETRY,\n      shader: Shader.from({\n        gl: {\n          vertex: BASIC_VERT,\n          fragment: BASIC_FRAG,\n        },\n      }) as any,\n      state,\n    });\n    this.id = props.id ?? `glass-panel-${++PANEL_COUNTER}`;\n    this.glassMaterial = props.material;\n    this.normalMap = props.normalMap;\n    this.dudvMap = props.dudvMap;\n    this.causticsAtlas = props.causticsAtlas;\n    this.sdfShadow = props.sdfShadow;\n    if (props.filters) {\n      this.filters = props.filters;\n    }\n  }\n\n  setMaterial(partial: Partial<GlassMaterial>): void {\n    this.glassMaterial = { ...this.glassMaterial, ...partial };\n  }\n\n  setTextures(textures: Partial<Omit<GlassPanelProps, 'material' | 'geometry'>>): void {\n    if (textures.normalMap) this.normalMap = textures.normalMap;\n    if (textures.dudvMap) this.dudvMap = textures.dudvMap;\n    if (textures.causticsAtlas) this.causticsAtlas = textures.causticsAtlas;\n    if (textures.sdfShadow) this.sdfShadow = textures.sdfShadow;\n  }\n\n  setTier(tier: CapabilityTier): void {\n    this.tier = tier;\n  }\n\n  getTier(): CapabilityTier {\n    return this.tier;\n  }\n}\n","import { Container, Texture } from 'pixi.js';\nimport type { Renderer } from 'pixi.js';\nimport { GlassSystem } from './system/GlassSystem.js';\nimport { GlassPresets } from './materials/GlassPresets.js';\nimport type { GlassPanel } from './panels/GlassPanel.js';\nimport type { GlassMaterial, SurfaceShape } from './core/types.js';\n\nexport interface PositionTransform {\n  x: number;\n  y: number;\n  scaleX: number;\n  scaleY: number;\n  rotation: number;\n}\n\nexport type PositionTransformFn = (\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n) => PositionTransform;\n\nexport interface LightFollowParams {\n  followCursor: boolean;\n  smoothing?: number; // 0 - 1, amount of smoothing (0 = instant, 1 = very slow, default 0.9)\n  delay?: number; // 0 - 1, lag before movement starts (0 = instant, 1 = max lag, default 0.5)\n  curve?: number; // 0.5 - 3, z falloff curve (default 1.5)\n  zMin?: number; // minimum z value (default 0.05)\n  zMax?: number; // maximum z value (default 0.20)\n  edgeStretch?: number; // 0.1 - 2, how much to stretch toward edges (< 1 = more edge, > 1 = more center, default 0.5)\n}\n\nexport interface GlassOverlayOptions {\n  /**\n   * The container holding the background content that should be seen through the glass.\n   * This will be rendered into the glass system's backdrop texture.\n   */\n  background: Container;\n\n  /**\n   * The container where the glass composite effect should be added.\n   * Typically the same stage, or a layer above the background.\n   */\n  stage: Container;\n\n  /**\n   * Optional initial configuration for the GlassSystem.\n   */\n  systemOptions?: {\n    hudEnabled?: boolean;\n  };\n\n  /**\n   * Optional light follow cursor settings.\n   */\n  lightFollowParams?: LightFollowParams;\n}\n\nexport interface GlassItemConfig {\n  /**\n   * Custom material overrides for this element.\n   */\n  material?: Partial<GlassMaterial>;\n\n  /**\n   * Optional custom normal map. If not provided, a default rounded rect map is generated.\n   */\n  normalMap?: Texture;\n\n  /**\n   * Corner radius for the default normal map generation. Defaults to 20.\n   */\n  cornerRadius?: number;\n\n  /**\n   * Surface shape for the glass bevel. Defaults to 'squircle'.\n   * - circle: Simple circular arc (sharper edges)\n   * - squircle: Softer flat→curve transition (smoother, default)\n   * - concave: Bowl-like depression (light diverges outward)\n   * - lip: Raised rim with shallow center dip\n   */\n  surfaceShape?: SurfaceShape;\n\n  /**\n   * How far the bevel extends from the edge toward center (in pixels).\n   * Defaults to 12.\n   */\n  bevelSize?: number;\n\n  /**\n   * Invert the normals (makes convex appear concave). Defaults to false.\n   */\n  invertNormals?: boolean;\n\n  /**\n   * Invert the shape curve direction. Defaults to false.\n   */\n  invertCurve?: boolean;\n\n  /**\n   * Bezier curve control points for custom bevel shape [x1, y1, x2, y2].\n   * When provided, overrides surfaceShape.\n   */\n  bezierCurve?: [number, number, number, number];\n\n  /**\n   * Render as a circle. Sets corner radius to half the minimum dimension.\n   * Can also be triggered by adding 'glass-circle' class or data-glass-circle attribute.\n   */\n  isCircle?: boolean;\n}\n\n/**\n * A high-level wrapper for GlassSystem that synchronizes GlassPanels with DOM elements.\n * Ideal for adding glass effects to existing UI overlays in Nuxt/Vue/React projects.\n */\ninterface TrackedItem {\n  panel: GlassPanel;\n  config: GlassItemConfig;\n  lastRect?: DOMRect;\n  lastRadius: number;\n  visible: boolean;\n  isCircle: boolean;\n  polling: boolean;\n}\n\nexport class GlassOverlay {\n  public readonly system: GlassSystem;\n  private readonly tracked = new Map<HTMLElement, TrackedItem>();\n  private readonly background: Container;\n  private observer?: MutationObserver;\n  private resizeObserver?: ResizeObserver;\n  private intersectionObserver?: IntersectionObserver;\n  private positionTransform?: PositionTransformFn;\n\n  // Light follow cursor\n  private lightFollowParams?: LightFollowParams;\n  private currentLightDir: [number, number, number] = [0, 0, 0.15];\n  private targetLightDir: [number, number, number] = [0, 0, 0.15];\n  private delayedLightDir: [number, number, number] = [0, 0, 0.15];\n  private boundMouseMove?: (e: MouseEvent) => void;\n\n  private renderer: Renderer;\n\n  constructor(renderer: Renderer, options: GlassOverlayOptions) {\n    this.renderer = renderer;\n    this.background = options.background;\n    this.system = new GlassSystem(renderer, options.systemOptions);\n\n    this.system.setOpaqueSceneCallback((target) => {\n      renderer.render({ container: this.background, target, clear: true });\n    });\n\n    const composite = this.system.getCompositeDisplay();\n    if (composite) {\n      options.stage.addChild(composite);\n    }\n\n    // Set up light follow cursor\n    if (options.lightFollowParams) {\n      this.setLightFollowParams(options.lightFollowParams);\n    }\n  }\n\n  setLightFollowParams(params: LightFollowParams): void {\n    this.lightFollowParams = params;\n\n    if (params.followCursor && !this.boundMouseMove) {\n      this.boundMouseMove = (e: MouseEvent) => {\n        const curve = params.curve ?? 1.5;\n        const zMin = params.zMin ?? 0.05;\n        const zMax = params.zMax ?? 0.20;\n        const edgeStretch = params.edgeStretch ?? 0.5;\n\n        // Get canvas bounds for proper coordinate mapping\n        const canvas = this.renderer.canvas as HTMLCanvasElement;\n        const rect = canvas.getBoundingClientRect();\n\n        // Convert cursor position to -1 to 1 range relative to canvas\n        let x = ((e.clientX - rect.left) / rect.width) * 2 - 1;\n        let y = ((e.clientY - rect.top) / rect.height) * 2 - 1; // Y: top=-1, bottom=1\n\n        // Apply edge stretch - power curve controls how values spread\n        // < 1 = stretch toward edges, > 1 = compress toward center\n        x = Math.sign(x) * Math.pow(Math.abs(x), edgeStretch);\n        y = Math.sign(y) * Math.pow(Math.abs(y), edgeStretch);\n\n        // Z decreases toward edges based on curve, capped at zMax (0.20)\n        const dist = Math.sqrt(x * x + y * y);\n        const z = Math.max(zMin, Math.min(zMax, zMax - Math.pow(dist, curve) * zMax * 0.5));\n\n        this.targetLightDir = [x, y, z];\n      };\n      window.addEventListener('mousemove', this.boundMouseMove);\n    } else if (!params.followCursor && this.boundMouseMove) {\n      window.removeEventListener('mousemove', this.boundMouseMove);\n      this.boundMouseMove = undefined;\n    }\n  }\n\n  autoMount(selector: string = '.glass-panel'): void {\n    // Set up ResizeObserver for size changes\n    this.resizeObserver = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const element = entry.target as HTMLElement;\n        const item = this.tracked.get(element);\n        if (!item) continue;\n\n        const rect = element.getBoundingClientRect();\n        const lastRect = item.lastRect;\n\n        // Check if size changed significantly (more than 1px)\n        if (lastRect && (\n          Math.abs(rect.width - lastRect.width) > 1 ||\n          Math.abs(rect.height - lastRect.height) > 1\n        )) {\n          this.updatePanelGeometry(element, item);\n        }\n        item.lastRect = rect;\n      }\n    });\n\n    // Set up IntersectionObserver for visibility\n    this.intersectionObserver = new IntersectionObserver((entries) => {\n      for (const entry of entries) {\n        const element = entry.target as HTMLElement;\n        const item = this.tracked.get(element);\n        if (!item) continue;\n\n        item.visible = entry.isIntersecting;\n        const cssVisible = this.isCssVisible(element);\n        item.panel.visible = item.visible && cssVisible;\n      }\n    });\n\n    const existing = document.querySelectorAll<HTMLElement>(selector);\n    existing.forEach((el) => this.track(el));\n\n    this.observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.type === 'childList') {\n          mutation.addedNodes.forEach((node) => {\n            if (node instanceof HTMLElement && node.matches(selector)) {\n              this.track(node);\n            }\n            if (node instanceof HTMLElement) {\n              const children = node.querySelectorAll<HTMLElement>(selector);\n              children.forEach((child) => this.track(child));\n            }\n          });\n          mutation.removedNodes.forEach((node) => {\n            if (node instanceof HTMLElement && this.tracked.has(node)) {\n              this.untrack(node);\n            }\n          });\n        } else if (mutation.type === 'attributes') {\n          const target = mutation.target as HTMLElement;\n          if (mutation.attributeName === 'class') {\n            if (target.matches(selector)) {\n              this.track(target);\n            } else {\n              this.untrack(target);\n            }\n          } else if (mutation.attributeName === 'style') {\n            const item = this.tracked.get(target);\n            if (item) {\n              // Check for visibility changes\n              const cssVisible = this.isCssVisible(target);\n              item.panel.visible = cssVisible && item.visible;\n\n              // Check for border-radius changes\n              const rect = target.getBoundingClientRect();\n              const newRadius = this.parseBorderRadius(target, rect);\n              if (Math.abs(newRadius - item.lastRadius) > 0.5) {\n                this.updatePanelGeometry(target, item);\n              }\n            }\n          } else if (mutation.attributeName === 'hidden') {\n            const item = this.tracked.get(target);\n            if (item) {\n              const cssVisible = this.isCssVisible(target);\n              item.panel.visible = cssVisible && item.visible;\n            }\n          }\n        }\n      }\n      this.cleanup();\n    });\n\n    this.observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: ['class', 'style', 'hidden'],\n    });\n  }\n\n  track(element: HTMLElement, config: GlassItemConfig = {}): GlassPanel {\n    if (this.tracked.has(element)) {\n      return this.tracked.get(element)!.panel;\n    }\n\n    const dataIor = element.dataset.glassIor ? parseFloat(element.dataset.glassIor) : undefined;\n    const dataRoughness = element.dataset.glassRoughness\n      ? parseFloat(element.dataset.glassRoughness)\n      : undefined;\n\n    const material = {\n      ...GlassPresets.clear(),\n      ...config.material,\n    };\n\n    if (dataIor !== undefined) material.ior = dataIor;\n    if (dataRoughness !== undefined) material.roughness = dataRoughness;\n\n    // Calculate dynamic normal map based on initial size\n    const rect = element.getBoundingClientRect();\n\n    // Detect circle mode from config, class, or data attribute\n    const isCircle = config.isCircle ||\n                     element.classList.contains('glass-circle') ||\n                     element.hasAttribute('data-glass-circle');\n\n    let radius: number;\n    if (isCircle) {\n      // Circle: radius = half the smaller dimension\n      radius = Math.min(rect.width, rect.height) / 2;\n    } else {\n      const cssRadius = this.parseBorderRadius(element, rect);\n      radius = config.cornerRadius ?? cssRadius; // Config overrides CSS\n    }\n    const bevel = config.bevelSize ?? 12;\n\n    const shape = config.surfaceShape ?? 'squircle';\n    const invertNormals = config.invertNormals ?? false;\n    const invertCurve = config.invertCurve ?? false;\n    const bezierCurve = config.bezierCurve;\n\n    // For circles, use square dimensions\n    const circleSize = Math.floor(Math.min(rect.width, rect.height));\n    const mapWidth = isCircle ? circleSize : rect.width;\n    const mapHeight = isCircle ? circleSize : rect.height;\n\n    const normalMap =\n      config.normalMap || createRoundedRectNormalMap(mapWidth, mapHeight, radius, bevel, shape, invertNormals, invertCurve, bezierCurve);\n\n    const panel = this.system.createPanel({\n      material,\n      normalMap,\n    });\n\n    this.tracked.set(element, { panel, config, lastRect: rect, lastRadius: radius, visible: true, isCircle, polling: false });\n\n    // Set up observers for this element\n    this.resizeObserver?.observe(element);\n    this.intersectionObserver?.observe(element);\n\n    // Set up animation/transition listeners\n    element.addEventListener('transitionrun', this.handleAnimationStart);\n    element.addEventListener('transitionend', this.handleAnimationEnd);\n    element.addEventListener('transitioncancel', this.handleAnimationEnd);\n    element.addEventListener('animationstart', this.handleAnimationStart);\n    element.addEventListener('animationend', this.handleAnimationEnd);\n    element.addEventListener('animationcancel', this.handleAnimationEnd);\n\n    this.syncElement(element, panel);\n\n    return panel;\n  }\n\n  private handleAnimationStart = (e: Event) => {\n    const element = e.currentTarget as HTMLElement;\n    this.startPolling(element);\n  };\n\n  private handleAnimationEnd = (e: Event) => {\n    const element = e.currentTarget as HTMLElement;\n    // Check if any animations are still running\n    const animations = element.getAnimations();\n    if (animations.length === 0) {\n      this.stopPolling(element);\n    }\n  };\n\n  private startPolling(element: HTMLElement): void {\n    const item = this.tracked.get(element);\n    if (!item || item.polling) return;\n\n    item.polling = true;\n    const poll = () => {\n      if (!item.polling) return;\n      this.syncElement(element, item.panel);\n      requestAnimationFrame(poll);\n    };\n    requestAnimationFrame(poll);\n  }\n\n  private stopPolling(element: HTMLElement): void {\n    const item = this.tracked.get(element);\n    if (!item) return;\n\n    item.polling = false;\n    this.updatePanelGeometry(element, item);\n  }\n\n  untrack(element: HTMLElement): void {\n    const item = this.tracked.get(element);\n    if (item) {\n      item.polling = false;\n      this.resizeObserver?.unobserve(element);\n      this.intersectionObserver?.unobserve(element);\n      element.removeEventListener('transitionrun', this.handleAnimationStart);\n      element.removeEventListener('transitionend', this.handleAnimationEnd);\n      element.removeEventListener('transitioncancel', this.handleAnimationEnd);\n      element.removeEventListener('animationstart', this.handleAnimationStart);\n      element.removeEventListener('animationend', this.handleAnimationEnd);\n      element.removeEventListener('animationcancel', this.handleAnimationEnd);\n      this.system.removePanel(item.panel);\n      this.tracked.delete(element);\n    }\n  }\n\n  update(): void {\n    // Update light direction with delay and smoothing\n    if (this.lightFollowParams?.followCursor) {\n      // Delay: lerp delayed toward target (0 = instant, 1 = very slow)\n      const delay = this.lightFollowParams.delay ?? 0.5;\n      const delayFactor = 1 - delay * 0.97; // Convert to lerp factor (0.03 to 1)\n      this.delayedLightDir[0] += (this.targetLightDir[0] - this.delayedLightDir[0]) * delayFactor;\n      this.delayedLightDir[1] += (this.targetLightDir[1] - this.delayedLightDir[1]) * delayFactor;\n      this.delayedLightDir[2] += (this.targetLightDir[2] - this.delayedLightDir[2]) * delayFactor;\n\n      // Smoothing: lerp current toward delayed (0 = instant, 1 = very slow)\n      const smoothing = this.lightFollowParams.smoothing ?? 0.9;\n      const smoothFactor = 1 - smoothing * 0.97; // Convert to lerp factor (0.03 to 1)\n      this.currentLightDir[0] += (this.delayedLightDir[0] - this.currentLightDir[0]) * smoothFactor;\n      this.currentLightDir[1] += (this.delayedLightDir[1] - this.currentLightDir[1]) * smoothFactor;\n      this.currentLightDir[2] += (this.delayedLightDir[2] - this.currentLightDir[2]) * smoothFactor;\n\n      // Apply to all panels\n      for (const [, item] of this.tracked) {\n        item.panel.glassMaterial.lightDir = [...this.currentLightDir];\n      }\n    }\n\n    for (const [element, item] of this.tracked) {\n      this.syncElement(element, item.panel);\n    }\n    this.system.render();\n  }\n\n  resize(): void {\n    this.update();\n  }\n\n  setPositionTransform(transform: PositionTransformFn | undefined): void {\n    this.positionTransform = transform;\n  }\n\n  cleanup(): void {\n    for (const [element] of this.tracked) {\n      if (!document.body.contains(element)) {\n        this.untrack(element);\n      }\n    }\n  }\n\n  destroy(): void {\n    if (this.boundMouseMove) {\n      window.removeEventListener('mousemove', this.boundMouseMove);\n      this.boundMouseMove = undefined;\n    }\n    this.observer?.disconnect();\n    this.resizeObserver?.disconnect();\n    this.intersectionObserver?.disconnect();\n    this.system.destroy();\n    this.tracked.clear();\n  }\n\n  private syncElement(element: HTMLElement, panel: GlassPanel) {\n    const item = this.tracked.get(element);\n    const rect = element.getBoundingClientRect();\n\n    const x = rect.left + rect.width / 2;\n    const y = rect.top + rect.height / 2;\n\n    // For circles, use the smaller dimension for both width and height\n    let width = rect.width;\n    let height = rect.height;\n    if (item?.isCircle) {\n      const size = Math.floor(Math.min(rect.width, rect.height));\n      width = size;\n      height = size;\n    }\n\n    if (this.positionTransform) {\n      const t = this.positionTransform(x, y, width, height);\n      panel.position.set(t.x, t.y);\n      panel.scale.set(width * t.scaleX, height * t.scaleY);\n      panel.rotation = t.rotation;\n    } else {\n      panel.position.set(x, y);\n      panel.scale.set(width, height);\n      panel.rotation = 0;\n    }\n  }\n\n  private parseBorderRadius(element: HTMLElement, rect: DOMRect): number {\n    const style = window.getComputedStyle(element);\n\n    // Get all four corner radii (computed style always returns individual values)\n    const topLeft = style.borderTopLeftRadius;\n    const topRight = style.borderTopRightRadius;\n    const bottomRight = style.borderBottomRightRadius;\n    const bottomLeft = style.borderBottomLeftRadius;\n\n    // Parse a single radius value (handles px and %)\n    const parseValue = (value: string, dimension: number): number => {\n      if (value.endsWith('%')) {\n        return (parseFloat(value) / 100) * dimension;\n      }\n      return parseFloat(value) || 0;\n    };\n\n    // For elliptical corners (e.g., \"10px 20px\"), use the first value (horizontal)\n    const getFirstValue = (radius: string): string => {\n      return radius.split(' ')[0];\n    };\n\n    // Use average of width/height for percentage calculations\n    const avgDimension = (rect.width + rect.height) / 2;\n\n    // Parse all corners and return the average\n    const radii = [\n      parseValue(getFirstValue(topLeft), avgDimension),\n      parseValue(getFirstValue(topRight), avgDimension),\n      parseValue(getFirstValue(bottomRight), avgDimension),\n      parseValue(getFirstValue(bottomLeft), avgDimension),\n    ];\n\n    // Return average radius, or use the most common value\n    const avg = radii.reduce((a, b) => a + b, 0) / 4;\n    return avg || 20; // Default to 20 if parsing fails\n  }\n\n  private isCssVisible(element: HTMLElement): boolean {\n    if (element.hidden) return false;\n    const style = window.getComputedStyle(element);\n    return style.display !== 'none' &&\n           style.visibility !== 'hidden';\n  }\n\n  private updatePanelGeometry(element: HTMLElement, item: TrackedItem): void {\n    const rect = element.getBoundingClientRect();\n\n    // Detect circle mode\n    const isCircle = item.config.isCircle ||\n                     element.classList.contains('glass-circle') ||\n                     element.hasAttribute('data-glass-circle');\n\n    let radius: number;\n    if (isCircle) {\n      radius = Math.min(rect.width, rect.height) / 2;\n    } else {\n      const cssRadius = this.parseBorderRadius(element, rect);\n      radius = item.config.cornerRadius ?? cssRadius;\n    }\n    const bevel = item.config.bevelSize ?? 12;\n    const shape = item.config.surfaceShape ?? 'squircle';\n    const invertNormals = item.config.invertNormals ?? false;\n    const invertCurve = item.config.invertCurve ?? false;\n    const bezierCurve = item.config.bezierCurve;\n\n    // For circles, use square dimensions\n    const circleSize = Math.floor(Math.min(rect.width, rect.height));\n    const mapWidth = isCircle ? circleSize : rect.width;\n    const mapHeight = isCircle ? circleSize : rect.height;\n\n    // Regenerate normal map with new dimensions/radius\n    const normalMap = createRoundedRectNormalMap(\n      mapWidth, mapHeight, radius, bevel, shape, invertNormals, invertCurve, bezierCurve\n    );\n\n    // Update the panel's normal map\n    item.panel.setTextures({ normalMap });\n    item.lastRect = rect;\n    item.lastRadius = radius;\n  }\n}\n\n// Height functions for different surface shapes\n// t is normalized distance from inner edge (0) to outer edge (1)\nexport function heightCircle(t: number): number {\n  return Math.sqrt(Math.max(0, 2 * t - t * t));\n}\n\nfunction heightCircleDerivative(t: number): number {\n  const h = Math.sqrt(Math.max(0.0001, 2 * t - t * t));\n  return (1 - t) / h;\n}\n\nexport function heightSquircle(t: number): number {\n  const inner = 1 - Math.pow(1 - t, 4);\n  return Math.pow(Math.max(0, inner), 0.25);\n}\n\nfunction heightSquircleDerivative(t: number): number {\n  const inner = 1 - Math.pow(1 - t, 4);\n  if (inner <= 0.0001) return 0;\n  return Math.pow(1 - t, 3) / Math.pow(inner, 0.75);\n}\n\nexport function smootherstep(t: number): number {\n  const x = Math.max(0, Math.min(1, t));\n  return x * x * x * (x * (x * 6 - 15) + 10);\n}\n\nfunction smootherstepDerivative(t: number): number {\n  const x = Math.max(0, Math.min(1, t));\n  return 30 * x * x * (x - 1) * (x - 1);\n}\n\n// Cubic bezier evaluation\nfunction cubicBezier(t: number, p0: number, p1: number, p2: number, p3: number): number {\n  const mt = 1 - t;\n  return mt * mt * mt * p0 + 3 * mt * mt * t * p1 + 3 * mt * t * t * p2 + t * t * t * p3;\n}\n\nfunction cubicBezierDerivative(t: number, p0: number, p1: number, p2: number, p3: number): number {\n  const mt = 1 - t;\n  return 3 * mt * mt * (p1 - p0) + 6 * mt * t * (p2 - p1) + 3 * t * t * (p3 - p2);\n}\n\nexport function getBezierHeightAndDerivative(\n  t: number,\n  curve: [number, number, number, number],\n): { height: number; derivative: number } {\n  // curve = [x1, y1, x2, y2] control points for cubic bezier from (0,0) to (1,1)\n  const height = cubicBezier(t, 0, curve[1], curve[3], 1);\n  const derivative = cubicBezierDerivative(t, 0, curve[1], curve[3], 1);\n  return { height, derivative };\n}\n\nexport function getHeightAndDerivative(\n  t: number,\n  shape: SurfaceShape,\n  bezierCurve?: [number, number, number, number],\n): { height: number; derivative: number } {\n  // Use bezier curve if provided\n  if (bezierCurve) {\n    return getBezierHeightAndDerivative(t, bezierCurve);\n  }\n  switch (shape) {\n    case 'circle': {\n      // Reverse t so curve goes high→low like ramp\n      const s = 1 - t;\n      return { height: heightCircle(s), derivative: -heightCircleDerivative(s) };\n    }\n    case 'squircle': {\n      // Reverse t so curve goes high→low like ramp\n      const s = 1 - t;\n      return { height: heightSquircle(s), derivative: -heightSquircleDerivative(s) };\n    }\n    case 'concave': {\n      // Reverse t so curve goes low→high (opposite of convex)\n      const s = 1 - t;\n      const h = heightSquircle(s);\n      const d = heightSquircleDerivative(s);\n      return { height: 1 - h, derivative: d };\n    }\n    case 'lip': {\n      const convexH = heightSquircle(t);\n      const convexD = heightSquircleDerivative(t);\n      const concaveH = 1 - convexH;\n      const concaveD = -convexD;\n      const blend = smootherstep(t);\n      const blendD = smootherstepDerivative(t);\n      const height = convexH * (1 - blend) + concaveH * blend;\n      const derivative = convexD * (1 - blend) + concaveD * blend + (concaveH - convexH) * blendD;\n      return { height, derivative };\n    }\n    case 'dome': {\n      // Full hemisphere - height goes from 0 at edge to 1 at center\n      const h = Math.sqrt(Math.max(0, 1 - t * t));\n      const d = t > 0.001 ? -t / h : 0;\n      return { height: h, derivative: d };\n    }\n    case 'wave': {\n      // Sinusoidal wave\n      const h = (1 - Math.cos(t * Math.PI)) / 2;\n      const d = (Math.PI * Math.sin(t * Math.PI)) / 2;\n      return { height: h, derivative: d };\n    }\n    case 'flat': {\n      // No bevel, completely flat\n      return { height: 0, derivative: 0 };\n    }\n    case 'ramp': {\n      // Linear test pattern - height = t, derivative = 1\n      return { height: t, derivative: 1 };\n    }\n  }\n}\n\nfunction createRoundedRectNormalMap(\n  width: number,\n  height: number,\n  radius: number,\n  bevel: number,\n  shape: SurfaceShape,\n  invertNormals: boolean = false,\n  invertCurve: boolean = false,\n  bezierCurve?: [number, number, number, number],\n): Texture {\n  const w = Math.ceil(width);\n  const h = Math.ceil(height);\n  const data = new Uint8Array(w * h * 4);\n\n  for (let y = 0; y < h; y++) {\n    for (let x = 0; x < w; x++) {\n      let nx = 0;\n      let ny = 0;\n      let nz = 1;\n      let alpha = 255;\n\n      // Use pixel centers for proper symmetry (pixels go 0 to w-1)\n      const cx = (w - 1) / 2;\n      const cy = (h - 1) / 2;\n      const relX = Math.abs(x - cx);\n      const relY = Math.abs(y - cy);\n\n      const innerW = w / 2 - radius;\n      const innerH = h / 2 - radius;\n\n      // Calculate distance to boundary and direction to boundary\n      let distToBoundary = 0;\n      let dirX = 0;\n      let dirY = 0;\n\n      // Find closest point on rounded rect boundary\n      let closestX = relX;\n      let closestY = relY;\n\n      if (relX <= innerW && relY <= innerH) {\n        // Inside flat center - closest point is on nearest edge\n        const toEdgeX = innerW + radius;\n        const toEdgeY = innerH + radius;\n        if (toEdgeX - relX < toEdgeY - relY) {\n          closestX = innerW + radius;\n          closestY = relY;\n        } else {\n          closestX = relX;\n          closestY = innerH + radius;\n        }\n        distToBoundary = Math.min(toEdgeX - relX, toEdgeY - relY);\n      } else if (relX > innerW && relY <= innerH) {\n        // Edge region (right/left)\n        closestX = innerW + radius;\n        closestY = relY;\n        distToBoundary = radius - (relX - innerW);\n      } else if (relY > innerH && relX <= innerW) {\n        // Edge region (top/bottom)\n        closestX = relX;\n        closestY = innerH + radius;\n        distToBoundary = radius - (relY - innerH);\n      } else {\n        // Corner region\n        const dx = relX - innerW;\n        const dy = relY - innerH;\n        const cornerDist = Math.sqrt(dx * dx + dy * dy);\n        distToBoundary = radius - cornerDist;\n        if (cornerDist > 0) {\n          closestX = innerW + (dx / cornerDist) * radius;\n          closestY = innerH + (dy / cornerDist) * radius;\n        }\n      }\n\n      // Hard cutoff for pixels outside the shape\n      if (distToBoundary < 0) {\n        alpha = 0;\n      }\n\n      // Direction points from pixel toward closest boundary point\n      const toDirX = closestX - relX;\n      const toDirY = closestY - relY;\n      const dirLen = Math.sqrt(toDirX * toDirX + toDirY * toDirY);\n      if (dirLen > 0.001) {\n        dirX = (x > cx ? 1 : -1) * (toDirX / dirLen);\n        dirY = (y > cy ? 1 : -1) * (toDirY / dirLen);\n      }\n\n      // Apply bevel based on distance to boundary\n      if (bevel > 0 && distToBoundary < bevel && distToBoundary >= 0) {\n        let t = 1 - distToBoundary / bevel;\n        if (invertCurve) t = 1 - t;\n        const { derivative } = getHeightAndDerivative(t, shape, bezierCurve);\n        const sign = invertCurve ? -1 : 1;\n        nx = dirX * derivative * 0.5 * sign;\n        ny = dirY * derivative * 0.5 * sign;\n        if (invertNormals) {\n          nx = -nx;\n          ny = -ny;\n        }\n      }\n\n      const len = Math.sqrt(nx * nx + ny * ny + nz * nz);\n      nx /= len;\n      ny /= len;\n      nz /= len;\n\n      const index = (y * w + x) * 4;\n      data[index] = ((nx * 0.5 + 0.5) * 255) | 0;\n      data[index + 1] = ((ny * 0.5 + 0.5) * 255) | 0;\n      data[index + 2] = ((nz * 0.5 + 0.5) * 255) | 0;\n      data[index + 3] = alpha;\n    }\n  }\n  return Texture.from({\n    resource: data,\n    width: w,\n    height: h,\n  });\n}\n","import { MeshGeometry, Texture } from 'pixi.js';\nimport { getHeightAndDerivative } from '../GlassOverlay.js';\nimport type { SurfaceShape } from '../core/types.js';\n\n/**\n * Creates a pill/stadium geometry that can expand from circle to pill shape.\n * When expansion = 0, it's a perfect circle.\n * When expansion > 0, it becomes a pill/stadium shape.\n *\n * Uses normalized coordinates (-0.5 to 0.5) like the default QUAD_GEOMETRY,\n * so panel.scale controls the actual size.\n */\nexport function createPillGeometry(\n  radius: number,\n  expansion: number = 0,\n  segments: number = 32\n): MeshGeometry {\n  const halfExpansion = expansion / 2;\n\n  // Center vertex + vertices for both semicircles\n  const vertexCount = 1 + segments;\n  const positions = new Float32Array(vertexCount * 2);\n  const uvs = new Float32Array(vertexCount * 2);\n\n  // Total dimensions - scale is applied by panel\n  const totalWidth = radius * 2 + expansion;\n  const totalHeight = radius * 2;\n\n  // Center vertex at origin\n  positions[0] = 0;\n  positions[1] = 0;\n  uvs[0] = 0.5;\n  uvs[1] = 0.5;\n\n  // Generate vertices around the perimeter\n  for (let i = 0; i < segments; i++) {\n    const angle = (i / segments) * Math.PI * 2 - Math.PI / 2;\n    const idx = (i + 1) * 2;\n\n    let x: number, y: number;\n\n    // Right semicircle (angles -90° to 90°)\n    if (angle >= -Math.PI / 2 && angle <= Math.PI / 2) {\n      x = Math.cos(angle) * radius + halfExpansion;\n      y = Math.sin(angle) * radius;\n    }\n    // Left semicircle (angles 90° to 270°)\n    else {\n      x = Math.cos(angle) * radius - halfExpansion;\n      y = Math.sin(angle) * radius;\n    }\n\n    // Normalize: x to -0.5..0.5 over totalWidth, y to -0.5..0.5 over totalHeight\n    // This keeps circle round when width=height, elongates when width>height\n    positions[idx] = x / totalWidth;\n    positions[idx + 1] = y / totalHeight;\n\n    // UVs: 0..1 range\n    uvs[idx] = x / totalWidth + 0.5;\n    uvs[idx + 1] = y / totalHeight + 0.5;\n  }\n\n  // Create triangle fan from center\n  const triangleCount = segments;\n  const indices = new Uint32Array(triangleCount * 3);\n\n  for (let i = 0; i < segments; i++) {\n    const triIdx = i * 3;\n    indices[triIdx] = 0; // center\n    indices[triIdx + 1] = i + 1;\n    indices[triIdx + 2] = ((i + 1) % segments) + 1;\n  }\n\n  return new MeshGeometry({\n    positions,\n    uvs,\n    indices,\n  });\n}\n\n/**\n * Updates an existing pill geometry with new expansion value.\n * More efficient than recreating the geometry.\n */\nexport function updatePillGeometry(\n  geometry: MeshGeometry,\n  radius: number,\n  expansion: number,\n  segments: number = 32\n): void {\n  const posAttr = geometry.getAttribute('aPosition');\n  const uvAttr = geometry.getAttribute('aUV');\n  if (!posAttr || !uvAttr) return;\n\n  const positions = posAttr.buffer.data as Float32Array;\n  const uvs = uvAttr.buffer.data as Float32Array;\n  const halfExpansion = expansion / 2;\n\n  const totalWidth = radius * 2 + expansion;\n  const totalHeight = radius * 2;\n\n  for (let i = 0; i < segments; i++) {\n    const angle = (i / segments) * Math.PI * 2 - Math.PI / 2;\n    const idx = (i + 1) * 2;\n\n    let x: number, y: number;\n\n    if (angle >= -Math.PI / 2 && angle <= Math.PI / 2) {\n      x = Math.cos(angle) * radius + halfExpansion;\n      y = Math.sin(angle) * radius;\n    } else {\n      x = Math.cos(angle) * radius - halfExpansion;\n      y = Math.sin(angle) * radius;\n    }\n\n    // Normalize to -0.5 to 0.5 range\n    positions[idx] = x / totalWidth;\n    positions[idx + 1] = y / totalHeight;\n\n    // UVs normalized to 0-1 range\n    uvs[idx] = (x / totalWidth) + 0.5;\n    uvs[idx + 1] = (y / totalHeight) + 0.5;\n  }\n\n  posAttr.buffer.update();\n  uvAttr.buffer.update();\n}\n\n/**\n * Creates a normal map for a pill/stadium shape with bevel effects.\n * The pill is a rectangle with semicircular caps on each end.\n */\nexport function createPillNormalMap(\n  width: number,\n  height: number,\n  expansion: number,\n  bevel: number,\n  shape: SurfaceShape,\n  invertNormals: boolean = false,\n  invertCurve: boolean = false,\n): Texture {\n  const w = Math.ceil(width);\n  const h = Math.ceil(height);\n  const data = new Uint8Array(w * h * 4);\n\n  // Pill dimensions: height determines the radius of the caps\n  const radius = h / 2;\n  const halfExpansion = expansion / 2;\n\n  for (let y = 0; y < h; y++) {\n    for (let x = 0; x < w; x++) {\n      let nx = 0;\n      let ny = 0;\n      let nz = 1;\n      let alpha = 255;\n\n      // Use pixel centers for proper symmetry\n      const cx = (w - 1) / 2;\n      const cy = (h - 1) / 2;\n      const relX = x - cx;\n      const relY = y - cy;\n\n      // Calculate distance to pill boundary\n      let distToBoundary = 0;\n      let dirX = 0;\n      let dirY = 0;\n\n      const absX = Math.abs(relX);\n      const absY = Math.abs(relY);\n\n      if (absX <= halfExpansion) {\n        // In the rectangular middle section\n        distToBoundary = radius - absY;\n        dirX = 0;\n        dirY = relY > 0 ? 1 : -1;\n      } else {\n        // In one of the semicircular caps\n        const capCenterX = relX > 0 ? halfExpansion : -halfExpansion;\n        const dx = relX - capCenterX;\n        const dy = relY;\n        const distFromCapCenter = Math.sqrt(dx * dx + dy * dy);\n        distToBoundary = radius - distFromCapCenter;\n\n        if (distFromCapCenter > 0.001) {\n          dirX = dx / distFromCapCenter;\n          dirY = dy / distFromCapCenter;\n        }\n      }\n\n      // Hard cutoff for pixels outside the shape\n      if (distToBoundary < 0) {\n        alpha = 0;\n      }\n\n      // Apply bevel based on distance to boundary\n      if (bevel > 0 && distToBoundary < bevel && distToBoundary >= 0) {\n        let t = 1 - distToBoundary / bevel;\n        if (invertCurve) t = 1 - t;\n        const { derivative } = getHeightAndDerivative(t, shape);\n        const sign = invertCurve ? -1 : 1;\n        nx = dirX * derivative * 0.5 * sign;\n        ny = dirY * derivative * 0.5 * sign;\n        if (invertNormals) {\n          nx = -nx;\n          ny = -ny;\n        }\n      }\n\n      const len = Math.sqrt(nx * nx + ny * ny + nz * nz);\n      nx /= len;\n      ny /= len;\n      nz /= len;\n\n      const index = (y * w + x) * 4;\n      data[index] = ((nx * 0.5 + 0.5) * 255) | 0;\n      data[index + 1] = ((ny * 0.5 + 0.5) * 255) | 0;\n      data[index + 2] = ((nz * 0.5 + 0.5) * 255) | 0;\n      data[index + 3] = alpha;\n    }\n  }\n\n  return Texture.from({\n    resource: data,\n    width: w,\n    height: h,\n  });\n}\n","import type { EdgeMaskConfig, EdgeTactic } from '../core/types.js';\n\nexport function hexToVec3(hex: number): [number, number, number] {\n  return [\n    ((hex >> 16) & 0xff) / 255,\n    ((hex >> 8) & 0xff) / 255,\n    (hex & 0xff) / 255,\n  ];\n}\n\nexport function createDefaultEdgeTactic(overrides?: Partial<EdgeTactic>): EdgeTactic {\n  return {\n    enabled: false,\n    rangeStart: 0,\n    rangeEnd: 0.3,\n    strength: 1,\n    opacity: 1,\n    ...overrides,\n  };\n}\n\nexport function createDefaultEdgeMask(overrides?: Partial<EdgeMaskConfig>): EdgeMaskConfig {\n  return {\n    cutoff: 0.001,\n    blur: 0,\n    invert: false,\n    smoothing: createDefaultEdgeTactic({ rangeEnd: 0.3, strength: 1 }),\n    contrast: createDefaultEdgeTactic({ rangeEnd: 0.3, strength: 0.7 }),\n    alpha: createDefaultEdgeTactic({ rangeEnd: 0.2, strength: 1 }),\n    tint: createDefaultEdgeTactic({ rangeEnd: 0.5, strength: 0.5 }),\n    darken: createDefaultEdgeTactic({ rangeEnd: 0.3, strength: 0.3 }),\n    desaturate: createDefaultEdgeTactic({ rangeEnd: 0.4, strength: 0.5 }),\n    ...overrides,\n  };\n}\n\nexport { createPillGeometry, updatePillGeometry, createPillNormalMap } from './PillGeometry.js';\n","import { Filter, Sprite, Texture, GlProgram } from 'pixi.js';\nimport type { RenderTexture, Renderer } from 'pixi.js';\nimport { SceneRTManager } from '../core/SceneRTManager.js';\nimport type { RenderQualityOptions } from '../core/types.js';\nimport type { GlassPanel } from '../panels/GlassPanel.js';\nimport type { Pipeline, PipelineContext } from './BasePipeline.js';\nimport { hexToVec3 } from '../utils/index.js';\n\nclass CompatibilityFilter extends Filter {\n  constructor() {\n    const fragment = `\n      precision mediump float;\n      varying vec2 vTextureCoord;\n      uniform sampler2D uSceneColor;\n      uniform sampler2D uNormalMap;\n      uniform vec2 uInvResolution;\n      uniform float uDispersion;\n      uniform float uRoughness;\n      uniform float uDisplacementScale;\n      uniform vec3 uTint;\n      uniform float uOpacity;\n      uniform bool uEnableDispersion;\n      vec3 sampleScene(vec2 uv){\n        return texture2D(uSceneColor, clamp(uv, vec2(0.001), vec2(0.999))).rgb;\n      }\n      void main(){\n        vec3 normal = texture2D(uNormalMap, vTextureCoord).xyz * 2.0 - 1.0;\n        vec2 offset = normal.xy * uDisplacementScale;\n        vec2 baseUV = vTextureCoord + offset;\n        vec3 color = sampleScene(baseUV);\n        if(uEnableDispersion){\n          color.r = sampleScene(baseUV + offset * (1.0 + uDispersion)).r;\n          color.b = sampleScene(baseUV - offset * (1.0 + uDispersion)).b;\n        }\n        float radius = uRoughness * 4.0;\n        if(radius > 0.001){\n          vec3 blurAccum = vec3(0.0);\n          float taps = 0.0;\n          for(int i=0;i<4;i++){\n            float angle = 6.2831853 * float(i) / 4.0;\n            vec2 sampleOffset = vec2(cos(angle), sin(angle)) * radius * uInvResolution;\n            blurAccum += sampleScene(baseUV + sampleOffset);\n            taps += 1.0;\n          }\n          color = mix(color, blurAccum / max(taps, 1.0), 0.7);\n        }\n        gl_FragColor = vec4(color * uTint * uOpacity, uOpacity);\n      }\n    `;\n    super({\n      glProgram: new GlProgram({\n          vertex: `\n            attribute vec2 aVertexPosition;\n            attribute vec2 aTextureCoord;\n            uniform mat3 projectionMatrix;\n            varying vec2 vTextureCoord;\n            void main(void){\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n                vTextureCoord = aTextureCoord;\n            }\n          `,\n          fragment,\n      }),\n      resources: {\n        uSceneColor: Texture.WHITE.source,\n        uNormalMap: Texture.WHITE.source,\n        uniforms: {\n            uInvResolution: { value: [1, 1], type: 'vec2<f32>' },\n            uDispersion: { value: 0, type: 'f32' },\n            uRoughness: { value: 0, type: 'f32' },\n            uDisplacementScale: { value: 0.01, type: 'f32' },\n            uTint: { value: [1, 1, 1], type: 'vec3<f32>' },\n            uOpacity: { value: 1, type: 'f32' },\n            uEnableDispersion: { value: 0, type: 'f32' }, // boolean as float\n        }\n      },\n    });\n  }\n}\n\nexport class WebGL1Pipeline implements Pipeline {\n  readonly id = 'webgl1';\n  private readonly filter = new CompatibilityFilter();\n  private readonly rtManager: SceneRTManager;\n  private readonly blitSprite: Sprite;\n\n  constructor(private readonly renderer: Renderer) {\n    this.rtManager = new SceneRTManager(renderer, false);\n    this.blitSprite = new Sprite(Texture.WHITE);\n  }\n\n  setup(): void {}\n\n  render(context: PipelineContext): void {\n    const { renderer, panels, quality, drawOpaqueScene } = context;\n    const targets = this.rtManager.ensure(\n      renderer.screen.width,\n      renderer.screen.height,\n      quality.renderScale,\n    );\n    \n    drawOpaqueScene(targets.sceneColor);\n    \n    this.blitSprite.texture = targets.sceneColor;\n    this.blitSprite.width = renderer.screen.width;\n    this.blitSprite.height = renderer.screen.height;\n    \n    renderer.render({ container: this.blitSprite, clear: true });\n    \n    const orderedPanels = [...panels].sort((a, b) => (a.zIndex ?? 0) - (b.zIndex ?? 0));\n    for (const panel of orderedPanels) {\n      this.applyFilter(panel, targets.sceneColor, quality);\n      renderer.render({ container: panel });\n    }\n  }\n\n  dispose(): void {\n    this.rtManager.dispose();\n  }\n\n  private applyFilter(\n    panel: GlassPanel,\n    sceneTexture: RenderTexture,\n    quality: RenderQualityOptions,\n  ): void {\n    const needsFilter =\n      Boolean(panel.normalMap || panel.dudvMap) ||\n      panel.glassMaterial.dispersion > 0.001 ||\n      panel.glassMaterial.roughness > 0.001;\n    if (!needsFilter) {\n      panel.filters = null;\n      return;\n    }\n    const resources = this.filter.resources;\n    // Assign textures to resources\n    (resources as any).uSceneColor = sceneTexture.source;\n    (resources as any).uNormalMap = (panel.normalMap ?? panel.dudvMap ?? Texture.WHITE).source;\n    \n    const uniforms = (resources as any).uniforms;\n    uniforms.uInvResolution = [1 / sceneTexture.width, 1 / sceneTexture.height];\n    uniforms.uDispersion = panel.glassMaterial.dispersion;\n    uniforms.uRoughness = panel.glassMaterial.roughness;\n    uniforms.uDisplacementScale = panel.glassMaterial.thickness * 0.1;\n    uniforms.uTint = hexToVec3(panel.glassMaterial.tint ?? 0xffffff);\n    uniforms.uOpacity = panel.glassMaterial.opacity;\n    uniforms.uEnableDispersion = quality.enableDispersion && panel.glassMaterial.dispersion > 0.001 ? 1 : 0;\n    \n    panel.filters = [this.filter];\n  }\n}\n","export const fullscreenVertex = `\nprecision mediump float;\nattribute vec2 aPosition;\nattribute vec2 aUV;\nvarying vec2 vUv;\nvoid main(void){\n  vUv = aUV;\n  vec2 pos = aPosition * 2.0 - 1.0;\n  gl_Position = vec4(pos, 0.0, 1.0);\n}\n`;\n\n// JFA Seed shader - identifies edge pixels from shape mask\nexport const jfaSeedFragment = `\nprecision highp float;\nvarying vec2 vUv;\nuniform sampler2D uNormalMap;\nuniform vec2 uTexelSize;\n\nvoid main() {\n  float center = texture2D(uNormalMap, vUv).a;\n\n  // Check if this is an edge pixel (shape mask transitions)\n  bool isEdge = false;\n\n  // Sample 8 neighbors for better edge detection\n  for (int dy = -1; dy <= 1; dy++) {\n    for (int dx = -1; dx <= 1; dx++) {\n      if (dx == 0 && dy == 0) continue;\n      vec2 offset = vec2(float(dx), float(dy)) * uTexelSize;\n      float neighbor = texture2D(uNormalMap, vUv + offset).a;\n\n      // Edge if center is inside shape but any neighbor is outside\n      if (center > 0.5 && neighbor < 0.5) {\n        isEdge = true;\n        break;\n      }\n    }\n    if (isEdge) break;\n  }\n\n  // Also check UV boundaries as edges\n  if (center > 0.5) {\n    if (vUv.x < uTexelSize.x || vUv.x > 1.0 - uTexelSize.x ||\n        vUv.y < uTexelSize.y || vUv.y > 1.0 - uTexelSize.y) {\n      isEdge = true;\n    }\n  }\n\n  if (isEdge) {\n    // Store own position as seed (normalized 0-1)\n    gl_FragColor = vec4(vUv, 0.0, 1.0);\n  } else if (center > 0.5) {\n    // Inside shape but not edge - mark as needing distance calc\n    gl_FragColor = vec4(-1.0, -1.0, 0.0, 1.0);\n  } else {\n    // Outside shape\n    gl_FragColor = vec4(-1.0, -1.0, 0.0, 0.0);\n  }\n}\n`;\n\n// JFA Flood shader - propagates nearest seed positions\nexport const jfaFloodFragment = `\nprecision highp float;\nvarying vec2 vUv;\nuniform sampler2D uPrevPass;\nuniform vec2 uTexelSize;\nuniform float uStepSize;\n\nvoid main() {\n  vec4 bestSeed = texture2D(uPrevPass, vUv);\n  float bestDist = 999999.0;\n\n  // Calculate distance to current best seed\n  if (bestSeed.x >= 0.0) {\n    vec2 diff = vUv - bestSeed.xy;\n    bestDist = dot(diff, diff);\n  }\n\n  // Check 8 neighbors at current step size\n  for (int dy = -1; dy <= 1; dy++) {\n    for (int dx = -1; dx <= 1; dx++) {\n      if (dx == 0 && dy == 0) continue;\n\n      vec2 neighborUV = vUv + vec2(float(dx), float(dy)) * uStepSize * uTexelSize;\n\n      // Bounds check\n      if (neighborUV.x < 0.0 || neighborUV.x > 1.0 || neighborUV.y < 0.0 || neighborUV.y > 1.0) {\n        continue;\n      }\n\n      vec4 neighborSeed = texture2D(uPrevPass, neighborUV);\n\n      // If neighbor has a valid seed\n      if (neighborSeed.x >= 0.0) {\n        vec2 diff = vUv - neighborSeed.xy;\n        float dist = dot(diff, diff);\n\n        if (dist < bestDist) {\n          bestDist = dist;\n          bestSeed = neighborSeed;\n        }\n      }\n    }\n  }\n\n  gl_FragColor = bestSeed;\n}\n`;\n\n// JFA Distance shader - converts seed positions to actual distances\nexport const jfaDistanceFragment = `\nprecision highp float;\nvarying vec2 vUv;\nuniform sampler2D uSeedMap;\nuniform float uMaxDistance;\n\nvoid main() {\n  vec4 seed = texture2D(uSeedMap, vUv);\n\n  if (seed.x < 0.0) {\n    // No seed found (outside shape or error)\n    gl_FragColor = vec4(0.0, 0.0, 0.0, seed.a);\n    return;\n  }\n\n  // Calculate actual distance\n  vec2 diff = vUv - seed.xy;\n  float dist = length(diff);\n\n  // Normalize to 0-1 range based on max distance\n  float normalizedDist = clamp(dist / uMaxDistance, 0.0, 1.0);\n\n  gl_FragColor = vec4(normalizedDist, normalizedDist, normalizedDist, seed.a);\n}\n`;\n\nexport const panelVertex = `\nprecision mediump float;\nattribute vec2 aPosition;\nattribute vec2 aUV;\nvarying vec2 vUv;\nuniform vec2 uPosition;\nuniform vec2 uScale;\nuniform vec2 uResolution;\nvoid main(void){\n  vUv = aUV;\n  vec2 worldPos = aPosition * uScale + uPosition;\n  vec2 clipPos = (worldPos / uResolution) * 2.0 - 1.0;\n  gl_Position = vec4(clipPos, 0.0, 1.0);\n}\n`;\n\nexport const refractionFragment = `\nprecision highp float;\nvarying vec2 vUv;\nuniform sampler2D uSceneColor;\nuniform sampler2D uNormalMap;\nuniform sampler2D uCausticsMap;\nuniform sampler2D uDistanceField;\nuniform vec2 uInvResolution;\nuniform float uIOR;\nuniform float uThickness;\nuniform float uDispersion;\nuniform float uRoughness;\nuniform float uOpacity;\nuniform bool uEnableDispersion;\nuniform bool uEnableCaustics;\nuniform vec3 uTint;\nuniform float uSpecular;\nuniform float uShininess;\nuniform float uShadow;\nuniform vec3 uLightDir;\nuniform float uBlurSamples;\nuniform float uBlurSpread;\nuniform float uBlurAngle;\nuniform float uBlurAnisotropy;\nuniform float uBlurGamma;\nuniform float uAberrationR;\nuniform float uAberrationB;\nuniform float uAO;\nuniform float uAORadius;\nuniform float uNoiseScale;\nuniform float uNoiseIntensity;\nuniform float uNoiseRotation;\nuniform float uNoiseThreshold;\nuniform float uEdgeSupersampling;\nuniform float uGlassSupersampling;\nuniform vec4 uEdgeIor; // rangeStart, rangeEnd, strength, enabled\nuniform vec2 uPanelSize;\n\n// Edge mask system\nuniform float uEdgeMaskCutoff;\nuniform float uEdgeMaskBlur;\nuniform bool uEdgeMaskInvert;\n\n// Edge tactics: vec4(rangeStart, rangeEnd, strength, opacity)\nuniform vec4 uEdgeSmoothing;\nuniform vec4 uEdgeContrast;\nuniform vec4 uEdgeAlpha;\nuniform vec4 uEdgeTint;\nuniform vec4 uEdgeDarken;\nuniform vec4 uEdgeDesaturate;\n\n// Tactic enable flags\nuniform bool uEnableSmoothing;\nuniform bool uEnableContrast;\nuniform bool uEnableAlpha;\nuniform bool uEnableTint;\nuniform bool uEnableDarken;\nuniform bool uEnableDesaturate;\n// Debug mode: 0=off, 1=edgeDist, 2=shapeMask, 3=normals\nuniform float uDebugMode;\n\n// Simple value noise\nfloat hash(vec2 p) {\n  return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat valueNoise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  f = f * f * (3.0 - 2.0 * f); // smoothstep\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n  return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nvec2 rotateUV(vec2 uv, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\n}\n\nvec3 sampleScene(vec2 uv){\n  return texture2D(uSceneColor, clamp(uv, vec2(0.001), vec2(0.999))).rgb;\n}\n\nvec3 sampleDispersion(vec2 baseUV, vec2 offset){\n  if(!uEnableDispersion){\n    return sampleScene(baseUV + offset);\n  }\n  vec3 result;\n  result.r = sampleScene(baseUV + offset * (1.0 + uDispersion * uAberrationR)).r;\n  result.g = sampleScene(baseUV + offset).g;\n  result.b = sampleScene(baseUV + offset * (1.0 - uDispersion * uAberrationB)).b;\n  return result;\n}\n\nvec3 sampleFrostedColor(vec2 baseUV, vec2 offset){\n  float radius = uRoughness * uBlurSpread;\n  vec3 accum = vec3(0.0);\n  float totalWeight = 0.0;\n  int samples = int(uBlurSamples);\n\n  // Golden angle spiral for better sample distribution\n  float goldenAngle = 2.39996323;\n\n  // Directional blur rotation matrix\n  float ca = cos(uBlurAngle);\n  float sa = sin(uBlurAngle);\n\n  for(int i=0;i<32;i++){\n    if(i >= samples) break;\n\n    // Normalized distance from center (0 to 1)\n    float t = float(i) / float(samples - 1);\n\n    // Apply gamma curve to sample distribution\n    float curvedT = pow(t, uBlurGamma);\n    float r = curvedT * radius;\n\n    float angle = float(i) * goldenAngle;\n    vec2 dir = vec2(cos(angle), sin(angle));\n\n    // Apply anisotropy (stretch in one direction)\n    if(uBlurAnisotropy > 0.001){\n      // Rotate to blur angle, apply stretch, rotate back\n      vec2 rotated = vec2(ca * dir.x + sa * dir.y, -sa * dir.x + ca * dir.y);\n      rotated.y *= (1.0 - uBlurAnisotropy);\n      dir = vec2(ca * rotated.x - sa * rotated.y, sa * rotated.x + ca * rotated.y);\n    }\n\n    vec2 sampleOffset = dir * r * uInvResolution;\n\n    // Weight samples by distance (softer falloff)\n    float w = 1.0 - curvedT * 0.5;\n    accum += sampleDispersion(baseUV, offset + sampleOffset) * w;\n    totalWeight += w;\n  }\n  return accum / max(totalWeight, 1.0);\n}\n\n// Apply a tactic based on edge mask value\n// Returns a factor in [0, 1] based on mask position within tactic range\n// mask: 0 at edge, 1 at center\n// rangeStart/rangeEnd: define the mask region where effect applies (0=edge, 1=center)\nfloat applyTactic(vec4 tactic, float mask) {\n  float rangeStart = tactic.x;\n  float rangeEnd = tactic.y;\n  float strength = tactic.z;\n  float opacity = tactic.w;\n\n  // Effect is full (1.0) when mask < rangeStart\n  // Effect fades to 0 as mask approaches rangeEnd\n  // Effect is 0 when mask > rangeEnd\n  float t = 1.0 - smoothstep(rangeStart, rangeEnd, mask);\n\n  // Apply strength and opacity\n  return t * strength * opacity;\n}\n\n// Calculate edge distance mask from shape mask (0 at edges, 1 at center)\n// Uses sampling to find distance to nearest edge of the shape\nfloat calculateEdgeMask(vec2 uv, sampler2D normalMap) {\n  // Sample in multiple directions to find distance to edge\n  float minDist = 1.0;\n\n  // Check 8 directions for coverage\n  for (int i = 0; i < 8; i++) {\n    float angle = float(i) * 0.785398; // PI/4\n    vec2 dir = vec2(cos(angle), sin(angle));\n\n    // March along direction with fine steps (0-30% of distance to center)\n    for (int step = 1; step <= 512; step++) {\n      float t = float(step) / 512.0 * 0.15; // Max 0.15 in UV space (30% of 0.5)\n      vec2 sampleUV = uv + dir * t;\n\n      // Check bounds\n      if (sampleUV.x < 0.0 || sampleUV.x > 1.0 || sampleUV.y < 0.0 || sampleUV.y > 1.0) {\n        minDist = min(minDist, t);\n        break;\n      }\n\n      // Check shape mask\n      float mask = texture2D(normalMap, sampleUV).a;\n      if (mask < 0.5) {\n        minDist = min(minDist, t);\n        break;\n      }\n    }\n  }\n\n  // Normalize to 0-1 range (0 at edge, 1 when dist >= 0.15)\n  return clamp(minDist / 0.15, 0.0, 1.0);\n}\n\nvoid main(){\n  vec2 screenUV = gl_FragCoord.xy * uInvResolution;\n\n  vec4 normalSample = texture2D(uNormalMap, vUv);\n  float shapeMask = normalSample.a;\n\n  // Discard pixels outside the shape (border radius)\n  if (shapeMask < 0.5) {\n    discard;\n  }\n\n  // Get edge distance from pre-computed JFA distance field (0 at edges, 1 at center)\n  float edgeDist = texture2D(uDistanceField, vUv).r;\n\n  // Optionally blur the edge distance\n  if (uEdgeMaskBlur > 0.0) {\n    float blurredDist = 0.0;\n    float blurWeight = 0.0;\n    float blurSize = uEdgeMaskBlur * 0.01;\n    for (int x = -2; x <= 2; x++) {\n      for (int y = -2; y <= 2; y++) {\n        vec2 offset = vec2(float(x), float(y)) * blurSize;\n        float sampleDist = texture2D(uDistanceField, vUv + offset).r;\n        float weight = 1.0 - length(vec2(float(x), float(y))) * 0.2;\n        blurredDist += sampleDist * weight;\n        blurWeight += weight;\n      }\n    }\n    edgeDist = blurredDist / blurWeight;\n  }\n\n  // Optionally invert the edge distance\n  if (uEdgeMaskInvert) {\n    edgeDist = 1.0 - edgeDist;\n  }\n\n  // Debug modes (early exit)\n  if (uDebugMode > 0.5) {\n    if (uDebugMode < 1.5) {\n      // Mode 1: Edge distance (black at edges, white at center)\n      gl_FragColor = vec4(vec3(edgeDist), 1.0);\n    } else if (uDebugMode < 2.5) {\n      // Mode 2: Shape mask (border radius alpha)\n      gl_FragColor = vec4(vec3(shapeMask), 1.0);\n    } else {\n      // Mode 3: Normal map visualization\n      gl_FragColor = vec4(normalSample.rgb, 1.0);\n    }\n    return;\n  }\n\n  // Simple refraction offset based on normal map\n  vec2 normal = normalSample.xy * 2.0 - 1.0;\n\n  // Calculate edge factors for each tactic\n  float smoothingFactor = uEnableSmoothing ? applyTactic(uEdgeSmoothing, edgeDist) : 0.0;\n  float contrastFactor = uEnableContrast ? applyTactic(uEdgeContrast, edgeDist) : 0.0;\n  float alphaFactor = uEnableAlpha ? applyTactic(uEdgeAlpha, edgeDist) : 0.0;\n  float tintFactor = uEnableTint ? applyTactic(uEdgeTint, edgeDist) : 0.0;\n  float darkenFactor = uEnableDarken ? applyTactic(uEdgeDarken, edgeDist) : 0.0;\n  float desaturateFactor = uEnableDesaturate ? applyTactic(uEdgeDesaturate, edgeDist) : 0.0;\n\n  // Apply noise distortion to normal (anchored to container via vUv)\n  if (uNoiseIntensity > 0.001) {\n    vec2 noiseUV = rotateUV(vUv * uNoiseScale, uNoiseRotation * 3.14159 / 180.0);\n    float n = valueNoise(noiseUV);\n    float n2 = valueNoise(noiseUV + vec2(100.0, 100.0));\n    // Apply threshold\n    n = smoothstep(uNoiseThreshold, 1.0, n) * (1.0 - uNoiseThreshold) + n * uNoiseThreshold;\n    n2 = smoothstep(uNoiseThreshold, 1.0, n2) * (1.0 - uNoiseThreshold) + n2 * uNoiseThreshold;\n    vec2 noiseNormal = (vec2(n, n2) - 0.5) * 2.0 * uNoiseIntensity;\n    normal += noiseNormal;\n  }\n\n  // Attenuate IOR effect at edges to prevent harsh distortion\n  float effectiveIOR = uIOR;\n  if (uEdgeIor.w > 0.5) {\n    // Apply tactic: reduce IOR at edges based on range and strength\n    float iorFactor = 1.0 - smoothstep(uEdgeIor.x, uEdgeIor.y, edgeDist);\n    effectiveIOR = mix(uIOR, 1.0, iorFactor * uEdgeIor.z);\n  }\n  vec2 offset = normal * uThickness * 0.1 * (effectiveIOR - 1.0);\n\n  vec3 refracted;\n  if (uGlassSupersampling > 1.0) {\n    // Supersample the entire glass panel\n    vec3 ssColor = vec3(0.0);\n    int samples = int(uGlassSupersampling * uGlassSupersampling);\n    float ssStep = 1.0 / uGlassSupersampling;\n    int sampleIdx = 0;\n    for (int x = 0; x < 4; x++) {\n      if (x >= int(uGlassSupersampling)) break;\n      for (int y = 0; y < 4; y++) {\n        if (y >= int(uGlassSupersampling)) break;\n        vec2 ssOffset = (vec2(float(x), float(y)) * ssStep - 0.5 + ssStep * 0.5) * uInvResolution;\n        ssColor += sampleFrostedColor(screenUV + ssOffset, offset);\n        sampleIdx++;\n      }\n    }\n    refracted = ssColor / float(sampleIdx);\n  } else {\n    refracted = sampleFrostedColor(screenUV, offset);\n  }\n  // Apply tint as color mix instead of multiply to preserve visibility\n  float tintStrength = 0.3;\n  refracted = mix(refracted, refracted * uTint + uTint * 0.1, tintStrength);\n\n  // Calculate lighting from normal map (now includes noise)\n  vec3 N = normalize(vec3(normal, normalSample.b * 2.0 - 1.0));\n  float NdotL = max(0.0, dot(N, normalize(uLightDir)));\n\n  // Specular highlight (Blinn-Phong)\n  vec3 viewDir = vec3(0.0, 0.0, 1.0);\n  vec3 halfDir = normalize(normalize(uLightDir) + viewDir);\n  float spec = pow(max(0.0, dot(N, halfDir)), uShininess) * uSpecular;\n\n  // Shadow from normal facing away from light\n  float shadowFactor = 1.0 - uShadow * (1.0 - NdotL);\n\n  // Ambient occlusion based on normal length (darker at edges/outside)\n  float normalDist = length(normal);\n  float aoFactor = 1.0 - uAO * smoothstep(0.0, uAORadius, normalDist);\n\n  // Apply lighting\n  refracted = refracted * shadowFactor * aoFactor + vec3(spec);\n\n  // Apply modular edge tactics\n\n  // Smoothing: reduce sharpness at edges by blending toward grey\n  if (uEnableSmoothing && smoothingFactor > 0.0) {\n    float lum = dot(refracted, vec3(0.299, 0.587, 0.114));\n    refracted = mix(refracted, vec3(lum), smoothingFactor * 0.5);\n  }\n\n  // Contrast reduction at edges\n  if (uEnableContrast && contrastFactor > 0.0) {\n    float contrastMult = 1.0 - contrastFactor * 0.5;\n    refracted *= contrastMult;\n  }\n\n  // Darken edges (vignette effect)\n  if (uEnableDarken && darkenFactor > 0.0) {\n    refracted *= (1.0 - darkenFactor * 0.7);\n  }\n\n  // Desaturate edges\n  if (uEnableDesaturate && desaturateFactor > 0.0) {\n    float luma = dot(refracted, vec3(0.299, 0.587, 0.114));\n    refracted = mix(refracted, vec3(luma), desaturateFactor);\n  }\n\n  // Tint opacity at edges\n  if (uEnableTint && tintFactor > 0.0) {\n    refracted = mix(refracted, refracted * uTint, tintFactor);\n  }\n\n  // Alpha falloff at edges\n  float finalAlpha = 1.0;\n  if (uEnableAlpha && alphaFactor > 0.0) {\n    finalAlpha = 1.0 - alphaFactor;\n  }\n\n  gl_FragColor = vec4(refracted, finalAlpha);\n}\n`;\n\nexport const revealageFragment = `\nprecision mediump float;\nvarying vec2 vUv;\nuniform sampler2D uNormalMap;\nuniform float uOpacity;\nvoid main(){\n  vec4 normalSample = texture2D(uNormalMap, vUv);\n  float mask = normalSample.a;\n\n  // Discard pixels outside the masked area (border radius)\n  if (mask < 0.01) {\n    discard;\n  }\n\n  float alpha = uOpacity * mask;\n  float revealage = exp(-3.0 * alpha);\n  gl_FragColor = vec4(revealage);\n}\n`;\n\nexport const compositeFragment = `\nprecision mediump float;\nvarying vec2 vUv;\nuniform sampler2D uSceneColor;\nuniform sampler2D uAccum;\nuniform sampler2D uReveal;\nvoid main(){\n  vec4 accum = texture2D(uAccum, vUv);\n  vec3 scene = texture2D(uSceneColor, vUv).rgb;\n\n  // Simple alpha blend: accum.a is opacity\n  vec3 result = mix(scene, accum.rgb, accum.a);\n  gl_FragColor = vec4(result, 1.0);\n}\n`;\n","import {\n  Container,\n  Mesh,\n  MeshGeometry,\n  RenderTexture,\n  Shader,\n  Sprite,\n  State,\n  Texture,\n  UniformGroup,\n} from 'pixi.js';\nimport type { Renderer } from 'pixi.js';\nimport { SceneRTManager } from '../core/SceneRTManager.js';\nimport type { GlassPanel } from '../panels/GlassPanel.js';\nimport {\n  compositeFragment,\n  fullscreenVertex,\n  jfaDistanceFragment,\n  jfaFloodFragment,\n  jfaSeedFragment,\n  panelVertex,\n  refractionFragment,\n  revealageFragment,\n} from '../shaders/webgl2.js';\nimport type { Pipeline, PipelineContext } from './BasePipeline.js';\nimport type { RenderQualityOptions } from '../core/types.js';\nimport { hexToVec3 } from '../utils/index.js';\n\n// Fullscreen quad with 0..1 positions for clip space mapping\nconst QUAD_GEOMETRY = new MeshGeometry({\n  positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n  uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n  indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n// Cache entry for JFA distance field per panel\ninterface JFACache {\n  distanceField: RenderTexture;\n  normalMapId: number; // Track which normal map was used\n  normalMapUpdateId: number; // Track texture updates\n  width: number;\n  height: number;\n}\n\nexport class WebGL2Pipeline implements Pipeline {\n  readonly id = 'webgl2';\n  private readonly rtManager: SceneRTManager;\n  private readonly refractShader: Shader;\n  private readonly revealageShader: Shader;\n  private readonly compositeShader: Shader;\n  private readonly fullScreenQuad: Mesh<MeshGeometry, Shader>;\n  private readonly shadowSprite: Sprite;\n  private readonly panelParent: Container;\n  private compositeRT?: RenderTexture;\n  private readonly compositeSprite: Sprite;\n  private accumRT?: RenderTexture;\n  private revealRT?: RenderTexture;\n\n  // JFA shaders and cache\n  private readonly jfaSeedShader: Shader;\n  private readonly jfaFloodShader: Shader;\n  private readonly jfaDistanceShader: Shader;\n  private jfaPingRT?: RenderTexture;\n  private jfaPongRT?: RenderTexture;\n  private readonly jfaCache: Map<GlassPanel, JFACache> = new Map();\n\n  constructor(\n    private readonly renderer: Renderer,\n    useDepth: boolean,\n  ) {\n    this.rtManager = new SceneRTManager(renderer, useDepth);\n    const refractUniforms = new UniformGroup({\n      uPosition: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n      uScale: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uResolution: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uInvResolution: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uIOR: { value: 1, type: 'f32' },\n      uThickness: { value: 1, type: 'f32' },\n      uDispersion: { value: 0, type: 'f32' },\n      uRoughness: { value: 0, type: 'f32' },\n      uOpacity: { value: 1, type: 'f32' },\n      uEnableDispersion: { value: 0, type: 'f32' },\n      uEnableCaustics: { value: 0, type: 'f32' },\n      uTint: { value: new Float32Array([1, 1, 1]), type: 'vec3<f32>' },\n      uSpecular: { value: 0, type: 'f32' },\n      uShininess: { value: 32, type: 'f32' },\n      uShadow: { value: 0, type: 'f32' },\n      uLightDir: { value: new Float32Array([0.5, 0.5, 1]), type: 'vec3<f32>' },\n      uBlurSamples: { value: 8, type: 'f32' },\n      uBlurSpread: { value: 4, type: 'f32' },\n      uBlurAngle: { value: 0, type: 'f32' },\n      uBlurAnisotropy: { value: 0, type: 'f32' },\n      uBlurGamma: { value: 1, type: 'f32' },\n      uAberrationR: { value: 1, type: 'f32' },\n      uAberrationB: { value: 1, type: 'f32' },\n      uAO: { value: 0, type: 'f32' },\n      uAORadius: { value: 0.5, type: 'f32' },\n      uNoiseScale: { value: 20, type: 'f32' },\n      uNoiseIntensity: { value: 0, type: 'f32' },\n      uNoiseRotation: { value: 0, type: 'f32' },\n      uNoiseThreshold: { value: 0, type: 'f32' },\n      uEdgeSupersampling: { value: 1, type: 'f32' },\n      uGlassSupersampling: { value: 1, type: 'f32' },\n      uEdgeIor: { value: new Float32Array([0, 0.15, 1, 1]), type: 'vec4<f32>' }, // rangeStart, rangeEnd, strength, enabled\n      uPanelSize: { value: new Float32Array([200, 200]), type: 'vec2<f32>' },\n      // Edge mask system\n      uEdgeMaskCutoff: { value: 0.001, type: 'f32' },\n      uEdgeMaskBlur: { value: 0, type: 'f32' },\n      uEdgeMaskInvert: { value: 0, type: 'f32' },\n      // Edge tactics: vec4(rangeStart, rangeEnd, strength, opacity)\n      uEdgeSmoothing: { value: new Float32Array([0, 0.3, 1, 1]), type: 'vec4<f32>' },\n      uEdgeContrast: { value: new Float32Array([0, 0.3, 0.7, 1]), type: 'vec4<f32>' },\n      uEdgeAlpha: { value: new Float32Array([0, 0.2, 1, 1]), type: 'vec4<f32>' },\n      uEdgeTint: { value: new Float32Array([0, 0.5, 0.5, 1]), type: 'vec4<f32>' },\n      uEdgeDarken: { value: new Float32Array([0, 0.3, 0.3, 1]), type: 'vec4<f32>' },\n      uEdgeDesaturate: { value: new Float32Array([0, 0.4, 0.5, 1]), type: 'vec4<f32>' },\n      // Tactic enables\n      uEnableSmoothing: { value: 0, type: 'f32' },\n      uEnableContrast: { value: 0, type: 'f32' },\n      uEnableAlpha: { value: 0, type: 'f32' },\n      uEnableTint: { value: 0, type: 'f32' },\n      uEnableDarken: { value: 0, type: 'f32' },\n      uEnableDesaturate: { value: 0, type: 'f32' },\n      uDebugMode: { value: 0, type: 'f32' },\n    });\n    this.refractShader = Shader.from({\n      gl: { vertex: panelVertex, fragment: refractionFragment },\n      resources: {\n        uSceneColor: Texture.WHITE.source,\n        uNormalMap: Texture.WHITE.source,\n        uCausticsMap: Texture.WHITE.source,\n        uDistanceField: Texture.WHITE.source,\n        panelUniforms: refractUniforms,\n      },\n    });\n    const revealUniforms = new UniformGroup({\n      uPosition: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n      uScale: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uResolution: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uOpacity: { value: 1, type: 'f32' },\n    });\n    this.revealageShader = Shader.from({\n      gl: { vertex: panelVertex, fragment: revealageFragment },\n      resources: {\n        uNormalMap: Texture.WHITE.source,\n        panelUniforms: revealUniforms,\n      },\n    });\n    this.compositeShader = Shader.from({\n      gl: { vertex: fullscreenVertex, fragment: compositeFragment },\n      resources: {\n        uSceneColor: Texture.WHITE.source,\n        uAccum: Texture.WHITE.source,\n        uReveal: Texture.WHITE.source,\n      },\n    });\n    this.fullScreenQuad = new Mesh({\n      geometry: QUAD_GEOMETRY,\n      shader: this.compositeShader,\n    });\n    this.fullScreenQuad.state = State.for2d();\n    this.fullScreenQuad.state.culling = false; // Disable culling\n    this.shadowSprite = new Sprite(Texture.WHITE);\n    this.panelParent = new Container();\n    this.panelParent.alpha = 1;\n    this.compositeSprite = new Sprite(Texture.EMPTY);\n    // Ensure composite sprite is visible and on top\n    this.compositeSprite.position.set(0, 0);\n    this.compositeSprite.visible = true;\n    this.compositeSprite.alpha = 1;\n    this.compositeSprite.zIndex = 9999; // Force on top\n\n    // JFA shaders\n    const jfaSeedUniforms = new UniformGroup({\n      uTexelSize: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n    });\n    this.jfaSeedShader = Shader.from({\n      gl: { vertex: fullscreenVertex, fragment: jfaSeedFragment },\n      resources: {\n        uNormalMap: Texture.WHITE.source,\n        jfaUniforms: jfaSeedUniforms,\n      },\n    });\n\n    const jfaFloodUniforms = new UniformGroup({\n      uTexelSize: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uStepSize: { value: 1, type: 'f32' },\n    });\n    this.jfaFloodShader = Shader.from({\n      gl: { vertex: fullscreenVertex, fragment: jfaFloodFragment },\n      resources: {\n        uPrevPass: Texture.WHITE.source,\n        jfaUniforms: jfaFloodUniforms,\n      },\n    });\n\n    const jfaDistanceUniforms = new UniformGroup({\n      uMaxDistance: { value: 0.15, type: 'f32' },\n    });\n    this.jfaDistanceShader = Shader.from({\n      gl: { vertex: fullscreenVertex, fragment: jfaDistanceFragment },\n      resources: {\n        uSeedMap: Texture.WHITE.source,\n        jfaUniforms: jfaDistanceUniforms,\n      },\n    });\n  }\n\n  setup(): void {}\n\n  render(context: PipelineContext): void {\n    const { renderer, panels, quality, drawOpaqueScene } = context;\n    const width = renderer.screen.width;\n    const height = renderer.screen.height;\n    const targets = this.rtManager.ensure(width, height, quality.renderScale);\n    this.ensureAccumTargets(width, height);\n    this.ensureCompositeTarget(width, height);\n\n    drawOpaqueScene(targets.sceneColor);\n\n    this.clearTarget(this.accumRT, 0, 0, 0, 0);\n    this.clearTarget(this.revealRT, 1, 1, 1, 1);\n\n    for (const panel of panels) {\n      this.renderPanel(panel, quality, targets.sceneColor);\n    }\n\n    this.fullScreenQuad.shader = this.compositeShader;\n    (this.compositeShader as any).resources.uSceneColor = targets.sceneColor.source;\n    (this.compositeShader as any).resources.uAccum = this.accumRT?.source;\n    (this.compositeShader as any).resources.uReveal = this.revealRT?.source;\n\n    this.fullScreenQuad.width = renderer.screen.width;\n    this.fullScreenQuad.height = renderer.screen.height;\n\n    this.fullScreenQuad.updateLocalTransform();\n    this.fullScreenQuad.worldTransform.copyFrom(this.fullScreenQuad.localTransform);\n\n    // Render composite quad to texture\n    renderer.render({ container: this.fullScreenQuad, target: this.compositeRT, clear: true });\n\n    if (this.compositeRT) {\n      this.compositeSprite.texture = this.compositeRT;\n      this.compositeSprite.width = width;\n      this.compositeSprite.height = height;\n      this.compositeSprite.visible = true;\n    }\n\n    this.renderContactShadows(panels, quality);\n  }\n\n  dispose(): void {\n    this.rtManager.dispose();\n    this.accumRT?.destroy(true);\n    this.revealRT?.destroy(true);\n    this.compositeRT?.destroy(true);\n    this.jfaPingRT?.destroy(true);\n    this.jfaPongRT?.destroy(true);\n    for (const cache of this.jfaCache.values()) {\n      cache.distanceField.destroy(true);\n    }\n    this.jfaCache.clear();\n  }\n\n  // Compute JFA distance field for a panel's normal map\n  private computeDistanceField(panel: GlassPanel): RenderTexture {\n    const normalMap = panel.normalMap ?? Texture.WHITE;\n    const width = normalMap.width;\n    const height = normalMap.height;\n    const normalMapId = (normalMap.source as any).uid ?? 0;\n    const normalMapUpdateId = (normalMap.source as any)._updateID ?? (normalMap.source as any).updateId ?? 0;\n\n    // Check cache - disabled for now as normal map updateId doesn't change on radius updates\n    // TODO: Add proper invalidation when panel properties change\n    const cached = this.jfaCache.get(panel);\n    // if (cached && cached.normalMapId === normalMapId && cached.normalMapUpdateId === normalMapUpdateId && cached.width === width && cached.height === height) {\n    //   return cached.distanceField;\n    // }\n\n    // Ensure ping-pong textures\n    if (!this.jfaPingRT || this.jfaPingRT.width !== width || this.jfaPingRT.height !== height) {\n      this.jfaPingRT?.destroy(true);\n      this.jfaPongRT?.destroy(true);\n      this.jfaPingRT = RenderTexture.create({ width, height, resolution: 1 });\n      this.jfaPongRT = RenderTexture.create({ width, height, resolution: 1 });\n    }\n\n    // Create or reuse distance field texture\n    let distanceField = cached?.distanceField;\n    if (!distanceField || distanceField.width !== width || distanceField.height !== height) {\n      distanceField?.destroy(true);\n      distanceField = RenderTexture.create({ width, height, resolution: 1 });\n    }\n\n    const texelSize = [1 / width, 1 / height];\n\n    // Step 1: Seed pass\n    const seedResources = (this.jfaSeedShader as any).resources;\n    seedResources.uNormalMap = normalMap.source;\n    const seedUniforms = seedResources.jfaUniforms?.uniforms;\n    if (seedUniforms) {\n      seedUniforms.uTexelSize[0] = texelSize[0];\n      seedUniforms.uTexelSize[1] = texelSize[1];\n    }\n\n    this.fullScreenQuad.shader = this.jfaSeedShader;\n    this.fullScreenQuad.width = 1;\n    this.fullScreenQuad.height = 1;\n    this.fullScreenQuad.updateLocalTransform();\n    this.fullScreenQuad.worldTransform.copyFrom(this.fullScreenQuad.localTransform);\n    this.renderer.render({ container: this.fullScreenQuad, target: this.jfaPingRT, clear: true });\n\n    // Step 2: Flood passes (log2 iterations)\n    const maxDim = Math.max(width, height);\n    const passes = Math.ceil(Math.log2(maxDim));\n    let readRT: RenderTexture = this.jfaPingRT!;\n    let writeRT: RenderTexture = this.jfaPongRT!;\n\n    const floodResources = (this.jfaFloodShader as any).resources;\n    const floodUniforms = floodResources.jfaUniforms?.uniforms;\n\n    for (let i = 0; i < passes; i++) {\n      const stepSize = Math.pow(2, passes - i - 1);\n\n      floodResources.uPrevPass = readRT.source;\n      if (floodUniforms) {\n        floodUniforms.uTexelSize[0] = texelSize[0];\n        floodUniforms.uTexelSize[1] = texelSize[1];\n        floodUniforms.uStepSize = stepSize;\n      }\n\n      this.fullScreenQuad.shader = this.jfaFloodShader;\n      this.renderer.render({ container: this.fullScreenQuad, target: writeRT, clear: true });\n\n      // Swap\n      const temp = readRT;\n      readRT = writeRT;\n      writeRT = temp;\n    }\n\n    // Step 3: Distance pass\n    const distResources = (this.jfaDistanceShader as any).resources;\n    distResources.uSeedMap = readRT.source;\n    const distUniforms = distResources.jfaUniforms?.uniforms;\n    if (distUniforms) {\n      distUniforms.uMaxDistance = 0.05; // Smaller = more detail in edge gradient\n    }\n\n    this.fullScreenQuad.shader = this.jfaDistanceShader;\n    this.renderer.render({ container: this.fullScreenQuad, target: distanceField, clear: true });\n\n    console.log('JFA computed:', width, 'x', height, 'passes:', passes);\n\n    // Cache result\n    this.jfaCache.set(panel, {\n      distanceField,\n      normalMapId,\n      normalMapUpdateId,\n      width,\n      height,\n    });\n\n    return distanceField;\n  }\n\n  private ensureAccumTargets(width: number, height: number): void {\n    const targetResolution = this.renderer.resolution;\n    if (!this.accumRT || this.accumRT.width !== width || this.accumRT.height !== height || this.accumRT.source.resolution !== targetResolution) {\n      this.accumRT?.destroy(true);\n      this.accumRT = RenderTexture.create({\n        width,\n        height,\n        resolution: targetResolution,\n      });\n    }\n    if (!this.revealRT || this.revealRT.width !== width || this.revealRT.height !== height || this.revealRT.source.resolution !== targetResolution) {\n      this.revealRT?.destroy(true);\n      this.revealRT = RenderTexture.create({\n        width,\n        height,\n        resolution: targetResolution,\n      });\n    }\n  }\n\n  private clearTarget(\n    target: RenderTexture | undefined,\n    r: number,\n    g: number,\n    b: number,\n    a: number,\n  ): void {\n    if (!target) return;\n    const dummy = new Container();\n    this.renderer.render({ container: dummy, target, clear: true, clearColor: [r, g, b, a] });\n  }\n\n  private renderPanel(\n    panel: GlassPanel,\n    quality: RenderQualityOptions,\n    sceneTarget: RenderTexture,\n  ): void {\n    if (!this.accumRT || !this.revealRT) return;\n    const normal = panel.normalMap ?? Texture.WHITE;\n    const screenWidth = this.renderer.screen.width;\n    const screenHeight = this.renderer.screen.height;\n\n    // Compute JFA distance field for this panel\n    const distanceField = this.computeDistanceField(panel);\n\n    const resources = (this.refractShader as any).resources;\n    if (resources) {\n      resources.uSceneColor = sceneTarget.source;\n      resources.uNormalMap = normal.source;\n      resources.uCausticsMap = (panel.causticsAtlas ?? Texture.WHITE).source;\n      resources.uDistanceField = distanceField.source;\n\n      // Update uniforms through UniformGroup in v8\n      const uniforms = resources.panelUniforms?.uniforms;\n      if (uniforms) {\n        // Use accumRT resolution since gl_FragCoord is in accumRT pixel space\n        const res = this.accumRT?.source?._resolution ?? this.renderer.resolution;\n        uniforms.uPosition[0] = panel.position.x;\n        uniforms.uPosition[1] = panel.position.y;\n        uniforms.uScale[0] = panel.scale.x;\n        uniforms.uScale[1] = panel.scale.y;\n        uniforms.uResolution[0] = screenWidth;\n        uniforms.uResolution[1] = screenHeight;\n        uniforms.uInvResolution[0] = 1 / (screenWidth * res);\n        uniforms.uInvResolution[1] = 1 / (screenHeight * res);\n        uniforms.uIOR = panel.glassMaterial.ior;\n        uniforms.uThickness = panel.glassMaterial.thickness;\n        uniforms.uDispersion = panel.glassMaterial.dispersion;\n        uniforms.uRoughness = panel.glassMaterial.roughness;\n        uniforms.uOpacity = panel.glassMaterial.opacity ?? 1;\n        uniforms.uEnableDispersion =\n          quality.enableDispersion && panel.glassMaterial.dispersion > 0.001 ? 1 : 0;\n        uniforms.uEnableCaustics = quality.enableCaustics && Boolean(panel.causticsAtlas) ? 1 : 0;\n        const tint = hexToVec3(panel.glassMaterial.tint ?? 0xffffff);\n        uniforms.uTint[0] = tint[0];\n        uniforms.uTint[1] = tint[1];\n        uniforms.uTint[2] = tint[2];\n        uniforms.uSpecular = panel.glassMaterial.specular ?? 0;\n        uniforms.uShininess = panel.glassMaterial.shininess ?? 32;\n        uniforms.uShadow = panel.glassMaterial.shadow ?? 0;\n        const lightDir = panel.glassMaterial.lightDir ?? [0.5, 0.5, 1];\n        uniforms.uLightDir[0] = lightDir[0];\n        uniforms.uLightDir[1] = lightDir[1];\n        uniforms.uLightDir[2] = lightDir[2];\n        uniforms.uBlurSamples = panel.glassMaterial.blurSamples ?? 8;\n        uniforms.uBlurSpread = panel.glassMaterial.blurSpread ?? 4;\n        uniforms.uBlurAngle = (panel.glassMaterial.blurAngle ?? 0) * Math.PI / 180;\n        uniforms.uBlurAnisotropy = panel.glassMaterial.blurAnisotropy ?? 0;\n        uniforms.uBlurGamma = panel.glassMaterial.blurGamma ?? 1;\n        uniforms.uAberrationR = panel.glassMaterial.aberrationR ?? 1;\n        uniforms.uAberrationB = panel.glassMaterial.aberrationB ?? 1;\n        uniforms.uAO = panel.glassMaterial.ao ?? 0;\n        uniforms.uAORadius = panel.glassMaterial.aoRadius ?? 0.5;\n        uniforms.uNoiseScale = panel.glassMaterial.noiseScale ?? 20;\n        uniforms.uNoiseIntensity = panel.glassMaterial.noiseIntensity ?? 0;\n        uniforms.uNoiseRotation = panel.glassMaterial.noiseRotation ?? 0;\n        uniforms.uNoiseThreshold = panel.glassMaterial.noiseThreshold ?? 0;\n        uniforms.uEdgeSupersampling = quality.edgeSupersampling ?? 1;\n        uniforms.uGlassSupersampling = panel.glassMaterial.glassSupersampling ?? 1;\n        uniforms.uEdgeIor[0] = panel.glassMaterial.edgeIorRangeStart ?? 0;\n        uniforms.uEdgeIor[1] = panel.glassMaterial.edgeIorRangeEnd ?? 0.15;\n        uniforms.uEdgeIor[2] = panel.glassMaterial.edgeIorStrength ?? 1;\n        uniforms.uEdgeIor[3] = panel.glassMaterial.edgeIorEnabled ? 1 : 0;\n        uniforms.uPanelSize[0] = panel.scale.x;\n        uniforms.uPanelSize[1] = panel.scale.y;\n\n        // Edge mask system\n        const edgeMask = panel.glassMaterial.edgeMask;\n        if (edgeMask) {\n          uniforms.uEdgeMaskCutoff = edgeMask.cutoff;\n          uniforms.uEdgeMaskBlur = edgeMask.blur;\n          uniforms.uEdgeMaskInvert = edgeMask.invert ? 1 : 0;\n\n          // Set tactic uniforms\n          const setTactic = (uniform: Float32Array, tactic: any) => {\n            uniform[0] = tactic.rangeStart;\n            uniform[1] = tactic.rangeEnd;\n            uniform[2] = tactic.strength;\n            uniform[3] = tactic.opacity;\n          };\n\n          setTactic(uniforms.uEdgeSmoothing, edgeMask.smoothing);\n          setTactic(uniforms.uEdgeContrast, edgeMask.contrast);\n          setTactic(uniforms.uEdgeAlpha, edgeMask.alpha);\n          setTactic(uniforms.uEdgeTint, edgeMask.tint);\n          setTactic(uniforms.uEdgeDarken, edgeMask.darken);\n          setTactic(uniforms.uEdgeDesaturate, edgeMask.desaturate);\n\n          uniforms.uEnableSmoothing = edgeMask.smoothing.enabled ? 1 : 0;\n          uniforms.uEnableContrast = edgeMask.contrast.enabled ? 1 : 0;\n          uniforms.uEnableAlpha = edgeMask.alpha.enabled ? 1 : 0;\n          uniforms.uEnableTint = edgeMask.tint.enabled ? 1 : 0;\n          uniforms.uEnableDarken = edgeMask.darken.enabled ? 1 : 0;\n          uniforms.uEnableDesaturate = edgeMask.desaturate.enabled ? 1 : 0;\n          uniforms.uDebugMode = (edgeMask as any).debugMode ?? 0;\n        } else {\n          // Legacy fallback\n          uniforms.uEdgeMaskCutoff = panel.glassMaterial.edgeMaskCutoff ?? 0.001;\n          uniforms.uEdgeMaskBlur = panel.glassMaterial.edgeBlur ?? 0;\n          uniforms.uEdgeMaskInvert = 0;\n          uniforms.uEnableSmoothing = 0;\n          uniforms.uEnableContrast = 0;\n          uniforms.uEnableAlpha = 0;\n          uniforms.uEnableTint = 0;\n          uniforms.uEnableDarken = 0;\n          uniforms.uEnableDesaturate = 0;\n        }\n      }\n    }\n\n    const prevShader = panel.shader;\n    panel.shader = this.refractShader as any;\n    this.drawPanelToTarget(panel, this.accumRT);\n\n    panel.shader = this.revealageShader as any;\n\n    const revealResources = (this.revealageShader as any).resources;\n    if (revealResources) {\n      revealResources.uNormalMap = normal.source;\n\n      const revealUniforms = revealResources.panelUniforms?.uniforms;\n      if (revealUniforms) {\n        revealUniforms.uPosition[0] = panel.position.x;\n        revealUniforms.uPosition[1] = panel.position.y;\n        revealUniforms.uScale[0] = panel.scale.x;\n        revealUniforms.uScale[1] = panel.scale.y;\n        revealUniforms.uResolution[0] = screenWidth;\n        revealUniforms.uResolution[1] = screenHeight;\n        revealUniforms.uOpacity = panel.glassMaterial.opacity;\n      }\n    }\n\n    this.drawPanelToTarget(panel, this.revealRT);\n    panel.shader = prevShader;\n  }\n\n  private renderContactShadows(panels: GlassPanel[], quality: RenderQualityOptions): void {\n    if (!quality.enableContactShadows) return;\n    for (const panel of panels) {\n      if (!panel.sdfShadow) continue;\n      this.shadowSprite.texture = panel.sdfShadow;\n      this.shadowSprite.position.copyFrom(panel.position);\n      this.shadowSprite.scale.copyFrom(panel.scale);\n      this.shadowSprite.rotation = panel.rotation;\n      this.shadowSprite.alpha = Math.min(panel.glassMaterial.opacity + 0.2, 0.9);\n      // this.shadowSprite.state.blendMode = BLEND_MODES.MULTIPLY;\n      this.renderer.render(this.shadowSprite);\n    }\n  }\n\n  getCompositeDisplay(): Container | undefined {\n    return this.compositeSprite;\n  }\n\n  private drawPanelToTarget(panel: GlassPanel, target: RenderTexture): void {\n    const renderer = this.renderer;\n    const gl = (renderer as any).gl as WebGL2RenderingContext;\n\n    // Clear parent and add only this panel\n    this.panelParent.removeChildren();\n    this.panelParent.addChild(panel);\n\n    // Update transforms for detached container in v8\n    panel.updateLocalTransform();\n    panel.worldTransform.copyFrom(panel.localTransform);\n\n    // Use standard alpha blending\n    if (gl) {\n      gl.enable(gl.BLEND);\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n    }\n\n    renderer.render({ container: this.panelParent, target, clear: false });\n\n    // Reset blend state\n    if (gl) {\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    }\n  }\n\n  private ensureCompositeTarget(width: number, height: number): void {\n    const targetResolution = this.renderer.resolution;\n    if (\n      !this.compositeRT ||\n      this.compositeRT.width !== width ||\n      this.compositeRT.height !== height ||\n      this.compositeRT.source.resolution !== targetResolution\n    ) {\n      this.compositeRT?.destroy(true);\n      this.compositeRT = RenderTexture.create({\n        width,\n        height,\n        resolution: targetResolution,\n      });\n      this.compositeSprite.texture = this.compositeRT;\n    }\n  }\n}\n","import type { Container, RenderTexture, Renderer, WebGLRenderer } from 'pixi.js';\nimport { AdaptiveQualityController } from '../core/AdaptiveQualityController.js';\nimport { CapabilityProbe } from '../core/CapabilityProbe.js';\nimport { EventBus } from '../core/EventBus.js';\nimport type {\n  AdaptiveDecision,\n  FallbackEvent,\n  GlassPanelProps,\n  GlassSystemOptions,\n  RenderQualityOptions,\n} from '../core/types.js';\nimport type { GlassPanel } from '../panels/GlassPanel.js';\nimport { GlassPanel as GlassPanelImpl } from '../panels/GlassPanel.js';\nimport type { Pipeline } from '../pipelines/BasePipeline.js';\nimport { WebGL1Pipeline } from '../pipelines/WebGL1Pipeline.js';\nimport { WebGL2Pipeline } from '../pipelines/WebGL2Pipeline.js';\n\ninterface GlassSystemEvents {\n  'quality:decision': AdaptiveDecision;\n  fallback: FallbackEvent;\n  [key: string]: any; // Add index signature to satisfy EventMap\n}\n\nexport class GlassSystem {\n  private pipeline: Pipeline;\n  private readonly panels: GlassPanel[] = [];\n  private readonly quality = new AdaptiveQualityController();\n  private drawOpaqueScene: (target: RenderTexture) => void = () => {};\n  private readonly events = new EventBus<GlassSystemEvents>();\n\n  constructor(\n    private readonly renderer: Renderer,\n    _options: GlassSystemOptions = {},\n  ) {\n    const gl = (renderer as WebGLRenderer).gl;\n    const capability = new CapabilityProbe(gl).run();\n    this.pipeline =\n      capability.tier === 'webgl2'\n        ? new WebGL2Pipeline(renderer, true)\n        : new WebGL1Pipeline(renderer);\n    if (capability.tier === 'webgl1') {\n      this.emitFallback('webgl', 'MRT unavailable, using compatibility pipeline');\n    }\n  }\n\n  setOpaqueSceneCallback(draw: (target: RenderTexture) => void): void {\n    this.drawOpaqueScene = draw;\n  }\n\n  createPanel(props: GlassPanelProps): GlassPanel {\n    const panel = new GlassPanelImpl(props);\n    this.panels.push(panel);\n    return panel;\n  }\n\n  removePanel(panel: GlassPanel): void {\n    const idx = this.panels.indexOf(panel);\n    if (idx >= 0) {\n      this.panels.splice(idx, 1);\n      panel.destroy({ children: true, texture: false, textureSource: false });\n    }\n  }\n\n  render(): void {\n    const start = performance.now();\n    const quality = this.quality.getQuality();\n    this.pipeline.render({\n      renderer: this.renderer,\n      panels: this.panels,\n      quality,\n      drawOpaqueScene: this.drawOpaqueScene,\n    });\n    const duration = performance.now() - start;\n    this.quality.record({ cpuMs: duration, timestamp: start });\n    const decision = this.quality.evaluate();\n    if (decision) {\n      this.events.emit('quality:decision', decision);\n    }\n  }\n\n  setQuality(options: Partial<RenderQualityOptions>): void {\n    this.quality.setOverrides(options);\n  }\n\n  destroy(): void {\n    for (const panel of this.panels) {\n      panel.destroy({ children: true, texture: false, textureSource: false });\n    }\n    this.panels.length = 0;\n    this.pipeline.dispose();\n    this.events.removeAll();\n  }\n\n  on<K extends keyof GlassSystemEvents>(\n    event: K,\n    listener: (payload: GlassSystemEvents[K]) => void,\n  ): void {\n    this.events.on(event, listener);\n  }\n\n  off<K extends keyof GlassSystemEvents>(\n    event: K,\n    listener: (payload: GlassSystemEvents[K]) => void,\n  ): void {\n    this.events.off(event, listener);\n  }\n\n  getPipelineId(): string {\n    return this.pipeline.id;\n  }\n\n  getCompositeDisplay(): Container | undefined {\n    if (typeof this.pipeline.getCompositeDisplay === 'function') {\n      return this.pipeline.getCompositeDisplay();\n    }\n    return undefined;\n  }\n\n  private emitFallback(target: string, message: string): void {\n    const event: FallbackEvent = { target, message, timestamp: performance.now() };\n    console.warn(`GlassSystem fallback: ${target} - ${message}`);\n    this.events.emit('fallback', event);\n  }\n}\n","import { Container, Graphics, Text } from 'pixi.js';\nimport type { Renderer } from 'pixi.js';\nimport type { AdaptiveDecision, RenderQualityOptions, TelemetrySample } from '../core/types.js';\n\ninterface HudMetrics {\n  quality: RenderQualityOptions;\n  fps: number;\n  lastDecision?: AdaptiveDecision;\n  telemetry: TelemetrySample[];\n}\n\nexport class GlassHUD {\n  readonly container = new Container();\n  private readonly panel: Graphics;\n  private readonly text: Text;\n  private visible = false;\n\n  constructor(private readonly renderer: Renderer) {\n    this.panel = new Graphics()\n      .beginFill(0x000000, 0.65)\n      .drawRoundedRect(0, 0, 260, 120, 8)\n      .endFill();\n    this.text = new Text('Glass HUD', { fontSize: 12, fill: 0xffffff });\n    this.text.position.set(12, 10);\n    this.container.addChild(this.panel, this.text);\n    this.container.visible = this.visible;\n    this.container.position.set(12, 12);\n  }\n\n  setVisible(visible: boolean): void {\n    this.visible = visible;\n    this.container.visible = visible;\n  }\n\n  update(metrics: HudMetrics): void {\n    if (!this.visible) return;\n    const { quality, fps, lastDecision } = metrics;\n    const lines = [\n      `FPS: ${fps.toFixed(1)}`,\n      `Scale: ${(quality.renderScale * 100).toFixed(0)}%`,\n      `Blur taps: ${quality.maxBlurTaps}`,\n      `Dispersion: ${quality.enableDispersion ? 'on' : 'off'}`,\n      `Caustics: ${quality.enableCaustics ? 'on' : 'off'}`,\n    ];\n    if (lastDecision) {\n      lines.push(`Action: ${lastDecision.action}`);\n    }\n    this.text.text = lines.join('\\n');\n  }\n}\n"],"names":["CapabilityProbe","gl","isWebGL2","extensions","tier","names","map","name","ext","param","DEFAULT_QUALITY","DEGRADATION_STEPS","q","AdaptiveQualityController","targetFrameMs","sample","overrides","avgCpu","sum","s","avgGpu","step","SceneRTManager","renderer","useDepth","Rectangle","width","height","scale","targetResolution","RenderTexture","_a","_c","_b","EventBus","event","listener","listeners","payload","key","make","material","GlassPresets","ior","clamped","PANEL_COUNTER","QUAD_GEOMETRY","MeshGeometry","BASIC_VERT","BASIC_FRAG","GlassPanel","Mesh","props","state","State","Shader","partial","textures","GlassOverlay","options","e","element","GlassSystem","target","composite","params","curve","zMin","zMax","edgeStretch","rect","x","y","dist","z","selector","entries","entry","item","lastRect","cssVisible","el","mutations","mutation","node","child","newRadius","config","dataIor","dataRoughness","isCircle","radius","cssRadius","bevel","shape","invertNormals","invertCurve","bezierCurve","circleSize","mapWidth","mapHeight","normalMap","createRoundedRectNormalMap","panel","poll","delayFactor","smoothFactor","transform","size","t","style","topLeft","topRight","bottomRight","bottomLeft","parseValue","value","dimension","getFirstValue","avgDimension","a","b","heightCircle","heightCircleDerivative","h","heightSquircle","inner","heightSquircleDerivative","smootherstep","smootherstepDerivative","cubicBezier","p0","p1","p2","p3","mt","cubicBezierDerivative","getBezierHeightAndDerivative","derivative","getHeightAndDerivative","d","convexH","convexD","concaveH","concaveD","blend","blendD","w","data","nx","ny","nz","alpha","cx","cy","relX","relY","innerW","innerH","distToBoundary","dirX","dirY","closestX","closestY","toEdgeX","toEdgeY","dx","dy","cornerDist","toDirX","toDirY","dirLen","sign","len","index","Texture","createPillGeometry","expansion","segments","halfExpansion","vertexCount","positions","uvs","totalWidth","totalHeight","i","angle","idx","triangleCount","indices","triIdx","updatePillGeometry","geometry","posAttr","uvAttr","createPillNormalMap","absX","absY","capCenterX","distFromCapCenter","hexToVec3","hex","createDefaultEdgeTactic","createDefaultEdgeMask","CompatibilityFilter","Filter","fragment","GlProgram","WebGL1Pipeline","Sprite","context","panels","quality","drawOpaqueScene","targets","orderedPanels","sceneTexture","resources","uniforms","fullscreenVertex","jfaSeedFragment","jfaFloodFragment","jfaDistanceFragment","panelVertex","refractionFragment","revealageFragment","compositeFragment","WebGL2Pipeline","refractUniforms","UniformGroup","revealUniforms","Container","jfaSeedUniforms","jfaFloodUniforms","jfaDistanceUniforms","_d","_e","cache","normalMapId","normalMapUpdateId","cached","distanceField","texelSize","seedResources","seedUniforms","maxDim","passes","readRT","writeRT","floodResources","floodUniforms","stepSize","temp","distResources","distUniforms","r","g","dummy","sceneTarget","normal","screenWidth","screenHeight","res","tint","lightDir","edgeMask","setTactic","uniform","tactic","prevShader","revealResources","_options","capability","draw","GlassPanelImpl","start","duration","decision","message","GlassHUD","Graphics","Text","visible","metrics","fps","lastDecision","lines"],"mappings":"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;AAAA;AAAA,EAkDlBC,GAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiDnBC,GAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA0BtBC,GAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBdC,GAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA0WrBC,GAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAoBpBC,GAA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"}