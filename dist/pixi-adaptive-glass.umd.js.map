{"version":3,"file":"pixi-adaptive-glass.umd.js","sources":["../src/core/CapabilityProbe.ts","../src/core/AdaptiveQualityController.ts","../src/core/SceneRTManager.ts","../src/core/EventBus.ts","../src/materials/GlassPresets.ts","../src/panels/GlassPanel.ts","../src/geometry/height-functions.ts","../src/utils/PillGeometry.ts","../src/utils/index.ts","../src/pipelines/WebGL1Pipeline.ts","../src/shaders/webgl2.ts","../src/pipelines/WebGL2Pipeline.ts","../src/system/GlassSystem.ts","../src/hud/GlassHUD.ts","../src/overlay/light-follow.ts","../src/overlay/dom-tracking.ts","../src/geometry/distance.ts","../src/geometry/normal-map.ts","../src/GlassOverlay.ts"],"sourcesContent":["import type { CapabilityResult, CapabilityTier } from './types.js';\n\nexport class CapabilityProbe {\n  private cached?: CapabilityResult;\n\n  constructor(private readonly gl: WebGLRenderingContext | WebGL2RenderingContext) {}\n\n  run(): CapabilityResult {\n    if (this.cached) {\n      return this.cached;\n    }\n\n    const isWebGL2 = this.isWebGL2Context(this.gl);\n    const extensions = this.queryExtensions([\n      'EXT_color_buffer_float',\n      'OES_texture_float_linear',\n      'OES_standard_derivatives',\n      'EXT_disjoint_timer_query_webgl2',\n      'EXT_disjoint_timer_query',\n    ]);\n\n    const tier: CapabilityTier = isWebGL2 && this.getMaxDrawBuffers() > 1 ? 'webgl2' : 'webgl1';\n\n    this.cached = {\n      tier,\n      maxDrawBuffers: this.getMaxDrawBuffers(),\n      extensions,\n    };\n    return this.cached;\n  }\n\n  private queryExtensions(names: string[]): Record<string, boolean> {\n    return names.reduce<Record<string, boolean>>((map, name) => {\n      map[name] = Boolean(this.gl.getExtension(name));\n      return map;\n    }, {});\n  }\n\n  private getMaxDrawBuffers(): number {\n    const ext = this.gl.getExtension('WEBGL_draw_buffers');\n    const param = this.isWebGL2Context(this.gl)\n      ? this.gl.MAX_DRAW_BUFFERS\n      : ext\n        ? ext.MAX_DRAW_BUFFERS_WEBGL\n        : 0;\n    if (!param) return 1;\n    const caps = this.gl.getParameter(param) as number | null;\n    return caps ?? 1;\n  }\n\n  private isWebGL2Context(\n    gl: WebGLRenderingContext | WebGL2RenderingContext,\n  ): gl is WebGL2RenderingContext {\n    return typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\n  }\n}\n","import type { AdaptiveAction, AdaptiveDecision, RenderQualityOptions, TelemetrySample } from './types.js';\n\nconst DEFAULT_QUALITY: RenderQualityOptions = {\n  renderScale: 1,\n  enableDispersion: true,\n  enableCaustics: true,\n  enableContactShadows: true,\n  maxBlurTaps: 9,\n  edgeSupersampling: 1,\n};\n\ntype DegradationStep = {\n  check: (q: RenderQualityOptions) => boolean;\n  apply: (q: RenderQualityOptions) => void;\n  action: AdaptiveAction;\n  reason: string;\n};\n\nconst DEGRADATION_STEPS: DegradationStep[] = [\n  { check: q => q.renderScale > 0.85, apply: q => { q.renderScale = 0.85; }, action: 'scale-rt-0-85', reason: 'Frame budget exceeded' },\n  { check: q => q.renderScale > 0.7, apply: q => { q.renderScale = 0.7; }, action: 'scale-rt-0-7', reason: 'Severe perf drop' },\n  { check: q => q.maxBlurTaps > 5, apply: q => { q.maxBlurTaps = 5; }, action: 'reduce-blur', reason: 'Sustained frame drops' },\n  { check: q => q.enableDispersion, apply: q => { q.enableDispersion = false; }, action: 'disable-dispersion', reason: 'Dispersion too expensive' },\n  { check: q => q.enableCaustics || q.enableContactShadows, apply: q => { q.enableCaustics = false; q.enableContactShadows = false; }, action: 'disable-caustics', reason: 'Optional overlays disabled' },\n];\n\nexport class AdaptiveQualityController {\n  private current: RenderQualityOptions = { ...DEFAULT_QUALITY };\n  private readonly telemetry: TelemetrySample[] = [];\n  private overrides: Partial<RenderQualityOptions> = {};\n\n  constructor(private readonly targetFrameMs = 100) {}\n\n  getQuality(): RenderQualityOptions {\n    return { ...this.current };\n  }\n\n  record(sample: TelemetrySample): void {\n    this.telemetry.push(sample);\n    if (this.telemetry.length > 120) {\n      this.telemetry.shift();\n    }\n  }\n\n  setOverrides(overrides: Partial<RenderQualityOptions>): void {\n    this.overrides = { ...this.overrides, ...overrides };\n    this.current = { ...this.current, ...this.overrides };\n  }\n\n  getTelemetry(): TelemetrySample[] {\n    return [...this.telemetry];\n  }\n\n  evaluate(): AdaptiveDecision | undefined {\n    if (this.telemetry.length < 30) return undefined;\n    const avgCpu = this.telemetry.reduce((sum, s) => sum + s.cpuMs, 0) / this.telemetry.length;\n    const avgGpu = this.telemetry.reduce((sum, s) => sum + (s.gpuMs ?? s.cpuMs), 0) / this.telemetry.length;\n    if (Math.max(avgCpu, avgGpu) <= this.targetFrameMs) return undefined;\n\n    for (const step of DEGRADATION_STEPS) {\n      if (step.check(this.current)) {\n        step.apply(this.current);\n        return { action: step.action, reason: step.reason };\n      }\n    }\n    return undefined;\n  }\n}\n","import { Rectangle, RenderTexture } from 'pixi.js';\nimport type { Renderer, WebGLRenderer } from 'pixi.js';\n\ninterface RtHandles {\n  sceneColor: RenderTexture;\n  sceneDepth?: RenderTexture;\n}\n\nexport class SceneRTManager {\n  private handles?: RtHandles;\n  private scale = 1;\n  private readonly clearRect = new Rectangle();\n\n  constructor(\n    private readonly renderer: Renderer,\n    private readonly useDepth: boolean,\n  ) {}\n\n  ensure(width: number, height: number, scale: number): RtHandles {\n    const targetResolution = this.renderer.resolution * scale;\n    if (\n      !this.handles ||\n      this.handles.sceneColor.width !== width ||\n      this.handles.sceneColor.height !== height ||\n      this.handles.sceneColor.source.resolution !== targetResolution\n    ) {\n      this.dispose();\n      this.handles = {\n        sceneColor: RenderTexture.create({\n          width,\n          height,\n          resolution: targetResolution,\n          scaleMode: 'linear',\n        }),\n        sceneDepth: this.useDepth\n          ? RenderTexture.create({\n              width,\n              height,\n              resolution: targetResolution,\n              scaleMode: 'nearest',\n            })\n          : undefined,\n      };\n      this.scale = scale;\n    }\n    return this.handles;\n  }\n\n  clearTargets(): void {\n    if (!this.handles) return;\n    this.clearRect.width = this.handles.sceneColor.width;\n    this.clearRect.height = this.handles.sceneColor.height;\n    \n    const renderer = this.renderer as WebGLRenderer;\n    renderer.renderTarget.bind(this.handles.sceneColor);\n    const gl = renderer.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    if (this.handles.sceneDepth) {\n      renderer.renderTarget.bind(this.handles.sceneDepth);\n      gl.clearColor(1, 0, 0, 1); \n      gl.clearDepth(1.0);\n      gl.clear(gl.DEPTH_BUFFER_BIT);\n    }\n  }\n\n  dispose(): void {\n    this.handles?.sceneColor.destroy(true);\n    this.handles?.sceneDepth?.destroy(true);\n    this.handles = undefined;\n  }\n}\n","type Listener<T> = (payload: T) => void;\n\ntype EventMap = Record<string, unknown>;\n\nexport class EventBus<Events extends EventMap> {\n  private listeners: { [K in keyof Events]?: Set<Listener<Events[K]>> } = {};\n\n  on<K extends keyof Events>(event: K, listener: Listener<Events[K]>): void {\n    let listeners = this.listeners[event];\n    if (!listeners) {\n      listeners = new Set();\n      this.listeners[event] = listeners;\n    }\n    listeners.add(listener);\n  }\n\n  off<K extends keyof Events>(event: K, listener: Listener<Events[K]>): void {\n    this.listeners[event]?.delete(listener);\n  }\n\n  emit<K extends keyof Events>(event: K, payload: Events[K]): void {\n    const listeners = this.listeners[event];\n    if (!listeners) return;\n    for (const listener of listeners) {\n      listener(payload);\n    }\n  }\n\n  removeAll(): void {\n    for (const key of Object.keys(this.listeners) as Array<keyof Events>) {\n      this.listeners[key]?.clear();\n    }\n  }\n}\n","import type { GlassMaterial } from '../core/types.js';\n\nconst make = (material: GlassMaterial): GlassMaterial => material;\n\nexport const GlassPresets = {\n  water(): GlassMaterial {\n    return make({\n      ior: 1.333,\n      thickness: 0.6,\n      roughness: 0.1,\n      dispersion: 0.02,\n      opacity: 1.0,\n      tint: 0x9fd9ff,\n    });\n  },\n  crownGlass(): GlassMaterial {\n    return make({\n      ior: 1.52,\n      thickness: 0.8,\n      roughness: 0.05,\n      dispersion: 0.04,\n      opacity: 1.0,\n      tint: 0xffffff,\n    });\n  },\n  acrylic(): GlassMaterial {\n    return make({\n      ior: 1.49,\n      thickness: 0.7,\n      roughness: 0.12,\n      dispersion: 0.01,\n      opacity: 1.0,\n      tint: 0xf7f7f7,\n    });\n  },\n  clear(): GlassMaterial {\n    return make({\n      ior: 1.52,\n      thickness: 0.8,\n      roughness: 0.05,\n      dispersion: 0.04,\n      opacity: 1.0,\n      tint: 0xffffff,\n    });\n  },\n  fromIOR(ior: number): GlassMaterial {\n    const clamped = Math.min(Math.max(ior, 1.0), 2.0);\n    return make({\n      ior: clamped,\n      thickness: 0.75,\n      roughness: 0.08,\n      dispersion: (clamped - 1) * 0.05,\n      opacity: 1.0,\n      tint: 0xffffff,\n    });\n  },\n};\n","  import { Mesh, MeshGeometry, Shader, State } from 'pixi.js';\nimport type { Texture } from 'pixi.js';\nimport type { CapabilityTier, GlassMaterial, GlassPanelProps } from '../core/types.js';\n\nlet PANEL_COUNTER = 0;\n\n// Use MeshGeometry which auto-maps to aPosition and aUV attributes\n// Centered geometry (-0.5 to 0.5) - position is center, scale is size\nconst QUAD_GEOMETRY = new MeshGeometry({\n  positions: new Float32Array([-0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5]),\n  uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n  indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\nconst BASIC_VERT = `\nprecision mediump float;\nattribute vec2 aPosition;\nattribute vec2 aUV;\nvarying vec2 vUv;\nuniform mat3 translationMatrix;\nuniform mat3 projectionMatrix;\nuniform mat3 uTextureMatrix;\nvoid main(void){\n  vUv = aUV;\n  gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aPosition, 1.0)).xy, 0.0, 1.0);\n}\n`;\n\nconst BASIC_FRAG = `\nprecision mediump float;\nvarying vec2 vUv;\nvoid main(void){\n  gl_FragColor = vec4(vUv, 0.0, 1.0);\n}\n`;\n\nexport class GlassPanel extends Mesh {\n  id: string;\n  glassMaterial: GlassMaterial;\n  normalMap?: Texture;\n  dudvMap?: Texture;\n  causticsAtlas?: Texture;\n  sdfShadow?: Texture;\n  private tier: CapabilityTier = 'webgl1';\n\n  constructor(props: GlassPanelProps) {\n    const state = State.for2d();\n    state.culling = false; // Disable culling to avoid winding order issues\n\n    super({\n      geometry: props.geometry ?? QUAD_GEOMETRY,\n      shader: Shader.from({\n        gl: {\n          vertex: BASIC_VERT,\n          fragment: BASIC_FRAG,\n        },\n      }) as any,\n      state,\n    });\n    this.id = props.id ?? `glass-panel-${++PANEL_COUNTER}`;\n    this.glassMaterial = props.material;\n    this.normalMap = props.normalMap;\n    this.dudvMap = props.dudvMap;\n    this.causticsAtlas = props.causticsAtlas;\n    this.sdfShadow = props.sdfShadow;\n    if (props.filters) {\n      this.filters = props.filters;\n    }\n  }\n\n  setMaterial(partial: Partial<GlassMaterial>): void {\n    this.glassMaterial = { ...this.glassMaterial, ...partial };\n  }\n\n  setTextures(textures: Partial<Omit<GlassPanelProps, 'material' | 'geometry'>>): void {\n    if (textures.normalMap) this.normalMap = textures.normalMap;\n    if (textures.dudvMap) this.dudvMap = textures.dudvMap;\n    if (textures.causticsAtlas) this.causticsAtlas = textures.causticsAtlas;\n    if (textures.sdfShadow) this.sdfShadow = textures.sdfShadow;\n  }\n\n  setTier(tier: CapabilityTier): void {\n    this.tier = tier;\n  }\n\n  getTier(): CapabilityTier {\n    return this.tier;\n  }\n}\n","import type { SurfaceShape } from '../core/types.js';\n\n/**\n * Convert distance to boundary into normalized t parameter.\n * t=0 at boundary edge, t=1 at plateau/center.\n */\nexport function distanceToT(distToBoundary: number, bevel: number): number {\n  return distToBoundary / bevel;\n}\n\n// Height functions for different surface shapes\n// t is normalized distance into bevel: 0 at boundary edge, 1 at plateau\n// height goes from 0 (edge) to 1 (plateau/center)\nexport function heightCircle(t: number): number {\n  return Math.sqrt(Math.max(0, 2 * t - t * t));\n}\n\nfunction heightCircleDerivative(t: number): number {\n  const h = Math.sqrt(Math.max(0.0001, 2 * t - t * t));\n  return (1 - t) / h;\n}\n\nexport function heightSquircle(t: number): number {\n  // Superellipse with n=3 for gentler curve between circle (n=2) and box (n=infinity)\n  // Using (1 - (1-t)^3)^(1/3) for smooth gradient\n  const inner = 1 - Math.pow(1 - t, 3);\n  return Math.pow(Math.max(0, inner), 1/3);\n}\n\nfunction heightSquircleDerivative(t: number): number {\n  const inner = 1 - Math.pow(1 - t, 3);\n  if (inner <= 0.0001) return 0;\n  // d/dt of (1 - (1-t)^3)^(1/3) = (1-t)^2 / (1 - (1-t)^3)^(2/3)\n  return Math.pow(1 - t, 2) / Math.pow(inner, 2/3);\n}\n\nexport function smootherstep(t: number): number {\n  const x = Math.max(0, Math.min(1, t));\n  return x * x * x * (x * (x * 6 - 15) + 10);\n}\n\nfunction smootherstepDerivative(t: number): number {\n  const x = Math.max(0, Math.min(1, t));\n  return 30 * x * x * (x - 1) * (x - 1);\n}\n\nexport function getHeightAndDerivative(\n  t: number,\n  shape: SurfaceShape\n): { height: number; derivative: number } {\n\n  switch (shape) {\n    case 'circle': {\n      // Circle profile: 0 at edge (t=0), 1 at plateau (t=1)\n      return { height: heightCircle(t), derivative: heightCircleDerivative(t) };\n    }\n    case 'squircle': {\n      // Squircle profile: 0 at edge (t=0), 1 at plateau (t=1)\n      return { height: heightSquircle(t), derivative: heightSquircleDerivative(t) };\n    }\n    case 'concave': {\n      // Quadratic ease-in: slow start, fast finish\n      const h = t * t;\n      const d = 2 * t;\n      return { height: h, derivative: d };\n    }\n    case 'lip': {\n      // S-curve: slow start, fast middle, slow end\n      const h = t < 0.5 ? 2 * t * t : 1 - 2 * (1 - t) * (1 - t);\n      const d = t < 0.5 ? 4 * t : 4 * (1 - t);\n      return { height: h, derivative: d };\n    }\n    case 'dome': {\n      // Full hemisphere - 0 at edge (t=0), 1 at plateau (t=1)\n      const s = 1 - t;\n      const h = Math.sqrt(Math.max(0, 1 - s * s));\n      const d = s > 0.001 ? s / h : 0;\n      return { height: h, derivative: d };\n    }\n    case 'wave': {\n      // Sinusoidal wave\n      const h = (1 - Math.cos(t * Math.PI)) / 2;\n      const d = (Math.PI * Math.sin(t * Math.PI)) / 2;\n      return { height: h, derivative: d };\n    }\n    case 'flat': {\n      // No bevel, completely flat at max height\n      return { height: 1, derivative: 0 };\n    }\n    case 'ramp': {\n      // Linear test pattern - height = t, derivative = 1\n      return { height: t, derivative: 1 };\n    }\n  }\n}\n","import { MeshGeometry, Texture } from 'pixi.js';\nimport type { SurfaceShape } from '../core/types.js';\nimport { distanceToT, getHeightAndDerivative } from '../geometry/height-functions.js';\n\n/**\n * Creates a pill/stadium geometry that can expand from circle to pill shape.\n * When expansion = 0, it's a perfect circle.\n * When expansion > 0, it becomes a pill/stadium shape.\n *\n * Uses normalized coordinates (-0.5 to 0.5) like the default QUAD_GEOMETRY,\n * so panel.scale controls the actual size.\n */\nexport function createPillGeometry(\n  radius: number,\n  expansion: number = 0,\n  segments: number = 32\n): MeshGeometry {\n  const halfExpansion = expansion / 2;\n\n  // Center vertex + vertices for both semicircles\n  const vertexCount = 1 + segments;\n  const positions = new Float32Array(vertexCount * 2);\n  const uvs = new Float32Array(vertexCount * 2);\n\n  // Total dimensions - scale is applied by panel\n  const totalWidth = radius * 2 + expansion;\n  const totalHeight = radius * 2;\n\n  // Center vertex at origin\n  positions[0] = 0;\n  positions[1] = 0;\n  uvs[0] = 0.5;\n  uvs[1] = 0.5;\n\n  // Generate vertices around the perimeter\n  for (let i = 0; i < segments; i++) {\n    const angle = (i / segments) * Math.PI * 2 - Math.PI / 2;\n    const idx = (i + 1) * 2;\n\n    let x: number, y: number;\n\n    // Right semicircle (angles -90째 to 90째)\n    if (angle >= -Math.PI / 2 && angle <= Math.PI / 2) {\n      x = Math.cos(angle) * radius + halfExpansion;\n      y = Math.sin(angle) * radius;\n    }\n    // Left semicircle (angles 90째 to 270째)\n    else {\n      x = Math.cos(angle) * radius - halfExpansion;\n      y = Math.sin(angle) * radius;\n    }\n\n    // Normalize: x to -0.5..0.5 over totalWidth, y to -0.5..0.5 over totalHeight\n    // This keeps circle round when width=height, elongates when width>height\n    positions[idx] = x / totalWidth;\n    positions[idx + 1] = y / totalHeight;\n\n    // UVs: 0..1 range\n    uvs[idx] = x / totalWidth + 0.5;\n    uvs[idx + 1] = y / totalHeight + 0.5;\n  }\n\n  // Create triangle fan from center\n  const triangleCount = segments;\n  const indices = new Uint32Array(triangleCount * 3);\n\n  for (let i = 0; i < segments; i++) {\n    const triIdx = i * 3;\n    indices[triIdx] = 0; // center\n    indices[triIdx + 1] = i + 1;\n    indices[triIdx + 2] = ((i + 1) % segments) + 1;\n  }\n\n  return new MeshGeometry({\n    positions,\n    uvs,\n    indices,\n  });\n}\n\n/**\n * Updates an existing pill geometry with new expansion value.\n * More efficient than recreating the geometry.\n */\nexport function updatePillGeometry(\n  geometry: MeshGeometry,\n  radius: number,\n  expansion: number,\n  segments: number = 32\n): void {\n  const posAttr = geometry.getAttribute('aPosition');\n  const uvAttr = geometry.getAttribute('aUV');\n  if (!posAttr || !uvAttr) return;\n\n  const positions = posAttr.buffer.data as Float32Array;\n  const uvs = uvAttr.buffer.data as Float32Array;\n  const halfExpansion = expansion / 2;\n\n  const totalWidth = radius * 2 + expansion;\n  const totalHeight = radius * 2;\n\n  for (let i = 0; i < segments; i++) {\n    const angle = (i / segments) * Math.PI * 2 - Math.PI / 2;\n    const idx = (i + 1) * 2;\n\n    let x: number, y: number;\n\n    if (angle >= -Math.PI / 2 && angle <= Math.PI / 2) {\n      x = Math.cos(angle) * radius + halfExpansion;\n      y = Math.sin(angle) * radius;\n    } else {\n      x = Math.cos(angle) * radius - halfExpansion;\n      y = Math.sin(angle) * radius;\n    }\n\n    // Normalize to -0.5 to 0.5 range\n    positions[idx] = x / totalWidth;\n    positions[idx + 1] = y / totalHeight;\n\n    // UVs normalized to 0-1 range\n    uvs[idx] = (x / totalWidth) + 0.5;\n    uvs[idx + 1] = (y / totalHeight) + 0.5;\n  }\n\n  posAttr.buffer.update();\n  uvAttr.buffer.update();\n}\n\n/**\n * Creates a normal map for a pill/stadium shape with bevel effects.\n * The pill is a rectangle with semicircular caps on each end.\n */\nexport function createPillNormalMap(\n  width: number,\n  height: number,\n  expansion: number,\n  bevel: number,\n  shape: SurfaceShape,\n  invertNormals: boolean = false,\n): Texture {\n  const w = Math.ceil(width);\n  const h = Math.ceil(height);\n  const data = new Uint8Array(w * h * 4);\n\n  // Pill dimensions: height determines the radius of the caps\n  const radius = h / 2;\n  const halfExpansion = expansion / 2;\n\n  for (let y = 0; y < h; y++) {\n    for (let x = 0; x < w; x++) {\n      let nx = 0;\n      let ny = 0;\n      let nz = 1;\n      let alpha = 255;\n\n      // Use pixel centers for proper symmetry\n      const cx = (w - 1) / 2;\n      const cy = (h - 1) / 2;\n      const relX = x - cx;\n      const relY = y - cy;\n\n      // Calculate distance to pill boundary\n      let distToBoundary = 0;\n      let dirX = 0;\n      let dirY = 0;\n\n      const absX = Math.abs(relX);\n      const absY = Math.abs(relY);\n\n      if (absX <= halfExpansion) {\n        // In the rectangular middle section\n        distToBoundary = radius - absY;\n        dirX = 0;\n        dirY = relY > 0 ? 1 : -1;\n      } else {\n        // In one of the semicircular caps\n        const capCenterX = relX > 0 ? halfExpansion : -halfExpansion;\n        const dx = relX - capCenterX;\n        const dy = relY;\n        const distFromCapCenter = Math.sqrt(dx * dx + dy * dy);\n        distToBoundary = radius - distFromCapCenter;\n\n        if (distFromCapCenter > 0.001) {\n          dirX = dx / distFromCapCenter;\n          dirY = dy / distFromCapCenter;\n        }\n      }\n\n      // Hard cutoff for pixels outside the shape\n      if (distToBoundary < 0) {\n        alpha = 0;\n      }\n\n      // Apply bevel based on distance to boundary\n      if (bevel > 0 && distToBoundary < bevel && distToBoundary >= 0) {\n        const t = distanceToT(distToBoundary, bevel);\n        const { derivative } = getHeightAndDerivative(t, shape);\n        nx = dirX * derivative * 0.5;\n        ny = dirY * derivative * 0.5;\n        if (invertNormals) {\n          nx = -nx;\n          ny = -ny;\n        }\n      }\n\n      const len = Math.sqrt(nx * nx + ny * ny + nz * nz);\n      nx /= len;\n      ny /= len;\n      nz /= len;\n\n      const index = (y * w + x) * 4;\n      data[index] = ((nx * 0.5 + 0.5) * 255) | 0;\n      data[index + 1] = ((ny * 0.5 + 0.5) * 255) | 0;\n      data[index + 2] = ((nz * 0.5 + 0.5) * 255) | 0;\n      data[index + 3] = alpha;\n    }\n  }\n\n  return Texture.from({\n    resource: data,\n    width: w,\n    height: h,\n  });\n}\n","import type { EdgeMaskConfig, EdgeTactic } from '../core/types.js';\n\nexport function hexToVec3(hex: number): [number, number, number] {\n  return [\n    ((hex >> 16) & 0xff) / 255,\n    ((hex >> 8) & 0xff) / 255,\n    (hex & 0xff) / 255,\n  ];\n}\n\nexport function createDefaultEdgeTactic(overrides?: Partial<EdgeTactic>): EdgeTactic {\n  return {\n    enabled: false,\n    rangeStart: 0,\n    rangeEnd: 0.3,\n    strength: 1,\n    opacity: 1,\n    ...overrides,\n  };\n}\n\nexport function createDefaultEdgeMask(overrides?: Partial<EdgeMaskConfig>): EdgeMaskConfig {\n  return {\n    cutoff: 0.001,\n    blur: 0,\n    invert: false,\n    smoothing: createDefaultEdgeTactic({ rangeEnd: 0.3, strength: 1 }),\n    contrast: createDefaultEdgeTactic({ rangeEnd: 0.3, strength: 0.7 }),\n    alpha: createDefaultEdgeTactic({ rangeEnd: 0.2, strength: 1 }),\n    tint: createDefaultEdgeTactic({ rangeEnd: 0.5, strength: 0.5 }),\n    darken: createDefaultEdgeTactic({ rangeEnd: 0.3, strength: 0.3 }),\n    desaturate: createDefaultEdgeTactic({ rangeEnd: 0.4, strength: 0.5 }),\n    ...overrides,\n  };\n}\n\nexport { createPillGeometry, updatePillGeometry, createPillNormalMap } from './PillGeometry.js';\n","import { Filter, Sprite, Texture, GlProgram } from 'pixi.js';\nimport type { RenderTexture, Renderer } from 'pixi.js';\nimport { SceneRTManager } from '../core/SceneRTManager.js';\nimport type { RenderQualityOptions } from '../core/types.js';\nimport type { GlassPanel } from '../panels/GlassPanel.js';\nimport type { Pipeline, PipelineContext } from './BasePipeline.js';\nimport { hexToVec3 } from '../utils/index.js';\n\nclass CompatibilityFilter extends Filter {\n  constructor() {\n    const fragment = `\n      precision mediump float;\n      varying vec2 vTextureCoord;\n      uniform sampler2D uSceneColor;\n      uniform sampler2D uNormalMap;\n      uniform vec2 uInvResolution;\n      uniform float uDispersion;\n      uniform float uRoughness;\n      uniform float uDisplacementScale;\n      uniform vec3 uTint;\n      uniform float uOpacity;\n      uniform bool uEnableDispersion;\n      vec3 sampleScene(vec2 uv){\n        return texture2D(uSceneColor, clamp(uv, vec2(0.001), vec2(0.999))).rgb;\n      }\n      void main(){\n        vec3 normal = texture2D(uNormalMap, vTextureCoord).xyz * 2.0 - 1.0;\n        vec2 offset = normal.xy * uDisplacementScale;\n        vec2 baseUV = vTextureCoord + offset;\n        vec3 color = sampleScene(baseUV);\n        if(uEnableDispersion){\n          color.r = sampleScene(baseUV + offset * (1.0 + uDispersion)).r;\n          color.b = sampleScene(baseUV - offset * (1.0 + uDispersion)).b;\n        }\n        float radius = uRoughness * 4.0;\n        if(radius > 0.001){\n          vec3 blurAccum = vec3(0.0);\n          float taps = 0.0;\n          for(int i=0;i<4;i++){\n            float angle = 6.2831853 * float(i) / 4.0;\n            vec2 sampleOffset = vec2(cos(angle), sin(angle)) * radius * uInvResolution;\n            blurAccum += sampleScene(baseUV + sampleOffset);\n            taps += 1.0;\n          }\n          color = mix(color, blurAccum / max(taps, 1.0), 0.7);\n        }\n        gl_FragColor = vec4(color * uTint * uOpacity, uOpacity);\n      }\n    `;\n    super({\n      glProgram: new GlProgram({\n          vertex: `\n            attribute vec2 aVertexPosition;\n            attribute vec2 aTextureCoord;\n            uniform mat3 projectionMatrix;\n            varying vec2 vTextureCoord;\n            void main(void){\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n                vTextureCoord = aTextureCoord;\n            }\n          `,\n          fragment,\n      }),\n      resources: {\n        uSceneColor: Texture.WHITE.source,\n        uNormalMap: Texture.WHITE.source,\n        uniforms: {\n            uInvResolution: { value: [1, 1], type: 'vec2<f32>' },\n            uDispersion: { value: 0, type: 'f32' },\n            uRoughness: { value: 0, type: 'f32' },\n            uDisplacementScale: { value: 0.01, type: 'f32' },\n            uTint: { value: [1, 1, 1], type: 'vec3<f32>' },\n            uOpacity: { value: 1, type: 'f32' },\n            uEnableDispersion: { value: 0, type: 'f32' }, // boolean as float\n        }\n      },\n    });\n  }\n}\n\nexport class WebGL1Pipeline implements Pipeline {\n  readonly id = 'webgl1';\n  private readonly filter = new CompatibilityFilter();\n  private readonly rtManager: SceneRTManager;\n  private readonly blitSprite: Sprite;\n\n  constructor(private readonly renderer: Renderer) {\n    this.rtManager = new SceneRTManager(renderer, false);\n    this.blitSprite = new Sprite(Texture.WHITE);\n  }\n\n  setup(): void {}\n\n  render(context: PipelineContext): void {\n    const { renderer, panels, quality, drawOpaqueScene } = context;\n    const targets = this.rtManager.ensure(\n      renderer.screen.width,\n      renderer.screen.height,\n      quality.renderScale,\n    );\n    \n    drawOpaqueScene(targets.sceneColor);\n    \n    this.blitSprite.texture = targets.sceneColor;\n    this.blitSprite.width = renderer.screen.width;\n    this.blitSprite.height = renderer.screen.height;\n    \n    renderer.render({ container: this.blitSprite, clear: true });\n    \n    const orderedPanels = [...panels].sort((a, b) => (a.zIndex ?? 0) - (b.zIndex ?? 0));\n    for (const panel of orderedPanels) {\n      this.applyFilter(panel, targets.sceneColor, quality);\n      renderer.render({ container: panel });\n    }\n  }\n\n  dispose(): void {\n    this.rtManager.dispose();\n  }\n\n  private applyFilter(\n    panel: GlassPanel,\n    sceneTexture: RenderTexture,\n    quality: RenderQualityOptions,\n  ): void {\n    const needsFilter =\n      Boolean(panel.normalMap || panel.dudvMap) ||\n      panel.glassMaterial.dispersion > 0.001 ||\n      panel.glassMaterial.roughness > 0.001;\n    if (!needsFilter) {\n      panel.filters = null;\n      return;\n    }\n    const resources = this.filter.resources;\n    // Assign textures to resources\n    (resources as any).uSceneColor = sceneTexture.source;\n    (resources as any).uNormalMap = (panel.normalMap ?? panel.dudvMap ?? Texture.WHITE).source;\n    \n    const uniforms = (resources as any).uniforms;\n    uniforms.uInvResolution = [1 / sceneTexture.width, 1 / sceneTexture.height];\n    uniforms.uDispersion = panel.glassMaterial.dispersion;\n    uniforms.uRoughness = panel.glassMaterial.roughness;\n    uniforms.uDisplacementScale = panel.glassMaterial.thickness * 0.1;\n    uniforms.uTint = hexToVec3(panel.glassMaterial.tint ?? 0xffffff);\n    uniforms.uOpacity = panel.glassMaterial.opacity;\n    uniforms.uEnableDispersion = quality.enableDispersion && panel.glassMaterial.dispersion > 0.001 ? 1 : 0;\n    \n    panel.filters = [this.filter];\n  }\n}\n","export const fullscreenVertex = `\nprecision mediump float;\nattribute vec2 aPosition;\nattribute vec2 aUV;\nvarying vec2 vUv;\nvoid main(void){\n  vUv = aUV;\n  vec2 pos = aPosition * 2.0 - 1.0;\n  gl_Position = vec4(pos, 0.0, 1.0);\n}\n`;\n\n// JFA Seed shader - identifies edge pixels from shape mask\nexport const jfaSeedFragment = `\nprecision highp float;\nvarying vec2 vUv;\nuniform sampler2D uNormalMap;\nuniform vec2 uTexelSize;\n\nvoid main() {\n  float center = texture2D(uNormalMap, vUv).a;\n\n  // Check if this is an edge pixel (shape mask transitions)\n  bool isEdge = false;\n\n  // Sample 8 neighbors for better edge detection\n  for (int dy = -1; dy <= 1; dy++) {\n    for (int dx = -1; dx <= 1; dx++) {\n      if (dx == 0 && dy == 0) continue;\n      vec2 offset = vec2(float(dx), float(dy)) * uTexelSize;\n      float neighbor = texture2D(uNormalMap, vUv + offset).a;\n\n      // Edge if center is inside shape but any neighbor is outside\n      if (center > 0.5 && neighbor < 0.5) {\n        isEdge = true;\n        break;\n      }\n    }\n    if (isEdge) break;\n  }\n\n  // Also check UV boundaries as edges\n  if (center > 0.5) {\n    if (vUv.x < uTexelSize.x || vUv.x > 1.0 - uTexelSize.x ||\n        vUv.y < uTexelSize.y || vUv.y > 1.0 - uTexelSize.y) {\n      isEdge = true;\n    }\n  }\n\n  if (isEdge) {\n    // Store own position as seed (normalized 0-1)\n    gl_FragColor = vec4(vUv, 0.0, 1.0);\n  } else if (center > 0.5) {\n    // Inside shape but not edge - mark as needing distance calc\n    gl_FragColor = vec4(-1.0, -1.0, 0.0, 1.0);\n  } else {\n    // Outside shape\n    gl_FragColor = vec4(-1.0, -1.0, 0.0, 0.0);\n  }\n}\n`;\n\n// JFA Flood shader - propagates nearest seed positions\nexport const jfaFloodFragment = `\nprecision highp float;\nvarying vec2 vUv;\nuniform sampler2D uPrevPass;\nuniform vec2 uTexelSize;\nuniform float uStepSize;\n\nvoid main() {\n  vec4 bestSeed = texture2D(uPrevPass, vUv);\n  float bestDist = 999999.0;\n\n  // Calculate distance to current best seed\n  if (bestSeed.x >= 0.0) {\n    vec2 diff = vUv - bestSeed.xy;\n    bestDist = dot(diff, diff);\n  }\n\n  // Check 8 neighbors at current step size\n  for (int dy = -1; dy <= 1; dy++) {\n    for (int dx = -1; dx <= 1; dx++) {\n      if (dx == 0 && dy == 0) continue;\n\n      vec2 neighborUV = vUv + vec2(float(dx), float(dy)) * uStepSize * uTexelSize;\n\n      // Bounds check\n      if (neighborUV.x < 0.0 || neighborUV.x > 1.0 || neighborUV.y < 0.0 || neighborUV.y > 1.0) {\n        continue;\n      }\n\n      vec4 neighborSeed = texture2D(uPrevPass, neighborUV);\n\n      // If neighbor has a valid seed\n      if (neighborSeed.x >= 0.0) {\n        vec2 diff = vUv - neighborSeed.xy;\n        float dist = dot(diff, diff);\n\n        if (dist < bestDist) {\n          bestDist = dist;\n          bestSeed = neighborSeed;\n        }\n      }\n    }\n  }\n\n  gl_FragColor = bestSeed;\n}\n`;\n\n// JFA Distance shader - converts seed positions to actual distances\nexport const jfaDistanceFragment = `\nprecision highp float;\nvarying vec2 vUv;\nuniform sampler2D uSeedMap;\nuniform float uMaxDistance;\n\nvoid main() {\n  vec4 seed = texture2D(uSeedMap, vUv);\n\n  if (seed.x < 0.0) {\n    // No seed found (outside shape or error)\n    gl_FragColor = vec4(0.0, 0.0, 0.0, seed.a);\n    return;\n  }\n\n  // Calculate actual distance\n  vec2 diff = vUv - seed.xy;\n  float dist = length(diff);\n\n  // Normalize to 0-1 range based on max distance\n  float normalizedDist = clamp(dist / uMaxDistance, 0.0, 1.0);\n\n  gl_FragColor = vec4(normalizedDist, normalizedDist, normalizedDist, seed.a);\n}\n`;\n\nexport const panelVertex = `\nprecision mediump float;\nattribute vec2 aPosition;\nattribute vec2 aUV;\nvarying vec2 vUv;\nuniform vec2 uPosition;\nuniform vec2 uScale;\nuniform vec2 uResolution;\nvoid main(void){\n  vUv = aUV;\n  vec2 worldPos = aPosition * uScale + uPosition;\n  vec2 clipPos = (worldPos / uResolution) * 2.0 - 1.0;\n  gl_Position = vec4(clipPos, 0.0, 1.0);\n}\n`;\n\nexport const refractionFragment = `\nprecision highp float;\nvarying vec2 vUv;\nuniform sampler2D uSceneColor;\nuniform sampler2D uNormalMap;\nuniform sampler2D uCausticsMap;\nuniform sampler2D uDistanceField;\nuniform vec2 uInvResolution;\nuniform float uIOR;\nuniform float uThickness;\nuniform float uDispersion;\nuniform float uRoughness;\nuniform float uOpacity;\nuniform bool uEnableDispersion;\nuniform bool uEnableCaustics;\nuniform vec3 uTint;\nuniform float uSpecular;\nuniform float uShininess;\nuniform float uShadow;\nuniform vec3 uLightDir;\nuniform float uBlurSamples;\nuniform float uBlurSpread;\nuniform float uBlurAngle;\nuniform float uBlurAnisotropy;\nuniform float uBlurGamma;\nuniform float uAberrationR;\nuniform float uAberrationB;\nuniform float uAO;\nuniform float uAORadius;\nuniform float uNoiseScale;\nuniform float uNoiseIntensity;\nuniform float uNoiseRotation;\nuniform float uNoiseThreshold;\nuniform float uEdgeSupersampling;\nuniform float uGlassSupersampling;\nuniform vec4 uEdgeIor; // rangeStart, rangeEnd, strength, enabled\nuniform vec2 uPanelSize;\n\n// Edge mask system\nuniform float uEdgeMaskCutoff;\nuniform float uEdgeMaskBlur;\nuniform bool uEdgeMaskInvert;\n\n// Edge tactics: vec4(rangeStart, rangeEnd, strength, opacity)\nuniform vec4 uEdgeSmoothing;\nuniform vec4 uEdgeContrast;\nuniform vec4 uEdgeAlpha;\nuniform vec4 uEdgeTint;\nuniform vec4 uEdgeDarken;\nuniform vec4 uEdgeDesaturate;\n\n// Tactic enable flags\nuniform bool uEnableSmoothing;\nuniform bool uEnableContrast;\nuniform bool uEnableAlpha;\nuniform bool uEnableTint;\nuniform bool uEnableDarken;\nuniform bool uEnableDesaturate;\n// Debug mode: 0=off, 1=edgeDist, 2=shapeMask, 3=normals\nuniform float uDebugMode;\n\n// Simple value noise\nfloat hash(vec2 p) {\n  return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat valueNoise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  f = f * f * (3.0 - 2.0 * f); // smoothstep\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n  return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nvec2 rotateUV(vec2 uv, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\n}\n\nvec3 sampleScene(vec2 uv){\n  return texture2D(uSceneColor, clamp(uv, vec2(0.001), vec2(0.999))).rgb;\n}\n\nvec3 sampleDispersion(vec2 baseUV, vec2 offset){\n  if(!uEnableDispersion){\n    return sampleScene(baseUV + offset);\n  }\n  vec3 result;\n  result.r = sampleScene(baseUV + offset * (1.0 + uDispersion * uAberrationR)).r;\n  result.g = sampleScene(baseUV + offset).g;\n  result.b = sampleScene(baseUV + offset * (1.0 - uDispersion * uAberrationB)).b;\n  return result;\n}\n\nvec3 sampleFrostedColor(vec2 baseUV, vec2 offset){\n  float radius = uRoughness * uBlurSpread;\n  vec3 accum = vec3(0.0);\n  float totalWeight = 0.0;\n  int samples = int(uBlurSamples);\n\n  // Golden angle spiral for better sample distribution\n  float goldenAngle = 2.39996323;\n\n  // Directional blur rotation matrix\n  float ca = cos(uBlurAngle);\n  float sa = sin(uBlurAngle);\n\n  for(int i=0;i<32;i++){\n    if(i >= samples) break;\n\n    // Normalized distance from center (0 to 1)\n    float t = float(i) / float(samples - 1);\n\n    // Apply gamma curve to sample distribution\n    float curvedT = pow(t, uBlurGamma);\n    float r = curvedT * radius;\n\n    float angle = float(i) * goldenAngle;\n    vec2 dir = vec2(cos(angle), sin(angle));\n\n    // Apply anisotropy (stretch in one direction)\n    if(uBlurAnisotropy > 0.001){\n      // Rotate to blur angle, apply stretch, rotate back\n      vec2 rotated = vec2(ca * dir.x + sa * dir.y, -sa * dir.x + ca * dir.y);\n      rotated.y *= (1.0 - uBlurAnisotropy);\n      dir = vec2(ca * rotated.x - sa * rotated.y, sa * rotated.x + ca * rotated.y);\n    }\n\n    vec2 sampleOffset = dir * r * uInvResolution;\n\n    // Weight samples by distance (softer falloff)\n    float w = 1.0 - curvedT * 0.5;\n    accum += sampleDispersion(baseUV, offset + sampleOffset) * w;\n    totalWeight += w;\n  }\n  return accum / max(totalWeight, 1.0);\n}\n\n// Apply a tactic based on edge mask value\n// Returns a factor in [0, 1] based on mask position within tactic range\n// mask: 0 at edge, 1 at center\n// rangeStart/rangeEnd: define the mask region where effect applies (0=edge, 1=center)\nfloat applyTactic(vec4 tactic, float mask) {\n  float rangeStart = tactic.x;\n  float rangeEnd = tactic.y;\n  float strength = tactic.z;\n  float opacity = tactic.w;\n\n  // Effect is full (1.0) when mask < rangeStart\n  // Effect fades to 0 as mask approaches rangeEnd\n  // Effect is 0 when mask > rangeEnd\n  float t = 1.0 - smoothstep(rangeStart, rangeEnd, mask);\n\n  // Apply strength and opacity\n  return t * strength * opacity;\n}\n\n// Calculate edge distance mask from shape mask (0 at edges, 1 at center)\n// Uses sampling to find distance to nearest edge of the shape\nfloat calculateEdgeMask(vec2 uv, sampler2D normalMap) {\n  // Sample in multiple directions to find distance to edge\n  float minDist = 1.0;\n\n  // Check 8 directions for coverage\n  for (int i = 0; i < 8; i++) {\n    float angle = float(i) * 0.785398; // PI/4\n    vec2 dir = vec2(cos(angle), sin(angle));\n\n    // March along direction with fine steps (0-30% of distance to center)\n    for (int step = 1; step <= 512; step++) {\n      float t = float(step) / 512.0 * 0.15; // Max 0.15 in UV space (30% of 0.5)\n      vec2 sampleUV = uv + dir * t;\n\n      // Check bounds\n      if (sampleUV.x < 0.0 || sampleUV.x > 1.0 || sampleUV.y < 0.0 || sampleUV.y > 1.0) {\n        minDist = min(minDist, t);\n        break;\n      }\n\n      // Check shape mask\n      float mask = texture2D(normalMap, sampleUV).a;\n      if (mask < 0.5) {\n        minDist = min(minDist, t);\n        break;\n      }\n    }\n  }\n\n  // Normalize to 0-1 range (0 at edge, 1 when dist >= 0.15)\n  return clamp(minDist / 0.15, 0.0, 1.0);\n}\n\nvoid main(){\n  vec2 screenUV = gl_FragCoord.xy * uInvResolution;\n\n  vec4 normalSample = texture2D(uNormalMap, vUv);\n  float shapeMask = normalSample.a;\n\n  // Discard pixels outside the shape (border radius) - skip when in debug mode\n  if (shapeMask < 0.5 && uDebugMode < 0.5) {\n    discard;\n  }\n\n  // Get edge distance from pre-computed JFA distance field (0 at edges, 1 at center)\n  float edgeDist = texture2D(uDistanceField, vUv).r;\n\n  // Optionally blur the edge distance\n  if (uEdgeMaskBlur > 0.0) {\n    float blurredDist = 0.0;\n    float blurWeight = 0.0;\n    float blurSize = uEdgeMaskBlur * 0.01;\n    for (int x = -2; x <= 2; x++) {\n      for (int y = -2; y <= 2; y++) {\n        vec2 offset = vec2(float(x), float(y)) * blurSize;\n        float sampleDist = texture2D(uDistanceField, vUv + offset).r;\n        float weight = 1.0 - length(vec2(float(x), float(y))) * 0.2;\n        blurredDist += sampleDist * weight;\n        blurWeight += weight;\n      }\n    }\n    edgeDist = blurredDist / blurWeight;\n  }\n\n  // Optionally invert the edge distance\n  if (uEdgeMaskInvert) {\n    edgeDist = 1.0 - edgeDist;\n  }\n\n  // Debug modes (early exit)\n  if (uDebugMode > 0.5) {\n    if (uDebugMode < 1.5) {\n      // Mode 1: Edge distance (black at edges, white at center)\n      gl_FragColor = vec4(vec3(edgeDist), 1.0);\n    } else if (uDebugMode < 2.5) {\n      // Mode 2: Shape mask (border radius alpha)\n      gl_FragColor = vec4(vec3(shapeMask), 1.0);\n    } else {\n      // Mode 3: Normal map visualization\n      gl_FragColor = vec4(normalSample.rgb, 1.0);\n    }\n    return;\n  }\n\n  // Simple refraction offset based on normal map\n  vec2 normal = normalSample.xy * 2.0 - 1.0;\n\n  // Calculate edge factors for each tactic\n  float smoothingFactor = uEnableSmoothing ? applyTactic(uEdgeSmoothing, edgeDist) : 0.0;\n  float contrastFactor = uEnableContrast ? applyTactic(uEdgeContrast, edgeDist) : 0.0;\n  float alphaFactor = uEnableAlpha ? applyTactic(uEdgeAlpha, edgeDist) : 0.0;\n  float tintFactor = uEnableTint ? applyTactic(uEdgeTint, edgeDist) : 0.0;\n  float darkenFactor = uEnableDarken ? applyTactic(uEdgeDarken, edgeDist) : 0.0;\n  float desaturateFactor = uEnableDesaturate ? applyTactic(uEdgeDesaturate, edgeDist) : 0.0;\n\n  // Apply noise distortion to normal (anchored to container via vUv)\n  if (uNoiseIntensity > 0.001) {\n    vec2 noiseUV = rotateUV(vUv * uNoiseScale, uNoiseRotation * 3.14159 / 180.0);\n    float n = valueNoise(noiseUV);\n    float n2 = valueNoise(noiseUV + vec2(100.0, 100.0));\n    // Apply threshold\n    n = smoothstep(uNoiseThreshold, 1.0, n) * (1.0 - uNoiseThreshold) + n * uNoiseThreshold;\n    n2 = smoothstep(uNoiseThreshold, 1.0, n2) * (1.0 - uNoiseThreshold) + n2 * uNoiseThreshold;\n    vec2 noiseNormal = (vec2(n, n2) - 0.5) * 2.0 * uNoiseIntensity;\n    normal += noiseNormal;\n  }\n\n  // Attenuate IOR effect at edges to prevent harsh distortion\n  float effectiveIOR = uIOR;\n  if (uEdgeIor.w > 0.5) {\n    // Apply tactic: reduce IOR at edges based on range and strength\n    float iorFactor = 1.0 - smoothstep(uEdgeIor.x, uEdgeIor.y, edgeDist);\n    effectiveIOR = mix(uIOR, 1.0, iorFactor * uEdgeIor.z);\n  }\n  vec2 offset = normal * uThickness * 0.1 * (effectiveIOR - 1.0);\n\n  vec3 refracted;\n  if (uGlassSupersampling > 1.0) {\n    // Supersample the entire glass panel\n    vec3 ssColor = vec3(0.0);\n    int samples = int(uGlassSupersampling * uGlassSupersampling);\n    float ssStep = 1.0 / uGlassSupersampling;\n    int sampleIdx = 0;\n    for (int x = 0; x < 4; x++) {\n      if (x >= int(uGlassSupersampling)) break;\n      for (int y = 0; y < 4; y++) {\n        if (y >= int(uGlassSupersampling)) break;\n        vec2 ssOffset = (vec2(float(x), float(y)) * ssStep - 0.5 + ssStep * 0.5) * uInvResolution;\n        ssColor += sampleFrostedColor(screenUV + ssOffset, offset);\n        sampleIdx++;\n      }\n    }\n    refracted = ssColor / float(sampleIdx);\n  } else {\n    refracted = sampleFrostedColor(screenUV, offset);\n  }\n  // Apply tint as color mix instead of multiply to preserve visibility\n  float tintStrength = 0.3;\n  refracted = mix(refracted, refracted * uTint + uTint * 0.1, tintStrength);\n\n  // Calculate lighting from normal map (now includes noise)\n  vec3 N = normalize(vec3(normal, normalSample.b * 2.0 - 1.0));\n  float NdotL = max(0.0, dot(N, normalize(uLightDir)));\n\n  // Specular highlight (Blinn-Phong)\n  vec3 viewDir = vec3(0.0, 0.0, 1.0);\n  vec3 halfDir = normalize(normalize(uLightDir) + viewDir);\n  float spec = pow(max(0.0, dot(N, halfDir)), uShininess) * uSpecular;\n\n  // Shadow from normal facing away from light\n  float shadowFactor = 1.0 - uShadow * (1.0 - NdotL);\n\n  // Ambient occlusion based on normal length (darker at edges/outside)\n  float normalDist = length(normal);\n  float aoFactor = 1.0 - uAO * smoothstep(0.0, uAORadius, normalDist);\n\n  // Apply lighting\n  refracted = refracted * shadowFactor * aoFactor + vec3(spec);\n\n  // Apply modular edge tactics\n\n  // Smoothing: reduce sharpness at edges by blending toward grey\n  if (uEnableSmoothing && smoothingFactor > 0.0) {\n    float lum = dot(refracted, vec3(0.299, 0.587, 0.114));\n    refracted = mix(refracted, vec3(lum), smoothingFactor * 0.5);\n  }\n\n  // Contrast reduction at edges\n  if (uEnableContrast && contrastFactor > 0.0) {\n    float contrastMult = 1.0 - contrastFactor * 0.5;\n    refracted *= contrastMult;\n  }\n\n  // Darken edges (vignette effect)\n  if (uEnableDarken && darkenFactor > 0.0) {\n    refracted *= (1.0 - darkenFactor * 0.7);\n  }\n\n  // Desaturate edges\n  if (uEnableDesaturate && desaturateFactor > 0.0) {\n    float luma = dot(refracted, vec3(0.299, 0.587, 0.114));\n    refracted = mix(refracted, vec3(luma), desaturateFactor);\n  }\n\n  // Tint opacity at edges\n  if (uEnableTint && tintFactor > 0.0) {\n    refracted = mix(refracted, refracted * uTint, tintFactor);\n  }\n\n  // Alpha falloff at edges\n  float finalAlpha = 1.0;\n  if (uEnableAlpha && alphaFactor > 0.0) {\n    finalAlpha = 1.0 - alphaFactor;\n  }\n\n  gl_FragColor = vec4(refracted, finalAlpha);\n}\n`;\n\nexport const revealageFragment = `\nprecision mediump float;\nvarying vec2 vUv;\nuniform sampler2D uNormalMap;\nuniform float uOpacity;\nvoid main(){\n  vec4 normalSample = texture2D(uNormalMap, vUv);\n  float mask = normalSample.a;\n\n  // Discard pixels outside the masked area (border radius)\n  if (mask < 0.01) {\n    discard;\n  }\n\n  float alpha = uOpacity * mask;\n  float revealage = exp(-3.0 * alpha);\n  gl_FragColor = vec4(revealage);\n}\n`;\n\nexport const compositeFragment = `\nprecision mediump float;\nvarying vec2 vUv;\nuniform sampler2D uSceneColor;\nuniform sampler2D uAccum;\nuniform sampler2D uReveal;\nvoid main(){\n  vec4 accum = texture2D(uAccum, vUv);\n  vec3 scene = texture2D(uSceneColor, vUv).rgb;\n\n  // Simple alpha blend: accum.a is opacity\n  vec3 result = mix(scene, accum.rgb, accum.a);\n  gl_FragColor = vec4(result, 1.0);\n}\n`;\n","import {\n  Container,\n  Mesh,\n  MeshGeometry,\n  RenderTexture,\n  Shader,\n  Sprite,\n  State,\n  Texture,\n  UniformGroup,\n} from 'pixi.js';\nimport type { Renderer } from 'pixi.js';\nimport { SceneRTManager } from '../core/SceneRTManager.js';\nimport type { GlassPanel } from '../panels/GlassPanel.js';\nimport {\n  compositeFragment,\n  fullscreenVertex,\n  jfaDistanceFragment,\n  jfaFloodFragment,\n  jfaSeedFragment,\n  panelVertex,\n  refractionFragment,\n  revealageFragment,\n} from '../shaders/webgl2.js';\nimport type { Pipeline, PipelineContext } from './BasePipeline.js';\nimport type { RenderQualityOptions } from '../core/types.js';\nimport { hexToVec3 } from '../utils/index.js';\n\n// Fullscreen quad with 0..1 positions for clip space mapping\nconst QUAD_GEOMETRY = new MeshGeometry({\n  positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n  uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n  indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n// Cache entry for JFA distance field per panel\ninterface JFACache {\n  distanceField: RenderTexture;\n  normalMapId: number; // Track which normal map was used\n  normalMapUpdateId: number; // Track texture updates\n  width: number;\n  height: number;\n}\n\nexport class WebGL2Pipeline implements Pipeline {\n  readonly id = 'webgl2';\n  private readonly rtManager: SceneRTManager;\n  private readonly refractShader: Shader;\n  private readonly revealageShader: Shader;\n  private readonly compositeShader: Shader;\n  private readonly fullScreenQuad: Mesh<MeshGeometry, Shader>;\n  private readonly shadowSprite: Sprite;\n  private readonly panelParent: Container;\n  private compositeRT?: RenderTexture;\n  private readonly compositeSprite: Sprite;\n  private accumRT?: RenderTexture;\n  private revealRT?: RenderTexture;\n\n  // JFA shaders and cache\n  private readonly jfaSeedShader: Shader;\n  private readonly jfaFloodShader: Shader;\n  private readonly jfaDistanceShader: Shader;\n  private jfaPingRT?: RenderTexture;\n  private jfaPongRT?: RenderTexture;\n  private readonly jfaCache: Map<GlassPanel, JFACache> = new Map();\n\n  constructor(\n    private readonly renderer: Renderer,\n    useDepth: boolean,\n  ) {\n    this.rtManager = new SceneRTManager(renderer, useDepth);\n    const refractUniforms = new UniformGroup({\n      uPosition: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n      uScale: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uResolution: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uInvResolution: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uIOR: { value: 1, type: 'f32' },\n      uThickness: { value: 1, type: 'f32' },\n      uDispersion: { value: 0, type: 'f32' },\n      uRoughness: { value: 0, type: 'f32' },\n      uOpacity: { value: 1, type: 'f32' },\n      uEnableDispersion: { value: 0, type: 'f32' },\n      uEnableCaustics: { value: 0, type: 'f32' },\n      uTint: { value: new Float32Array([1, 1, 1]), type: 'vec3<f32>' },\n      uSpecular: { value: 0, type: 'f32' },\n      uShininess: { value: 32, type: 'f32' },\n      uShadow: { value: 0, type: 'f32' },\n      uLightDir: { value: new Float32Array([0.5, 0.5, 1]), type: 'vec3<f32>' },\n      uBlurSamples: { value: 8, type: 'f32' },\n      uBlurSpread: { value: 4, type: 'f32' },\n      uBlurAngle: { value: 0, type: 'f32' },\n      uBlurAnisotropy: { value: 0, type: 'f32' },\n      uBlurGamma: { value: 1, type: 'f32' },\n      uAberrationR: { value: 1, type: 'f32' },\n      uAberrationB: { value: 1, type: 'f32' },\n      uAO: { value: 0, type: 'f32' },\n      uAORadius: { value: 0.5, type: 'f32' },\n      uNoiseScale: { value: 20, type: 'f32' },\n      uNoiseIntensity: { value: 0, type: 'f32' },\n      uNoiseRotation: { value: 0, type: 'f32' },\n      uNoiseThreshold: { value: 0, type: 'f32' },\n      uEdgeSupersampling: { value: 1, type: 'f32' },\n      uGlassSupersampling: { value: 1, type: 'f32' },\n      uEdgeIor: { value: new Float32Array([0, 0.15, 1, 1]), type: 'vec4<f32>' }, // rangeStart, rangeEnd, strength, enabled\n      uPanelSize: { value: new Float32Array([200, 200]), type: 'vec2<f32>' },\n      // Edge mask system\n      uEdgeMaskCutoff: { value: 0.001, type: 'f32' },\n      uEdgeMaskBlur: { value: 0, type: 'f32' },\n      uEdgeMaskInvert: { value: 0, type: 'f32' },\n      // Edge tactics: vec4(rangeStart, rangeEnd, strength, opacity)\n      uEdgeSmoothing: { value: new Float32Array([0, 0.3, 1, 1]), type: 'vec4<f32>' },\n      uEdgeContrast: { value: new Float32Array([0, 0.3, 0.7, 1]), type: 'vec4<f32>' },\n      uEdgeAlpha: { value: new Float32Array([0, 0.2, 1, 1]), type: 'vec4<f32>' },\n      uEdgeTint: { value: new Float32Array([0, 0.5, 0.5, 1]), type: 'vec4<f32>' },\n      uEdgeDarken: { value: new Float32Array([0, 0.3, 0.3, 1]), type: 'vec4<f32>' },\n      uEdgeDesaturate: { value: new Float32Array([0, 0.4, 0.5, 1]), type: 'vec4<f32>' },\n      // Tactic enables\n      uEnableSmoothing: { value: 0, type: 'f32' },\n      uEnableContrast: { value: 0, type: 'f32' },\n      uEnableAlpha: { value: 0, type: 'f32' },\n      uEnableTint: { value: 0, type: 'f32' },\n      uEnableDarken: { value: 0, type: 'f32' },\n      uEnableDesaturate: { value: 0, type: 'f32' },\n      uDebugMode: { value: 0, type: 'f32' },\n    });\n    this.refractShader = Shader.from({\n      gl: { vertex: panelVertex, fragment: refractionFragment },\n      resources: {\n        uSceneColor: Texture.WHITE.source,\n        uNormalMap: Texture.WHITE.source,\n        uCausticsMap: Texture.WHITE.source,\n        uDistanceField: Texture.WHITE.source,\n        panelUniforms: refractUniforms,\n      },\n    });\n    const revealUniforms = new UniformGroup({\n      uPosition: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n      uScale: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uResolution: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uOpacity: { value: 1, type: 'f32' },\n    });\n    this.revealageShader = Shader.from({\n      gl: { vertex: panelVertex, fragment: revealageFragment },\n      resources: {\n        uNormalMap: Texture.WHITE.source,\n        panelUniforms: revealUniforms,\n      },\n    });\n    this.compositeShader = Shader.from({\n      gl: { vertex: fullscreenVertex, fragment: compositeFragment },\n      resources: {\n        uSceneColor: Texture.WHITE.source,\n        uAccum: Texture.WHITE.source,\n        uReveal: Texture.WHITE.source,\n      },\n    });\n    this.fullScreenQuad = new Mesh({\n      geometry: QUAD_GEOMETRY,\n      shader: this.compositeShader,\n    });\n    this.fullScreenQuad.state = State.for2d();\n    this.fullScreenQuad.state.culling = false; // Disable culling\n    this.shadowSprite = new Sprite(Texture.WHITE);\n    this.panelParent = new Container();\n    this.panelParent.alpha = 1;\n    this.compositeSprite = new Sprite(Texture.EMPTY);\n    // Ensure composite sprite is visible and on top\n    this.compositeSprite.position.set(0, 0);\n    this.compositeSprite.visible = true;\n    this.compositeSprite.alpha = 1;\n    this.compositeSprite.zIndex = 9999; // Force on top\n\n    // JFA shaders\n    const jfaSeedUniforms = new UniformGroup({\n      uTexelSize: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n    });\n    this.jfaSeedShader = Shader.from({\n      gl: { vertex: fullscreenVertex, fragment: jfaSeedFragment },\n      resources: {\n        uNormalMap: Texture.WHITE.source,\n        jfaUniforms: jfaSeedUniforms,\n      },\n    });\n\n    const jfaFloodUniforms = new UniformGroup({\n      uTexelSize: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uStepSize: { value: 1, type: 'f32' },\n    });\n    this.jfaFloodShader = Shader.from({\n      gl: { vertex: fullscreenVertex, fragment: jfaFloodFragment },\n      resources: {\n        uPrevPass: Texture.WHITE.source,\n        jfaUniforms: jfaFloodUniforms,\n      },\n    });\n\n    const jfaDistanceUniforms = new UniformGroup({\n      uMaxDistance: { value: 0.15, type: 'f32' },\n    });\n    this.jfaDistanceShader = Shader.from({\n      gl: { vertex: fullscreenVertex, fragment: jfaDistanceFragment },\n      resources: {\n        uSeedMap: Texture.WHITE.source,\n        jfaUniforms: jfaDistanceUniforms,\n      },\n    });\n  }\n\n  setup(): void {}\n\n  render(context: PipelineContext): void {\n    const { renderer, panels, quality, drawOpaqueScene } = context;\n    const width = renderer.screen.width;\n    const height = renderer.screen.height;\n    const targets = this.rtManager.ensure(width, height, quality.renderScale);\n    this.ensureAccumTargets(width, height);\n    this.ensureCompositeTarget(width, height);\n\n    drawOpaqueScene(targets.sceneColor);\n\n    this.clearTarget(this.accumRT, 0, 0, 0, 0);\n    this.clearTarget(this.revealRT, 1, 1, 1, 1);\n\n    for (const panel of panels) {\n      this.renderPanel(panel, quality, targets.sceneColor);\n    }\n\n    this.fullScreenQuad.shader = this.compositeShader;\n    (this.compositeShader as any).resources.uSceneColor = targets.sceneColor.source;\n    (this.compositeShader as any).resources.uAccum = this.accumRT?.source;\n    (this.compositeShader as any).resources.uReveal = this.revealRT?.source;\n\n    this.fullScreenQuad.width = renderer.screen.width;\n    this.fullScreenQuad.height = renderer.screen.height;\n\n    this.fullScreenQuad.updateLocalTransform();\n    this.fullScreenQuad.worldTransform.copyFrom(this.fullScreenQuad.localTransform);\n\n    // Render composite quad to texture\n    renderer.render({ container: this.fullScreenQuad, target: this.compositeRT, clear: true });\n\n    if (this.compositeRT) {\n      this.compositeSprite.texture = this.compositeRT;\n      this.compositeSprite.width = width;\n      this.compositeSprite.height = height;\n      this.compositeSprite.visible = true;\n    }\n\n    this.renderContactShadows(panels, quality);\n  }\n\n  dispose(): void {\n    this.rtManager.dispose();\n    this.accumRT?.destroy(true);\n    this.revealRT?.destroy(true);\n    this.compositeRT?.destroy(true);\n    this.jfaPingRT?.destroy(true);\n    this.jfaPongRT?.destroy(true);\n    for (const cache of this.jfaCache.values()) {\n      cache.distanceField.destroy(true);\n    }\n    this.jfaCache.clear();\n  }\n\n  // Compute JFA distance field for a panel's normal map\n  private computeDistanceField(panel: GlassPanel): RenderTexture {\n    const normalMap = panel.normalMap ?? Texture.WHITE;\n    const width = normalMap.width;\n    const height = normalMap.height;\n    const normalMapId = (normalMap.source as any).uid ?? 0;\n    const normalMapUpdateId = (normalMap.source as any)._updateID ?? (normalMap.source as any).updateId ?? 0;\n\n    // Check cache\n    const cached = this.jfaCache.get(panel);\n    if (cached && cached.normalMapId === normalMapId && cached.normalMapUpdateId === normalMapUpdateId && cached.width === width && cached.height === height) {\n      return cached.distanceField;\n    }\n\n    // Ensure ping-pong textures\n    if (!this.jfaPingRT || this.jfaPingRT.width !== width || this.jfaPingRT.height !== height) {\n      this.jfaPingRT?.destroy(true);\n      this.jfaPongRT?.destroy(true);\n      this.jfaPingRT = RenderTexture.create({ width, height, resolution: 1 });\n      this.jfaPongRT = RenderTexture.create({ width, height, resolution: 1 });\n    }\n\n    // Create or reuse distance field texture\n    let distanceField = cached?.distanceField;\n    if (!distanceField || distanceField.width !== width || distanceField.height !== height) {\n      distanceField?.destroy(true);\n      distanceField = RenderTexture.create({ width, height, resolution: 1 });\n    }\n\n    const texelSize = [1 / width, 1 / height];\n\n    // Step 1: Seed pass\n    const seedResources = (this.jfaSeedShader as any).resources;\n    seedResources.uNormalMap = normalMap.source;\n    const seedUniforms = seedResources.jfaUniforms?.uniforms;\n    if (seedUniforms) {\n      seedUniforms.uTexelSize[0] = texelSize[0];\n      seedUniforms.uTexelSize[1] = texelSize[1];\n    }\n\n    this.fullScreenQuad.shader = this.jfaSeedShader;\n    this.fullScreenQuad.width = 1;\n    this.fullScreenQuad.height = 1;\n    this.fullScreenQuad.updateLocalTransform();\n    this.fullScreenQuad.worldTransform.copyFrom(this.fullScreenQuad.localTransform);\n    this.renderer.render({ container: this.fullScreenQuad, target: this.jfaPingRT, clear: true });\n\n    // Step 2: Flood passes (log2 iterations)\n    const maxDim = Math.max(width, height);\n    const passes = Math.ceil(Math.log2(maxDim));\n    let readRT: RenderTexture = this.jfaPingRT!;\n    let writeRT: RenderTexture = this.jfaPongRT!;\n\n    const floodResources = (this.jfaFloodShader as any).resources;\n    const floodUniforms = floodResources.jfaUniforms?.uniforms;\n\n    for (let i = 0; i < passes; i++) {\n      const stepSize = Math.pow(2, passes - i - 1);\n\n      floodResources.uPrevPass = readRT.source;\n      if (floodUniforms) {\n        floodUniforms.uTexelSize[0] = texelSize[0];\n        floodUniforms.uTexelSize[1] = texelSize[1];\n        floodUniforms.uStepSize = stepSize;\n      }\n\n      this.fullScreenQuad.shader = this.jfaFloodShader;\n      this.renderer.render({ container: this.fullScreenQuad, target: writeRT, clear: true });\n\n      // Swap\n      const temp = readRT;\n      readRT = writeRT;\n      writeRT = temp;\n    }\n\n    // Step 3: Distance pass\n    const distResources = (this.jfaDistanceShader as any).resources;\n    distResources.uSeedMap = readRT.source;\n    const distUniforms = distResources.jfaUniforms?.uniforms;\n    if (distUniforms) {\n      distUniforms.uMaxDistance = 0.05; // Smaller = more detail in edge gradient\n    }\n\n    this.fullScreenQuad.shader = this.jfaDistanceShader;\n    this.renderer.render({ container: this.fullScreenQuad, target: distanceField, clear: true });\n\n\n    // Cache result\n    this.jfaCache.set(panel, {\n      distanceField,\n      normalMapId,\n      normalMapUpdateId,\n      width,\n      height,\n    });\n\n    return distanceField;\n  }\n\n  private ensureAccumTargets(width: number, height: number): void {\n    const targetResolution = this.renderer.resolution;\n    if (!this.accumRT || this.accumRT.width !== width || this.accumRT.height !== height || this.accumRT.source.resolution !== targetResolution) {\n      this.accumRT?.destroy(true);\n      this.accumRT = RenderTexture.create({\n        width,\n        height,\n        resolution: targetResolution,\n      });\n    }\n    if (!this.revealRT || this.revealRT.width !== width || this.revealRT.height !== height || this.revealRT.source.resolution !== targetResolution) {\n      this.revealRT?.destroy(true);\n      this.revealRT = RenderTexture.create({\n        width,\n        height,\n        resolution: targetResolution,\n      });\n    }\n  }\n\n  private clearTarget(\n    target: RenderTexture | undefined,\n    r: number,\n    g: number,\n    b: number,\n    a: number,\n  ): void {\n    if (!target) return;\n    const dummy = new Container();\n    this.renderer.render({ container: dummy, target, clear: true, clearColor: [r, g, b, a] });\n  }\n\n  private renderPanel(\n    panel: GlassPanel,\n    quality: RenderQualityOptions,\n    sceneTarget: RenderTexture,\n  ): void {\n    if (!this.accumRT || !this.revealRT) return;\n    const normal = panel.normalMap ?? Texture.WHITE;\n    const screenWidth = this.renderer.screen.width;\n    const screenHeight = this.renderer.screen.height;\n\n    // Compute JFA distance field for this panel\n    const distanceField = this.computeDistanceField(panel);\n\n    const resources = (this.refractShader as any).resources;\n    if (resources) {\n      resources.uSceneColor = sceneTarget.source;\n      resources.uNormalMap = normal.source;\n      resources.uCausticsMap = (panel.causticsAtlas ?? Texture.WHITE).source;\n      resources.uDistanceField = distanceField.source;\n\n      // Update uniforms through UniformGroup in v8\n      const uniforms = resources.panelUniforms?.uniforms;\n      if (uniforms) {\n        // Use accumRT resolution since gl_FragCoord is in accumRT pixel space\n        const res = this.accumRT?.source?._resolution ?? this.renderer.resolution;\n        uniforms.uPosition[0] = panel.position.x;\n        uniforms.uPosition[1] = panel.position.y;\n        uniforms.uScale[0] = panel.scale.x;\n        uniforms.uScale[1] = panel.scale.y;\n        uniforms.uResolution[0] = screenWidth;\n        uniforms.uResolution[1] = screenHeight;\n        uniforms.uInvResolution[0] = 1 / (screenWidth * res);\n        uniforms.uInvResolution[1] = 1 / (screenHeight * res);\n        uniforms.uIOR = panel.glassMaterial.ior;\n        uniforms.uThickness = panel.glassMaterial.thickness;\n        uniforms.uDispersion = panel.glassMaterial.dispersion;\n        uniforms.uRoughness = panel.glassMaterial.roughness;\n        uniforms.uOpacity = panel.glassMaterial.opacity ?? 1;\n        uniforms.uEnableDispersion =\n          quality.enableDispersion && panel.glassMaterial.dispersion > 0.001 ? 1 : 0;\n        uniforms.uEnableCaustics = quality.enableCaustics && Boolean(panel.causticsAtlas) ? 1 : 0;\n        const tint = hexToVec3(panel.glassMaterial.tint ?? 0xffffff);\n        uniforms.uTint[0] = tint[0];\n        uniforms.uTint[1] = tint[1];\n        uniforms.uTint[2] = tint[2];\n        uniforms.uSpecular = panel.glassMaterial.specular ?? 0;\n        uniforms.uShininess = panel.glassMaterial.shininess ?? 32;\n        uniforms.uShadow = panel.glassMaterial.shadow ?? 0;\n        const lightDir = panel.glassMaterial.lightDir ?? [0.5, 0.5, 1];\n        uniforms.uLightDir[0] = -lightDir[0];\n        uniforms.uLightDir[1] = -lightDir[1];\n        uniforms.uLightDir[2] = lightDir[2];\n        uniforms.uBlurSamples = panel.glassMaterial.blurSamples ?? 8;\n        uniforms.uBlurSpread = panel.glassMaterial.blurSpread ?? 4;\n        uniforms.uBlurAngle = (panel.glassMaterial.blurAngle ?? 0) * Math.PI / 180;\n        uniforms.uBlurAnisotropy = panel.glassMaterial.blurAnisotropy ?? 0;\n        uniforms.uBlurGamma = panel.glassMaterial.blurGamma ?? 1;\n        uniforms.uAberrationR = panel.glassMaterial.aberrationR ?? 1;\n        uniforms.uAberrationB = panel.glassMaterial.aberrationB ?? 1;\n        uniforms.uAO = panel.glassMaterial.ao ?? 0;\n        uniforms.uAORadius = panel.glassMaterial.aoRadius ?? 0.5;\n        uniforms.uNoiseScale = panel.glassMaterial.noiseScale ?? 20;\n        uniforms.uNoiseIntensity = panel.glassMaterial.noiseIntensity ?? 0;\n        uniforms.uNoiseRotation = panel.glassMaterial.noiseRotation ?? 0;\n        uniforms.uNoiseThreshold = panel.glassMaterial.noiseThreshold ?? 0;\n        uniforms.uEdgeSupersampling = quality.edgeSupersampling ?? 1;\n        uniforms.uGlassSupersampling = panel.glassMaterial.glassSupersampling ?? 1;\n        uniforms.uEdgeIor[0] = panel.glassMaterial.edgeIorRangeStart ?? 0;\n        uniforms.uEdgeIor[1] = panel.glassMaterial.edgeIorRangeEnd ?? 0.15;\n        uniforms.uEdgeIor[2] = panel.glassMaterial.edgeIorStrength ?? 1;\n        uniforms.uEdgeIor[3] = panel.glassMaterial.edgeIorEnabled ? 1 : 0;\n        uniforms.uPanelSize[0] = panel.scale.x;\n        uniforms.uPanelSize[1] = panel.scale.y;\n\n        // Edge mask system\n        const edgeMask = panel.glassMaterial.edgeMask;\n        if (edgeMask) {\n          uniforms.uEdgeMaskCutoff = edgeMask.cutoff;\n          uniforms.uEdgeMaskBlur = edgeMask.blur;\n          uniforms.uEdgeMaskInvert = edgeMask.invert ? 1 : 0;\n\n          // Set tactic uniforms\n          const setTactic = (uniform: Float32Array, tactic: any) => {\n            uniform[0] = tactic.rangeStart;\n            uniform[1] = tactic.rangeEnd;\n            uniform[2] = tactic.strength;\n            uniform[3] = tactic.opacity;\n          };\n\n          setTactic(uniforms.uEdgeSmoothing, edgeMask.smoothing);\n          setTactic(uniforms.uEdgeContrast, edgeMask.contrast);\n          setTactic(uniforms.uEdgeAlpha, edgeMask.alpha);\n          setTactic(uniforms.uEdgeTint, edgeMask.tint);\n          setTactic(uniforms.uEdgeDarken, edgeMask.darken);\n          setTactic(uniforms.uEdgeDesaturate, edgeMask.desaturate);\n\n          uniforms.uEnableSmoothing = edgeMask.smoothing.enabled ? 1 : 0;\n          uniforms.uEnableContrast = edgeMask.contrast.enabled ? 1 : 0;\n          uniforms.uEnableAlpha = edgeMask.alpha.enabled ? 1 : 0;\n          uniforms.uEnableTint = edgeMask.tint.enabled ? 1 : 0;\n          uniforms.uEnableDarken = edgeMask.darken.enabled ? 1 : 0;\n          uniforms.uEnableDesaturate = edgeMask.desaturate.enabled ? 1 : 0;\n          uniforms.uDebugMode = (edgeMask as any).debugMode ?? 0;\n        } else {\n          // Legacy fallback\n          uniforms.uEdgeMaskCutoff = panel.glassMaterial.edgeMaskCutoff ?? 0.001;\n          uniforms.uEdgeMaskBlur = panel.glassMaterial.edgeBlur ?? 0;\n          uniforms.uEdgeMaskInvert = 0;\n          uniforms.uEnableSmoothing = 0;\n          uniforms.uEnableContrast = 0;\n          uniforms.uEnableAlpha = 0;\n          uniforms.uEnableTint = 0;\n          uniforms.uEnableDarken = 0;\n          uniforms.uEnableDesaturate = 0;\n        }\n      }\n    }\n\n    const prevShader = panel.shader;\n    panel.shader = this.refractShader as any;\n    this.drawPanelToTarget(panel, this.accumRT);\n\n    panel.shader = this.revealageShader as any;\n\n    const revealResources = (this.revealageShader as any).resources;\n    if (revealResources) {\n      revealResources.uNormalMap = normal.source;\n\n      const revealUniforms = revealResources.panelUniforms?.uniforms;\n      if (revealUniforms) {\n        revealUniforms.uPosition[0] = panel.position.x;\n        revealUniforms.uPosition[1] = panel.position.y;\n        revealUniforms.uScale[0] = panel.scale.x;\n        revealUniforms.uScale[1] = panel.scale.y;\n        revealUniforms.uResolution[0] = screenWidth;\n        revealUniforms.uResolution[1] = screenHeight;\n        revealUniforms.uOpacity = panel.glassMaterial.opacity;\n      }\n    }\n\n    this.drawPanelToTarget(panel, this.revealRT);\n    panel.shader = prevShader;\n  }\n\n  private renderContactShadows(panels: GlassPanel[], quality: RenderQualityOptions): void {\n    if (!quality.enableContactShadows) return;\n    for (const panel of panels) {\n      if (!panel.sdfShadow) continue;\n      this.shadowSprite.texture = panel.sdfShadow;\n      this.shadowSprite.position.copyFrom(panel.position);\n      this.shadowSprite.scale.copyFrom(panel.scale);\n      this.shadowSprite.rotation = panel.rotation;\n      this.shadowSprite.alpha = Math.min(panel.glassMaterial.opacity + 0.2, 0.9);\n      // this.shadowSprite.state.blendMode = BLEND_MODES.MULTIPLY;\n      this.renderer.render(this.shadowSprite);\n    }\n  }\n\n  getCompositeDisplay(): Container | undefined {\n    return this.compositeSprite;\n  }\n\n  private drawPanelToTarget(panel: GlassPanel, target: RenderTexture): void {\n    const renderer = this.renderer;\n    const gl = (renderer as any).gl as WebGL2RenderingContext;\n\n    // Clear parent and add only this panel\n    this.panelParent.removeChildren();\n    this.panelParent.addChild(panel);\n\n    // Update transforms for detached container in v8\n    panel.updateLocalTransform();\n    panel.worldTransform.copyFrom(panel.localTransform);\n\n    // Use standard alpha blending\n    if (gl) {\n      gl.enable(gl.BLEND);\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n    }\n\n    renderer.render({ container: this.panelParent, target, clear: false });\n\n    // Reset blend state\n    if (gl) {\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    }\n  }\n\n  private ensureCompositeTarget(width: number, height: number): void {\n    const targetResolution = this.renderer.resolution;\n    if (\n      !this.compositeRT ||\n      this.compositeRT.width !== width ||\n      this.compositeRT.height !== height ||\n      this.compositeRT.source.resolution !== targetResolution\n    ) {\n      this.compositeRT?.destroy(true);\n      this.compositeRT = RenderTexture.create({\n        width,\n        height,\n        resolution: targetResolution,\n      });\n      this.compositeSprite.texture = this.compositeRT;\n    }\n  }\n}\n","import type { Container, RenderTexture, Renderer, WebGLRenderer } from 'pixi.js';\nimport { AdaptiveQualityController } from '../core/AdaptiveQualityController.js';\nimport { CapabilityProbe } from '../core/CapabilityProbe.js';\nimport { EventBus } from '../core/EventBus.js';\nimport type {\n  AdaptiveDecision,\n  FallbackEvent,\n  GlassPanelProps,\n  GlassSystemOptions,\n  RenderQualityOptions,\n} from '../core/types.js';\nimport type { GlassPanel } from '../panels/GlassPanel.js';\nimport { GlassPanel as GlassPanelImpl } from '../panels/GlassPanel.js';\nimport type { Pipeline } from '../pipelines/BasePipeline.js';\nimport { WebGL1Pipeline } from '../pipelines/WebGL1Pipeline.js';\nimport { WebGL2Pipeline } from '../pipelines/WebGL2Pipeline.js';\n\ninterface GlassSystemEvents {\n  'quality:decision': AdaptiveDecision;\n  fallback: FallbackEvent;\n  [key: string]: any; // Add index signature to satisfy EventMap\n}\n\nexport class GlassSystem {\n  private pipeline: Pipeline;\n  private readonly panels: GlassPanel[] = [];\n  private readonly quality = new AdaptiveQualityController();\n  private drawOpaqueScene: (target: RenderTexture) => void = () => {};\n  private readonly events = new EventBus<GlassSystemEvents>();\n\n  constructor(\n    private readonly renderer: Renderer,\n    _options: GlassSystemOptions = {},\n  ) {\n    const gl = (renderer as WebGLRenderer).gl;\n    const capability = new CapabilityProbe(gl).run();\n    this.pipeline =\n      capability.tier === 'webgl2'\n        ? new WebGL2Pipeline(renderer, true)\n        : new WebGL1Pipeline(renderer);\n    if (capability.tier === 'webgl1') {\n      this.emitFallback('webgl', 'MRT unavailable, using compatibility pipeline');\n    }\n  }\n\n  setOpaqueSceneCallback(draw: (target: RenderTexture) => void): void {\n    this.drawOpaqueScene = draw;\n  }\n\n  createPanel(props: GlassPanelProps): GlassPanel {\n    const panel = new GlassPanelImpl(props);\n    this.panels.push(panel);\n    return panel;\n  }\n\n  removePanel(panel: GlassPanel): void {\n    const idx = this.panels.indexOf(panel);\n    if (idx >= 0) {\n      this.panels.splice(idx, 1);\n      panel.destroy({ children: true, texture: false, textureSource: false });\n    }\n  }\n\n  render(): void {\n    const start = performance.now();\n    const quality = this.quality.getQuality();\n    this.pipeline.render({\n      renderer: this.renderer,\n      panels: this.panels,\n      quality,\n      drawOpaqueScene: this.drawOpaqueScene,\n    });\n    const duration = performance.now() - start;\n    this.quality.record({ cpuMs: duration, timestamp: start });\n    const decision = this.quality.evaluate();\n    if (decision) {\n      this.events.emit('quality:decision', decision);\n    }\n  }\n\n  setQuality(options: Partial<RenderQualityOptions>): void {\n    this.quality.setOverrides(options);\n  }\n\n  destroy(): void {\n    for (const panel of this.panels) {\n      panel.destroy({ children: true, texture: false, textureSource: false });\n    }\n    this.panels.length = 0;\n    this.pipeline.dispose();\n    this.events.removeAll();\n  }\n\n  on<K extends keyof GlassSystemEvents>(\n    event: K,\n    listener: (payload: GlassSystemEvents[K]) => void,\n  ): void {\n    this.events.on(event, listener);\n  }\n\n  off<K extends keyof GlassSystemEvents>(\n    event: K,\n    listener: (payload: GlassSystemEvents[K]) => void,\n  ): void {\n    this.events.off(event, listener);\n  }\n\n  getPipelineId(): string {\n    return this.pipeline.id;\n  }\n\n  getCompositeDisplay(): Container | undefined {\n    if (typeof this.pipeline.getCompositeDisplay === 'function') {\n      return this.pipeline.getCompositeDisplay();\n    }\n    return undefined;\n  }\n\n  private emitFallback(target: string, message: string): void {\n    const event: FallbackEvent = { target, message, timestamp: performance.now() };\n    console.warn(`GlassSystem fallback: ${target} - ${message}`);\n    this.events.emit('fallback', event);\n  }\n}\n","import { Container, Graphics, Text } from 'pixi.js';\nimport type { Renderer } from 'pixi.js';\nimport type { AdaptiveDecision, RenderQualityOptions, TelemetrySample } from '../core/types.js';\n\ninterface HudMetrics {\n  quality: RenderQualityOptions;\n  fps: number;\n  lastDecision?: AdaptiveDecision;\n  telemetry: TelemetrySample[];\n}\n\nexport class GlassHUD {\n  readonly container = new Container();\n  private readonly panel: Graphics;\n  private readonly text: Text;\n  private visible = false;\n\n  constructor(private readonly renderer: Renderer) {\n    this.panel = new Graphics()\n      .beginFill(0x000000, 0.65)\n      .drawRoundedRect(0, 0, 260, 120, 8)\n      .endFill();\n    this.text = new Text('Glass HUD', { fontSize: 12, fill: 0xffffff });\n    this.text.position.set(12, 10);\n    this.container.addChild(this.panel, this.text);\n    this.container.visible = this.visible;\n    this.container.position.set(12, 12);\n  }\n\n  setVisible(visible: boolean): void {\n    this.visible = visible;\n    this.container.visible = visible;\n  }\n\n  update(metrics: HudMetrics): void {\n    if (!this.visible) return;\n    const { quality, fps, lastDecision } = metrics;\n    const lines = [\n      `FPS: ${fps.toFixed(1)}`,\n      `Scale: ${(quality.renderScale * 100).toFixed(0)}%`,\n      `Blur taps: ${quality.maxBlurTaps}`,\n      `Dispersion: ${quality.enableDispersion ? 'on' : 'off'}`,\n      `Caustics: ${quality.enableCaustics ? 'on' : 'off'}`,\n    ];\n    if (lastDecision) {\n      lines.push(`Action: ${lastDecision.action}`);\n    }\n    this.text.text = lines.join('\\n');\n  }\n}\n","import type { Renderer } from 'pixi.js';\nimport type { LightFollowParams, TrackedItem } from './types.js';\n\nexport class LightFollowController {\n  private params?: LightFollowParams;\n  private currentDir: [number, number, number] = [0, 0, 0.15];\n  private targetDir: [number, number, number] = [0, 0, 0.15];\n  private delayedDir: [number, number, number] = [0, 0, 0.15];\n  private boundMouseMove?: (e: MouseEvent) => void;\n  private renderer: Renderer;\n\n  constructor(renderer: Renderer) {\n    this.renderer = renderer;\n  }\n\n  setParams(params: LightFollowParams): void {\n    this.params = params;\n\n    if (params.followCursor && !this.boundMouseMove) {\n      this.boundMouseMove = (e: MouseEvent) => {\n        const curve = params.curve ?? 1.5;\n        const zMin = params.zMin ?? 0.05;\n        const zMax = params.zMax ?? 0.20;\n        const edgeStretch = params.edgeStretch ?? 0.5;\n\n        // Get canvas bounds for proper coordinate mapping\n        const canvas = this.renderer.canvas as HTMLCanvasElement;\n        const rect = canvas.getBoundingClientRect();\n\n        // Convert cursor position to -1 to 1 range relative to canvas\n        let x = 1 - ((e.clientX - rect.left) / rect.width) * 2; // X: left=1, right=-1\n        let y = 1 - ((e.clientY - rect.top) / rect.height) * 2; // Y: top=1, bottom=-1\n\n        // Apply edge stretch - power curve controls how values spread\n        // < 1 = stretch toward edges, > 1 = compress toward center\n        x = Math.sign(x) * Math.pow(Math.abs(x), edgeStretch);\n        y = Math.sign(y) * Math.pow(Math.abs(y), edgeStretch);\n\n        // Z decreases toward edges based on curve, capped at zMax (0.20)\n        const dist = Math.sqrt(x * x + y * y);\n        const z = Math.max(zMin, Math.min(zMax, zMax - Math.pow(dist, curve) * zMax * 0.5));\n\n        this.targetDir = [x, y, z];\n      };\n      window.addEventListener('mousemove', this.boundMouseMove);\n    } else if (!params.followCursor && this.boundMouseMove) {\n      window.removeEventListener('mousemove', this.boundMouseMove);\n      this.boundMouseMove = undefined;\n    }\n  }\n\n  update(tracked: Map<HTMLElement, TrackedItem>): void {\n    if (!this.params?.followCursor) return;\n\n    // Delay: lerp delayed toward target (0 = instant, 1 = very slow)\n    const delay = this.params.delay ?? 0.5;\n    const delayFactor = 1 - delay * 0.97; // Convert to lerp factor (0.03 to 1)\n    this.delayedDir[0] += (this.targetDir[0] - this.delayedDir[0]) * delayFactor;\n    this.delayedDir[1] += (this.targetDir[1] - this.delayedDir[1]) * delayFactor;\n    this.delayedDir[2] += (this.targetDir[2] - this.delayedDir[2]) * delayFactor;\n\n    // Smoothing: lerp current toward delayed (0 = instant, 1 = very slow)\n    const smoothing = this.params.smoothing ?? 0.9;\n    const smoothFactor = 1 - smoothing * 0.97; // Convert to lerp factor (0.03 to 1)\n    this.currentDir[0] += (this.delayedDir[0] - this.currentDir[0]) * smoothFactor;\n    this.currentDir[1] += (this.delayedDir[1] - this.currentDir[1]) * smoothFactor;\n    this.currentDir[2] += (this.delayedDir[2] - this.currentDir[2]) * smoothFactor;\n\n    // Apply to all panels\n    for (const [, item] of tracked) {\n      item.panel.glassMaterial.lightDir = [...this.currentDir];\n    }\n  }\n\n  destroy(): void {\n    if (this.boundMouseMove) {\n      window.removeEventListener('mousemove', this.boundMouseMove);\n      this.boundMouseMove = undefined;\n    }\n  }\n}\n","import type { GlassPanel } from '../panels/GlassPanel.js';\nimport type { TrackedItem } from './types.js';\n\nexport type SyncElementFn = (element: HTMLElement, panel: GlassPanel) => void;\nexport type UpdateGeometryFn = (element: HTMLElement, item: TrackedItem) => void;\nexport type IsCssVisibleFn = (element: HTMLElement) => boolean;\nexport type ParseBorderRadiusFn = (element: HTMLElement, rect: DOMRect) => number;\n\nexport interface DomTrackingCallbacks {\n  syncElement: SyncElementFn;\n  updateGeometry: UpdateGeometryFn;\n  isCssVisible: IsCssVisibleFn;\n  parseBorderRadius: ParseBorderRadiusFn;\n}\n\nexport class DomTrackingController {\n  private resizeObserver?: ResizeObserver;\n  private intersectionObserver?: IntersectionObserver;\n  private observer?: MutationObserver;\n  private tracked: Map<HTMLElement, TrackedItem>;\n  private callbacks: DomTrackingCallbacks;\n\n  constructor(tracked: Map<HTMLElement, TrackedItem>, callbacks: DomTrackingCallbacks) {\n    this.tracked = tracked;\n    this.callbacks = callbacks;\n  }\n\n  setupObservers(selector: string, trackFn: (el: HTMLElement) => void, untrackFn: (el: HTMLElement) => void, cleanupFn: () => void): void {\n    // Set up ResizeObserver for size changes\n    this.resizeObserver = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const element = entry.target as HTMLElement;\n        const item = this.tracked.get(element);\n        if (!item) continue;\n\n        const rect = element.getBoundingClientRect();\n        const lastRect = item.lastRect;\n\n        // Check if size changed significantly (more than 1px)\n        if (lastRect && (\n          Math.abs(rect.width - lastRect.width) > 1 ||\n          Math.abs(rect.height - lastRect.height) > 1\n        )) {\n          this.callbacks.updateGeometry(element, item);\n        }\n        item.lastRect = rect;\n      }\n    });\n\n    // Set up IntersectionObserver for visibility\n    this.intersectionObserver = new IntersectionObserver((entries) => {\n      for (const entry of entries) {\n        const element = entry.target as HTMLElement;\n        const item = this.tracked.get(element);\n        if (!item) continue;\n\n        item.visible = entry.isIntersecting;\n        const cssVisible = this.callbacks.isCssVisible(element);\n        item.panel.visible = item.visible && cssVisible;\n      }\n    });\n\n    // Mount existing elements\n    const existing = document.querySelectorAll<HTMLElement>(selector);\n    existing.forEach((el) => trackFn(el));\n\n    // Set up MutationObserver\n    this.observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.type === 'childList') {\n          mutation.addedNodes.forEach((node) => {\n            if (node instanceof HTMLElement && node.matches(selector)) {\n              trackFn(node);\n            }\n            if (node instanceof HTMLElement) {\n              const children = node.querySelectorAll<HTMLElement>(selector);\n              children.forEach((child) => trackFn(child));\n            }\n          });\n          mutation.removedNodes.forEach((node) => {\n            if (node instanceof HTMLElement && this.tracked.has(node)) {\n              untrackFn(node);\n            }\n          });\n        } else if (mutation.type === 'attributes') {\n          const target = mutation.target as HTMLElement;\n          if (mutation.attributeName === 'class') {\n            if (target.matches(selector)) {\n              trackFn(target);\n            } else {\n              untrackFn(target);\n            }\n          } else if (mutation.attributeName === 'style') {\n            const item = this.tracked.get(target);\n            if (item) {\n              // Check for visibility changes\n              const cssVisible = this.callbacks.isCssVisible(target);\n              item.panel.visible = cssVisible && item.visible;\n\n              // Check for border-radius changes\n              const rect = target.getBoundingClientRect();\n              const newRadius = this.callbacks.parseBorderRadius(target, rect);\n              if (Math.abs(newRadius - item.lastRadius) > 0.5) {\n                this.callbacks.updateGeometry(target, item);\n              }\n            }\n          } else if (mutation.attributeName === 'hidden') {\n            const item = this.tracked.get(target);\n            if (item) {\n              const cssVisible = this.callbacks.isCssVisible(target);\n              item.panel.visible = cssVisible && item.visible;\n            }\n          }\n        }\n      }\n      cleanupFn();\n    });\n\n    this.observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: ['class', 'style', 'hidden'],\n    });\n  }\n\n  observeElement(element: HTMLElement): void {\n    this.resizeObserver?.observe(element);\n    this.intersectionObserver?.observe(element);\n  }\n\n  unobserveElement(element: HTMLElement): void {\n    this.resizeObserver?.unobserve(element);\n    this.intersectionObserver?.unobserve(element);\n  }\n\n  destroy(): void {\n    this.observer?.disconnect();\n    this.resizeObserver?.disconnect();\n    this.intersectionObserver?.disconnect();\n  }\n}\n\n// Animation polling helpers\nexport function createAnimationHandlers(\n  tracked: Map<HTMLElement, TrackedItem>,\n  syncElement: SyncElementFn,\n  updateGeometry: UpdateGeometryFn\n) {\n  const startPolling = (element: HTMLElement): void => {\n    const item = tracked.get(element);\n    if (!item || item.polling) return;\n\n    item.polling = true;\n    const poll = () => {\n      if (!item.polling) return;\n      syncElement(element, item.panel);\n      requestAnimationFrame(poll);\n    };\n    requestAnimationFrame(poll);\n  };\n\n  const stopPolling = (element: HTMLElement): void => {\n    const item = tracked.get(element);\n    if (!item) return;\n\n    item.polling = false;\n    updateGeometry(element, item);\n  };\n\n  const handleAnimationStart = (e: Event) => {\n    const element = e.currentTarget as HTMLElement;\n    startPolling(element);\n  };\n\n  const handleAnimationEnd = (e: Event) => {\n    const element = e.currentTarget as HTMLElement;\n    // Check if any animations are still running\n    const animations = element.getAnimations();\n    if (animations.length === 0) {\n      stopPolling(element);\n    }\n  };\n\n  return { handleAnimationStart, handleAnimationEnd };\n}\n","// Calculate signed distance to rounded rect boundary (positive = inside)\nexport function getDistanceToBoundary(\n  px: number, py: number,\n  w: number, h: number,\n  radius: number\n): number {\n  const cx = w / 2;\n  const cy = h / 2;\n  const relX = Math.abs(px + 0.5 - cx);\n  const relY = Math.abs(py + 0.5 - cy);\n\n  const innerW = cx - radius;\n  const innerH = cy - radius;\n\n  if (relX <= innerW && relY <= innerH) {\n    return Math.min(innerW + radius - relX, innerH + radius - relY);\n  } else if (relX > innerW && relY <= innerH) {\n    return radius - (relX - innerW);\n  } else if (relY > innerH && relX <= innerW) {\n    return radius - (relY - innerH);\n  } else {\n    const dx = relX - innerW;\n    const dy = relY - innerH;\n    return radius - Math.sqrt(dx * dx + dy * dy);\n  }\n}\n","import { Texture } from 'pixi.js';\nimport type { SurfaceShape } from '../core/types.js';\nimport { getDistanceToBoundary } from './distance.js';\nimport { distanceToT, getHeightAndDerivative } from './height-functions.js';\n\nexport function createRoundedRectNormalMap(\n  width: number,\n  height: number,\n  radius: number,\n  bevel: number,\n  shape: SurfaceShape,\n  invertNormals: boolean = false,\n): Texture {\n  const w = Math.ceil(width);\n  const h = Math.ceil(height);\n  const data = new Uint8Array(w * h * 4);\n\n  // Subpixel offsets for 4x MSAA pattern\n  const subpixelOffsets = [\n    [-0.25, -0.25],\n    [0.25, -0.25],\n    [-0.25, 0.25],\n    [0.25, 0.25],\n  ];\n\n  for (let y = 0; y < h; y++) {\n    for (let x = 0; x < w; x++) {\n      let nx = 0;\n      let ny = 0;\n      let nz = 1;\n\n      // Subpixel sampling for alpha\n      let alphaSum = 0;\n      for (const [ox, oy] of subpixelOffsets) {\n        const dist = getDistanceToBoundary(x + ox, y + oy, w, h, radius);\n        alphaSum += dist >= 0 ? 1 : 0;\n      }\n      const alpha = (alphaSum / subpixelOffsets.length) * 255;\n\n      // Use pixel center for normal calculation\n      const cx = w / 2;\n      const cy = h / 2;\n      const relX = Math.abs(x + 0.5 - cx);\n      const relY = Math.abs(y + 0.5 - cy);\n\n      const innerW = cx - radius;\n      const innerH = cy - radius;\n\n      // Calculate distance to boundary and direction\n      let distToBoundary = 0;\n      let dirX = 0;\n      let dirY = 0;\n      let closestX = relX;\n      let closestY = relY;\n\n      if (relX <= innerW && relY <= innerH) {\n        const toEdgeX = innerW + radius;\n        const toEdgeY = innerH + radius;\n        if (toEdgeX - relX < toEdgeY - relY) {\n          closestX = innerW + radius;\n          closestY = relY;\n        } else {\n          closestX = relX;\n          closestY = innerH + radius;\n        }\n        distToBoundary = Math.min(toEdgeX - relX, toEdgeY - relY);\n      } else if (relX > innerW && relY <= innerH) {\n        closestX = innerW + radius;\n        closestY = relY;\n        distToBoundary = radius - (relX - innerW);\n      } else if (relY > innerH && relX <= innerW) {\n        closestX = relX;\n        closestY = innerH + radius;\n        distToBoundary = radius - (relY - innerH);\n      } else {\n        const dx = relX - innerW;\n        const dy = relY - innerH;\n        const cornerDist = Math.sqrt(dx * dx + dy * dy);\n        distToBoundary = radius - cornerDist;\n        if (cornerDist > 0) {\n          closestX = innerW + (dx / cornerDist) * radius;\n          closestY = innerH + (dy / cornerDist) * radius;\n        }\n      }\n\n      // Direction points from pixel toward closest boundary point\n      const toDirX = closestX - relX;\n      const toDirY = closestY - relY;\n      const dirLen = Math.sqrt(toDirX * toDirX + toDirY * toDirY);\n      if (dirLen > 0.001) {\n        dirX = (x > cx ? 1 : -1) * (toDirX / dirLen);\n        dirY = (y > cy ? 1 : -1) * (toDirY / dirLen);\n      }\n\n      // Apply bevel based on distance to boundary\n      if (bevel > 0 && distToBoundary < bevel && distToBoundary >= 0) {\n        const t = distanceToT(distToBoundary, bevel);\n        const { derivative } = getHeightAndDerivative(t, shape);\n        nx = dirX * derivative * 0.5;\n        ny = dirY * derivative * 0.5;\n        if (invertNormals) {\n          nx = -nx;\n          ny = -ny;\n        }\n      }\n\n      const len = Math.sqrt(nx * nx + ny * ny + nz * nz);\n      nx /= len;\n      ny /= len;\n      nz /= len;\n\n      const index = (y * w + x) * 4;\n      data[index] = ((nx * 0.5 + 0.5) * 255) | 0;\n      data[index + 1] = ((ny * 0.5 + 0.5) * 255) | 0;\n      data[index + 2] = ((nz * 0.5 + 0.5) * 255) | 0;\n      data[index + 3] = alpha;\n    }\n  }\n  return Texture.from({\n    resource: data,\n    width: w,\n    height: h,\n  });\n}\n\nexport function createDisplacementMapData(\n  width: number,\n  height: number,\n  radius: number,\n  bevel: number,\n  shape: SurfaceShape = 'squircle',\n): { data: Uint8Array; width: number; height: number } {\n  const w = Math.ceil(width);\n  const h = Math.ceil(height);\n  const data = new Uint8Array(w * h * 4);\n\n  for (let y = 0; y < h; y++) {\n    for (let x = 0; x < w; x++) {\n      const dist = getDistanceToBoundary(x, y, w, h, radius);\n      const alpha = dist >= 0 ? 255 : 0;\n\n      let displacement = 0; // Center is min height (black)\n      if (bevel > 0 && dist >= 0 && dist < bevel) {\n        const t = distanceToT(dist, bevel);\n        const { height: ht } = getHeightAndDerivative(t, shape);\n        displacement = (1 - ht) * 255; // Inverted: white at edge, black at center\n      } else if (dist < 0) {\n        displacement = 0; // Outside shape\n      }\n\n      const index = (y * w + x) * 4;\n      data[index] = displacement;\n      data[index + 1] = displacement;\n      data[index + 2] = displacement;\n      data[index + 3] = alpha;\n    }\n  }\n\n  return { data, width: w, height: h };\n}\n\nexport function createDisplacementMap(\n  width: number,\n  height: number,\n  radius: number,\n  bevel: number,\n  shape: SurfaceShape = 'squircle',\n): Texture {\n  const result = createDisplacementMapData(width, height, radius, bevel, shape);\n  return Texture.from({\n    resource: result.data,\n    width: result.width,\n    height: result.height,\n  });\n}\n","import { Texture } from 'pixi.js';\nimport type { Renderer } from 'pixi.js';\nimport { GlassSystem } from './system/GlassSystem.js';\nimport { GlassPresets } from './materials/GlassPresets.js';\nimport type { GlassPanel } from './panels/GlassPanel.js';\n\n// Re-export types for external consumers\nexport type {\n  PositionTransform,\n  PositionTransformFn,\n  LightFollowParams,\n  GlassOverlayOptions,\n  GlassItemConfig,\n} from './overlay/types.js';\n\nimport type {\n  PositionTransformFn,\n  LightFollowParams,\n  GlassOverlayOptions,\n  GlassItemConfig,\n  TrackedItem,\n} from './overlay/types.js';\n\nimport { LightFollowController } from './overlay/light-follow.js';\nimport { DomTrackingController, createAnimationHandlers } from './overlay/dom-tracking.js';\nimport { createRoundedRectNormalMap, createDisplacementMap } from './geometry/normal-map.js';\n\n// Re-export geometry functions for external use\nexport {\n  heightCircle,\n  heightSquircle,\n  smootherstep,\n  getHeightAndDerivative,\n} from './geometry/height-functions.js';\n\nexport { getDistanceToBoundary } from './geometry/distance.js';\n\nexport {\n  createRoundedRectNormalMap,\n  createDisplacementMapData,\n  createDisplacementMap,\n} from './geometry/normal-map.js';\n\n/**\n * A high-level wrapper for GlassSystem that synchronizes GlassPanels with DOM elements.\n * Ideal for adding glass effects to existing UI overlays in Nuxt/Vue/React projects.\n */\nexport class GlassOverlay {\n  public readonly system: GlassSystem;\n  private readonly tracked = new Map<HTMLElement, TrackedItem>();\n  private positionTransform?: PositionTransformFn;\n  private lightFollow: LightFollowController;\n  private domTracking: DomTrackingController;\n  private animationHandlers: ReturnType<typeof createAnimationHandlers>;\n\n  constructor(renderer: Renderer, options: GlassOverlayOptions) {\n    this.system = new GlassSystem(renderer, options.systemOptions);\n\n    this.system.setOpaqueSceneCallback((target) => {\n      renderer.render({ container: options.background, target, clear: true });\n    });\n\n    const composite = this.system.getCompositeDisplay();\n    if (composite) {\n      options.stage.addChild(composite);\n    }\n\n    // Initialize controllers\n    this.lightFollow = new LightFollowController(renderer);\n    this.domTracking = new DomTrackingController(this.tracked, {\n      syncElement: this.syncElement.bind(this),\n      updateGeometry: this.updatePanelGeometry.bind(this),\n      isCssVisible: this.isCssVisible.bind(this),\n      parseBorderRadius: this.parseBorderRadius.bind(this),\n    });\n\n    this.animationHandlers = createAnimationHandlers(\n      this.tracked,\n      this.syncElement.bind(this),\n      this.updatePanelGeometry.bind(this)\n    );\n\n    // Set up light follow cursor\n    if (options.lightFollowParams) {\n      this.setLightFollowParams(options.lightFollowParams);\n    }\n  }\n\n  setLightFollowParams(params: LightFollowParams): void {\n    this.lightFollow.setParams(params);\n  }\n\n  autoMount(selector: string = '.glass-panel'): void {\n    this.domTracking.setupObservers(\n      selector,\n      (el) => this.track(el),\n      (el) => this.untrack(el),\n      () => this.cleanup()\n    );\n  }\n\n  track(element: HTMLElement, config: GlassItemConfig = {}): GlassPanel {\n    if (this.tracked.has(element)) {\n      return this.tracked.get(element)!.panel;\n    }\n\n    const material = this.createMaterial(element, config);\n    const rect = element.getBoundingClientRect();\n    const isCircle = this.detectCircleMode(element, config);\n    const radius = this.calculateRadius(element, rect, config, isCircle);\n    const normalMap = this.createNormalMap(rect, radius, config, isCircle);\n\n    const panel = this.system.createPanel({ material, normalMap });\n    const item: TrackedItem = {\n      panel,\n      config,\n      lastRect: rect,\n      lastRadius: radius,\n      visible: true,\n      isCircle,\n      polling: false,\n    };\n\n    this.tracked.set(element, item);\n\n    // Set up observers\n    this.domTracking.observeElement(element);\n\n    // Set up animation listeners\n    element.addEventListener('transitionrun', this.animationHandlers.handleAnimationStart);\n    element.addEventListener('transitionend', this.animationHandlers.handleAnimationEnd);\n    element.addEventListener('transitioncancel', this.animationHandlers.handleAnimationEnd);\n    element.addEventListener('animationstart', this.animationHandlers.handleAnimationStart);\n    element.addEventListener('animationend', this.animationHandlers.handleAnimationEnd);\n    element.addEventListener('animationcancel', this.animationHandlers.handleAnimationEnd);\n\n    this.syncElement(element, panel);\n\n    return panel;\n  }\n\n  untrack(element: HTMLElement): void {\n    const item = this.tracked.get(element);\n    if (!item) return;\n\n    item.polling = false;\n    this.domTracking.unobserveElement(element);\n\n    element.removeEventListener('transitionrun', this.animationHandlers.handleAnimationStart);\n    element.removeEventListener('transitionend', this.animationHandlers.handleAnimationEnd);\n    element.removeEventListener('transitioncancel', this.animationHandlers.handleAnimationEnd);\n    element.removeEventListener('animationstart', this.animationHandlers.handleAnimationStart);\n    element.removeEventListener('animationend', this.animationHandlers.handleAnimationEnd);\n    element.removeEventListener('animationcancel', this.animationHandlers.handleAnimationEnd);\n\n    this.system.removePanel(item.panel);\n    this.tracked.delete(element);\n  }\n\n  update(): void {\n    this.lightFollow.update(this.tracked);\n\n    for (const [element, item] of this.tracked) {\n      this.syncElement(element, item.panel);\n    }\n    this.system.render();\n  }\n\n  resize(): void {\n    this.update();\n  }\n\n  setPositionTransform(transform: PositionTransformFn | undefined): void {\n    this.positionTransform = transform;\n  }\n\n  cleanup(): void {\n    for (const [element] of this.tracked) {\n      if (!document.body.contains(element)) {\n        this.untrack(element);\n      }\n    }\n  }\n\n  destroy(): void {\n    this.lightFollow.destroy();\n    this.domTracking.destroy();\n    this.system.destroy();\n    this.tracked.clear();\n  }\n\n  private createMaterial(element: HTMLElement, config: GlassItemConfig) {\n    const dataIor = element.dataset.glassIor ? parseFloat(element.dataset.glassIor) : undefined;\n    const dataRoughness = element.dataset.glassRoughness\n      ? parseFloat(element.dataset.glassRoughness)\n      : undefined;\n\n    const material = {\n      ...GlassPresets.clear(),\n      ...config.material,\n    };\n\n    if (dataIor !== undefined) material.ior = dataIor;\n    if (dataRoughness !== undefined) material.roughness = dataRoughness;\n\n    return material;\n  }\n\n  private detectCircleMode(element: HTMLElement, config: GlassItemConfig): boolean {\n    return config.isCircle ||\n           element.classList.contains('glass-circle') ||\n           element.hasAttribute('data-glass-circle');\n  }\n\n  private calculateRadius(element: HTMLElement, rect: DOMRect, config: GlassItemConfig, isCircle: boolean): number {\n    if (isCircle) {\n      return Math.min(rect.width, rect.height) / 2;\n    }\n    const cssRadius = this.parseBorderRadius(element, rect);\n    return config.cornerRadius ?? cssRadius;\n  }\n\n  private createNormalMap(rect: DOMRect, radius: number, config: GlassItemConfig, isCircle: boolean): Texture {\n    if (config.normalMap) return config.normalMap;\n\n    const bevel = config.bevelSize ?? 12;\n    const shape = config.surfaceShape ?? 'squircle';\n    const invertNormals = config.invertNormals ?? false;\n    const useDisplacementMap = config.useDisplacementMap ?? false;\n\n    const dpr = window.devicePixelRatio || 1;\n    const circleSize = Math.floor(Math.min(rect.width, rect.height) * dpr);\n    const mapWidth = isCircle ? circleSize : rect.width * dpr;\n    const mapHeight = isCircle ? circleSize : rect.height * dpr;\n\n    return useDisplacementMap\n      ? createDisplacementMap(mapWidth, mapHeight, radius * dpr, bevel * dpr, shape)\n      : createRoundedRectNormalMap(mapWidth, mapHeight, radius * dpr, bevel * dpr, shape, invertNormals);\n  }\n\n  private syncElement(element: HTMLElement, panel: GlassPanel): void {\n    const item = this.tracked.get(element);\n    const rect = element.getBoundingClientRect();\n\n    // Round to whole pixels to avoid subpixel blurring\n    const width = item?.isCircle ? Math.floor(Math.min(rect.width, rect.height)) : Math.round(rect.width);\n    const height = item?.isCircle ? width : Math.round(rect.height);\n    const x = Math.round(rect.left) + width / 2;\n    const y = Math.round(rect.top) + height / 2;\n\n    if (this.positionTransform) {\n      const t = this.positionTransform(x, y, width, height);\n      panel.position.set(Math.round(t.x), Math.round(t.y));\n      panel.scale.set(Math.round(width * t.scaleX), Math.round(height * t.scaleY));\n      panel.rotation = t.rotation;\n    } else {\n      panel.position.set(x, y);\n      panel.scale.set(width, height);\n      panel.rotation = 0;\n    }\n  }\n\n  private parseBorderRadius(element: HTMLElement, rect: DOMRect): number {\n    const style = window.getComputedStyle(element);\n\n    const topLeft = style.borderTopLeftRadius;\n    const topRight = style.borderTopRightRadius;\n    const bottomRight = style.borderBottomRightRadius;\n    const bottomLeft = style.borderBottomLeftRadius;\n\n    const parseValue = (value: string, dimension: number): number => {\n      if (value.endsWith('%')) {\n        return (parseFloat(value) / 100) * dimension;\n      }\n      return parseFloat(value) || 0;\n    };\n\n    const getFirstValue = (radius: string): string => {\n      return radius.split(' ')[0];\n    };\n\n    const avgDimension = (rect.width + rect.height) / 2;\n\n    const radii = [\n      parseValue(getFirstValue(topLeft), avgDimension),\n      parseValue(getFirstValue(topRight), avgDimension),\n      parseValue(getFirstValue(bottomRight), avgDimension),\n      parseValue(getFirstValue(bottomLeft), avgDimension),\n    ];\n\n    const avg = radii.reduce((a, b) => a + b, 0) / 4;\n    return avg || 20;\n  }\n\n  private isCssVisible(element: HTMLElement): boolean {\n    if (element.hidden) return false;\n    const style = window.getComputedStyle(element);\n    return style.display !== 'none' &&\n           style.visibility !== 'hidden';\n  }\n\n  private updatePanelGeometry(element: HTMLElement, item: TrackedItem): void {\n    const rect = element.getBoundingClientRect();\n    const isCircle = this.detectCircleMode(element, item.config);\n    const radius = this.calculateRadius(element, rect, item.config, isCircle);\n    const normalMap = this.createNormalMap(rect, radius, item.config, isCircle);\n\n    item.panel.setTextures({ normalMap });\n    item.lastRect = rect;\n    item.lastRadius = radius;\n  }\n}\n"],"names":["CapabilityProbe","gl","isWebGL2","extensions","tier","names","map","name","ext","param","DEFAULT_QUALITY","DEGRADATION_STEPS","q","AdaptiveQualityController","targetFrameMs","sample","overrides","avgCpu","sum","s","avgGpu","step","SceneRTManager","renderer","useDepth","Rectangle","width","height","scale","targetResolution","RenderTexture","_a","_c","_b","EventBus","event","listener","listeners","payload","key","make","material","GlassPresets","ior","clamped","PANEL_COUNTER","QUAD_GEOMETRY","MeshGeometry","BASIC_VERT","BASIC_FRAG","GlassPanel","Mesh","props","state","State","Shader","partial","textures","distanceToT","distToBoundary","bevel","heightCircle","t","heightCircleDerivative","h","heightSquircle","inner","heightSquircleDerivative","smootherstep","x","getHeightAndDerivative","shape","d","createPillGeometry","radius","expansion","segments","halfExpansion","vertexCount","positions","uvs","totalWidth","totalHeight","i","angle","idx","y","triangleCount","indices","triIdx","updatePillGeometry","geometry","posAttr","uvAttr","createPillNormalMap","invertNormals","w","data","nx","ny","nz","alpha","cx","cy","relX","relY","dirX","dirY","absX","absY","capCenterX","dx","dy","distFromCapCenter","derivative","len","index","Texture","hexToVec3","hex","createDefaultEdgeTactic","createDefaultEdgeMask","CompatibilityFilter","Filter","fragment","GlProgram","WebGL1Pipeline","Sprite","context","panels","quality","drawOpaqueScene","targets","orderedPanels","a","b","panel","sceneTexture","resources","uniforms","fullscreenVertex","jfaSeedFragment","jfaFloodFragment","jfaDistanceFragment","panelVertex","refractionFragment","revealageFragment","compositeFragment","WebGL2Pipeline","refractUniforms","UniformGroup","revealUniforms","Container","jfaSeedUniforms","jfaFloodUniforms","jfaDistanceUniforms","_d","_e","cache","normalMap","normalMapId","normalMapUpdateId","cached","distanceField","texelSize","seedResources","seedUniforms","maxDim","passes","readRT","writeRT","floodResources","floodUniforms","stepSize","temp","distResources","distUniforms","target","r","g","dummy","sceneTarget","normal","screenWidth","screenHeight","res","tint","lightDir","edgeMask","setTactic","uniform","tactic","prevShader","revealResources","GlassSystem","_options","capability","draw","GlassPanelImpl","start","duration","decision","options","message","GlassHUD","Graphics","Text","visible","metrics","fps","lastDecision","lines","LightFollowController","params","e","curve","zMin","zMax","edgeStretch","rect","dist","z","tracked","delayFactor","smoothFactor","item","DomTrackingController","callbacks","selector","trackFn","untrackFn","cleanupFn","entries","entry","element","lastRect","cssVisible","el","mutations","mutation","node","child","newRadius","createAnimationHandlers","syncElement","updateGeometry","startPolling","poll","stopPolling","getDistanceToBoundary","px","py","innerW","innerH","createRoundedRectNormalMap","subpixelOffsets","alphaSum","ox","oy","closestX","closestY","toEdgeX","toEdgeY","cornerDist","toDirX","toDirY","dirLen","createDisplacementMapData","displacement","ht","createDisplacementMap","result","GlassOverlay","composite","config","isCircle","transform","dataIor","dataRoughness","cssRadius","useDisplacementMap","dpr","circleSize","mapWidth","mapHeight","style","topLeft","topRight","bottomRight","bottomLeft","parseValue","value","dimension","getFirstValue","avgDimension"],"mappings":"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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkDlBC,GAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiDnBC,GAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA0BtBC,EAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBdC,GAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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"}