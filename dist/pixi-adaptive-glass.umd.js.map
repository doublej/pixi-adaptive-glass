{"version":3,"file":"pixi-adaptive-glass.umd.js","sources":["../src/core/CapabilityProbe.ts","../src/core/AdaptiveQualityController.ts","../src/core/SceneRTManager.ts","../src/core/EventBus.ts","../src/materials/GlassPresets.ts","../src/panels/GlassPanel.ts","../src/utils/index.ts","../src/pipelines/WebGL1Pipeline.ts","../src/shaders/webgl2.ts","../src/pipelines/WebGL2Pipeline.ts","../src/system/GlassSystem.ts","../src/hud/GlassHUD.ts","../src/GlassOverlay.ts"],"sourcesContent":["import type { CapabilityResult, CapabilityTier } from './types.js';\n\nexport class CapabilityProbe {\n  private cached?: CapabilityResult;\n\n  constructor(private readonly gl: WebGLRenderingContext | WebGL2RenderingContext) {}\n\n  run(): CapabilityResult {\n    if (this.cached) {\n      return this.cached;\n    }\n\n    const isWebGL2 = this.isWebGL2Context(this.gl);\n    const extensions = this.queryExtensions([\n      'EXT_color_buffer_float',\n      'OES_texture_float_linear',\n      'OES_standard_derivatives',\n      'EXT_disjoint_timer_query_webgl2',\n      'EXT_disjoint_timer_query',\n    ]);\n\n    const tier: CapabilityTier = isWebGL2 && this.getMaxDrawBuffers() > 1 ? 'webgl2' : 'webgl1';\n\n    this.cached = {\n      tier,\n      maxDrawBuffers: this.getMaxDrawBuffers(),\n      extensions,\n    };\n    return this.cached;\n  }\n\n  private queryExtensions(names: string[]): Record<string, boolean> {\n    return names.reduce<Record<string, boolean>>((map, name) => {\n      map[name] = Boolean(this.gl.getExtension(name));\n      return map;\n    }, {});\n  }\n\n  private getMaxDrawBuffers(): number {\n    const ext = this.gl.getExtension('WEBGL_draw_buffers');\n    const param = this.isWebGL2Context(this.gl)\n      ? this.gl.MAX_DRAW_BUFFERS\n      : ext\n        ? ext.MAX_DRAW_BUFFERS_WEBGL\n        : 0;\n    if (!param) return 1;\n    const caps = this.gl.getParameter(param) as number | null;\n    return caps ?? 1;\n  }\n\n  private isWebGL2Context(\n    gl: WebGLRenderingContext | WebGL2RenderingContext,\n  ): gl is WebGL2RenderingContext {\n    return typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\n  }\n}\n","import type { AdaptiveAction, AdaptiveDecision, RenderQualityOptions, TelemetrySample } from './types.js';\n\nconst DEFAULT_QUALITY: RenderQualityOptions = {\n  renderScale: 1,\n  enableDispersion: true,\n  enableCaustics: true,\n  enableContactShadows: true,\n  maxBlurTaps: 9,\n  edgeSupersampling: 1,\n};\n\ntype DegradationStep = {\n  check: (q: RenderQualityOptions) => boolean;\n  apply: (q: RenderQualityOptions) => void;\n  action: AdaptiveAction;\n  reason: string;\n};\n\nconst DEGRADATION_STEPS: DegradationStep[] = [\n  { check: q => q.renderScale > 0.85, apply: q => { q.renderScale = 0.85; }, action: 'scale-rt-0-85', reason: 'Frame budget exceeded' },\n  { check: q => q.renderScale > 0.7, apply: q => { q.renderScale = 0.7; }, action: 'scale-rt-0-7', reason: 'Severe perf drop' },\n  { check: q => q.maxBlurTaps > 5, apply: q => { q.maxBlurTaps = 5; }, action: 'reduce-blur', reason: 'Sustained frame drops' },\n  { check: q => q.enableDispersion, apply: q => { q.enableDispersion = false; }, action: 'disable-dispersion', reason: 'Dispersion too expensive' },\n  { check: q => q.enableCaustics || q.enableContactShadows, apply: q => { q.enableCaustics = false; q.enableContactShadows = false; }, action: 'disable-caustics', reason: 'Optional overlays disabled' },\n];\n\nexport class AdaptiveQualityController {\n  private current: RenderQualityOptions = { ...DEFAULT_QUALITY };\n  private readonly telemetry: TelemetrySample[] = [];\n  private overrides: Partial<RenderQualityOptions> = {};\n\n  constructor(private readonly targetFrameMs = 100) {}\n\n  getQuality(): RenderQualityOptions {\n    return { ...this.current };\n  }\n\n  record(sample: TelemetrySample): void {\n    this.telemetry.push(sample);\n    if (this.telemetry.length > 120) {\n      this.telemetry.shift();\n    }\n  }\n\n  setOverrides(overrides: Partial<RenderQualityOptions>): void {\n    this.overrides = { ...this.overrides, ...overrides };\n    this.current = { ...this.current, ...this.overrides };\n  }\n\n  getTelemetry(): TelemetrySample[] {\n    return [...this.telemetry];\n  }\n\n  evaluate(): AdaptiveDecision | undefined {\n    if (this.telemetry.length < 30) return undefined;\n    const avgCpu = this.telemetry.reduce((sum, s) => sum + s.cpuMs, 0) / this.telemetry.length;\n    const avgGpu = this.telemetry.reduce((sum, s) => sum + (s.gpuMs ?? s.cpuMs), 0) / this.telemetry.length;\n    if (Math.max(avgCpu, avgGpu) <= this.targetFrameMs) return undefined;\n\n    for (const step of DEGRADATION_STEPS) {\n      if (step.check(this.current)) {\n        step.apply(this.current);\n        return { action: step.action, reason: step.reason };\n      }\n    }\n    return undefined;\n  }\n}\n","import { Rectangle, RenderTexture } from 'pixi.js';\nimport type { Renderer, WebGLRenderer } from 'pixi.js';\n\ninterface RtHandles {\n  sceneColor: RenderTexture;\n  sceneDepth?: RenderTexture;\n}\n\nexport class SceneRTManager {\n  private handles?: RtHandles;\n  private scale = 1;\n  private readonly clearRect = new Rectangle();\n\n  constructor(\n    private readonly renderer: Renderer,\n    private readonly useDepth: boolean,\n  ) {}\n\n  ensure(width: number, height: number, scale: number): RtHandles {\n    const targetResolution = this.renderer.resolution * scale;\n    if (\n      !this.handles ||\n      this.handles.sceneColor.width !== width ||\n      this.handles.sceneColor.height !== height ||\n      this.handles.sceneColor.source.resolution !== targetResolution\n    ) {\n      this.dispose();\n      this.handles = {\n        sceneColor: RenderTexture.create({\n          width,\n          height,\n          resolution: targetResolution,\n          scaleMode: 'linear',\n        }),\n        sceneDepth: this.useDepth\n          ? RenderTexture.create({\n              width,\n              height,\n              resolution: targetResolution,\n              scaleMode: 'nearest',\n            })\n          : undefined,\n      };\n      this.scale = scale;\n    }\n    return this.handles;\n  }\n\n  clearTargets(): void {\n    if (!this.handles) return;\n    this.clearRect.width = this.handles.sceneColor.width;\n    this.clearRect.height = this.handles.sceneColor.height;\n    \n    const renderer = this.renderer as WebGLRenderer;\n    renderer.renderTarget.bind(this.handles.sceneColor);\n    const gl = renderer.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    if (this.handles.sceneDepth) {\n      renderer.renderTarget.bind(this.handles.sceneDepth);\n      gl.clearColor(1, 0, 0, 1); \n      gl.clearDepth(1.0);\n      gl.clear(gl.DEPTH_BUFFER_BIT);\n    }\n  }\n\n  dispose(): void {\n    this.handles?.sceneColor.destroy(true);\n    this.handles?.sceneDepth?.destroy(true);\n    this.handles = undefined;\n  }\n}\n","type Listener<T> = (payload: T) => void;\n\ntype EventMap = Record<string, unknown>;\n\nexport class EventBus<Events extends EventMap> {\n  private listeners: { [K in keyof Events]?: Set<Listener<Events[K]>> } = {};\n\n  on<K extends keyof Events>(event: K, listener: Listener<Events[K]>): void {\n    let listeners = this.listeners[event];\n    if (!listeners) {\n      listeners = new Set();\n      this.listeners[event] = listeners;\n    }\n    listeners.add(listener);\n  }\n\n  off<K extends keyof Events>(event: K, listener: Listener<Events[K]>): void {\n    this.listeners[event]?.delete(listener);\n  }\n\n  emit<K extends keyof Events>(event: K, payload: Events[K]): void {\n    const listeners = this.listeners[event];\n    if (!listeners) return;\n    for (const listener of listeners) {\n      listener(payload);\n    }\n  }\n\n  removeAll(): void {\n    for (const key of Object.keys(this.listeners) as Array<keyof Events>) {\n      this.listeners[key]?.clear();\n    }\n  }\n}\n","import type { GlassMaterial } from '../core/types.js';\n\nconst make = (material: GlassMaterial): GlassMaterial => material;\n\nexport const GlassPresets = {\n  water(): GlassMaterial {\n    return make({\n      ior: 1.333,\n      thickness: 0.6,\n      roughness: 0.1,\n      dispersion: 0.02,\n      opacity: 1.0,\n      tint: 0x9fd9ff,\n    });\n  },\n  crownGlass(): GlassMaterial {\n    return make({\n      ior: 1.52,\n      thickness: 0.8,\n      roughness: 0.05,\n      dispersion: 0.04,\n      opacity: 1.0,\n      tint: 0xffffff,\n    });\n  },\n  acrylic(): GlassMaterial {\n    return make({\n      ior: 1.49,\n      thickness: 0.7,\n      roughness: 0.12,\n      dispersion: 0.01,\n      opacity: 1.0,\n      tint: 0xf7f7f7,\n    });\n  },\n  clear(): GlassMaterial {\n    return make({\n      ior: 1.52,\n      thickness: 0.8,\n      roughness: 0.05,\n      dispersion: 0.04,\n      opacity: 1.0,\n      tint: 0xffffff,\n    });\n  },\n  fromIOR(ior: number): GlassMaterial {\n    const clamped = Math.min(Math.max(ior, 1.0), 2.0);\n    return make({\n      ior: clamped,\n      thickness: 0.75,\n      roughness: 0.08,\n      dispersion: (clamped - 1) * 0.05,\n      opacity: 1.0,\n      tint: 0xffffff,\n    });\n  },\n};\n","  import { Mesh, MeshGeometry, Shader, State } from 'pixi.js';\nimport type { Texture } from 'pixi.js';\nimport type { CapabilityTier, GlassMaterial, GlassPanelProps } from '../core/types.js';\n\nlet PANEL_COUNTER = 0;\n\n// Use MeshGeometry which auto-maps to aPosition and aUV attributes\n// Centered geometry (-0.5 to 0.5) - position is center, scale is size\nconst QUAD_GEOMETRY = new MeshGeometry({\n  positions: new Float32Array([-0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5]),\n  uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n  indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\nconst BASIC_VERT = `\nprecision mediump float;\nattribute vec2 aPosition;\nattribute vec2 aUV;\nvarying vec2 vUv;\nuniform mat3 translationMatrix;\nuniform mat3 projectionMatrix;\nuniform mat3 uTextureMatrix;\nvoid main(void){\n  vUv = aUV;\n  gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aPosition, 1.0)).xy, 0.0, 1.0);\n}\n`;\n\nconst BASIC_FRAG = `\nprecision mediump float;\nvarying vec2 vUv;\nvoid main(void){\n  gl_FragColor = vec4(vUv, 0.0, 1.0);\n}\n`;\n\nexport class GlassPanel extends Mesh {\n  id: string;\n  glassMaterial: GlassMaterial;\n  normalMap?: Texture;\n  dudvMap?: Texture;\n  causticsAtlas?: Texture;\n  sdfShadow?: Texture;\n  private tier: CapabilityTier = 'webgl1';\n\n  constructor(props: GlassPanelProps) {\n    const state = State.for2d();\n    state.culling = false; // Disable culling to avoid winding order issues\n\n    super({\n      geometry: props.geometry ?? QUAD_GEOMETRY,\n      shader: Shader.from({\n        gl: {\n          vertex: BASIC_VERT,\n          fragment: BASIC_FRAG,\n        },\n      }) as any,\n      state,\n    });\n    this.id = props.id ?? `glass-panel-${++PANEL_COUNTER}`;\n    this.glassMaterial = props.material;\n    this.normalMap = props.normalMap;\n    this.dudvMap = props.dudvMap;\n    this.causticsAtlas = props.causticsAtlas;\n    this.sdfShadow = props.sdfShadow;\n    if (props.filters) {\n      this.filters = props.filters;\n    }\n  }\n\n  setMaterial(partial: Partial<GlassMaterial>): void {\n    this.glassMaterial = { ...this.glassMaterial, ...partial };\n  }\n\n  setTextures(textures: Partial<Omit<GlassPanelProps, 'material' | 'geometry'>>): void {\n    if (textures.normalMap) this.normalMap = textures.normalMap;\n    if (textures.dudvMap) this.dudvMap = textures.dudvMap;\n    if (textures.causticsAtlas) this.causticsAtlas = textures.causticsAtlas;\n    if (textures.sdfShadow) this.sdfShadow = textures.sdfShadow;\n  }\n\n  setTier(tier: CapabilityTier): void {\n    this.tier = tier;\n  }\n\n  getTier(): CapabilityTier {\n    return this.tier;\n  }\n}\n","export function hexToVec3(hex: number): [number, number, number] {\n  return [\n    ((hex >> 16) & 0xff) / 255,\n    ((hex >> 8) & 0xff) / 255,\n    (hex & 0xff) / 255,\n  ];\n}\n","import { Filter, Sprite, Texture, GlProgram } from 'pixi.js';\nimport type { RenderTexture, Renderer } from 'pixi.js';\nimport { SceneRTManager } from '../core/SceneRTManager.js';\nimport type { RenderQualityOptions } from '../core/types.js';\nimport type { GlassPanel } from '../panels/GlassPanel.js';\nimport type { Pipeline, PipelineContext } from './BasePipeline.js';\nimport { hexToVec3 } from '../utils/index.js';\n\nclass CompatibilityFilter extends Filter {\n  constructor() {\n    const fragment = `\n      precision mediump float;\n      varying vec2 vTextureCoord;\n      uniform sampler2D uSceneColor;\n      uniform sampler2D uNormalMap;\n      uniform vec2 uInvResolution;\n      uniform float uDispersion;\n      uniform float uRoughness;\n      uniform float uDisplacementScale;\n      uniform vec3 uTint;\n      uniform float uOpacity;\n      uniform bool uEnableDispersion;\n      vec3 sampleScene(vec2 uv){\n        return texture2D(uSceneColor, clamp(uv, vec2(0.001), vec2(0.999))).rgb;\n      }\n      void main(){\n        vec3 normal = texture2D(uNormalMap, vTextureCoord).xyz * 2.0 - 1.0;\n        vec2 offset = normal.xy * uDisplacementScale;\n        vec2 baseUV = vTextureCoord + offset;\n        vec3 color = sampleScene(baseUV);\n        if(uEnableDispersion){\n          color.r = sampleScene(baseUV + offset * (1.0 + uDispersion)).r;\n          color.b = sampleScene(baseUV - offset * (1.0 + uDispersion)).b;\n        }\n        float radius = uRoughness * 4.0;\n        if(radius > 0.001){\n          vec3 blurAccum = vec3(0.0);\n          float taps = 0.0;\n          for(int i=0;i<4;i++){\n            float angle = 6.2831853 * float(i) / 4.0;\n            vec2 sampleOffset = vec2(cos(angle), sin(angle)) * radius * uInvResolution;\n            blurAccum += sampleScene(baseUV + sampleOffset);\n            taps += 1.0;\n          }\n          color = mix(color, blurAccum / max(taps, 1.0), 0.7);\n        }\n        gl_FragColor = vec4(color * uTint * uOpacity, uOpacity);\n      }\n    `;\n    super({\n      glProgram: new GlProgram({\n          vertex: `\n            attribute vec2 aVertexPosition;\n            attribute vec2 aTextureCoord;\n            uniform mat3 projectionMatrix;\n            varying vec2 vTextureCoord;\n            void main(void){\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n                vTextureCoord = aTextureCoord;\n            }\n          `,\n          fragment,\n      }),\n      resources: {\n        uSceneColor: Texture.WHITE.source,\n        uNormalMap: Texture.WHITE.source,\n        uniforms: {\n            uInvResolution: { value: [1, 1], type: 'vec2<f32>' },\n            uDispersion: { value: 0, type: 'f32' },\n            uRoughness: { value: 0, type: 'f32' },\n            uDisplacementScale: { value: 0.01, type: 'f32' },\n            uTint: { value: [1, 1, 1], type: 'vec3<f32>' },\n            uOpacity: { value: 1, type: 'f32' },\n            uEnableDispersion: { value: 0, type: 'f32' }, // boolean as float\n        }\n      },\n    });\n  }\n}\n\nexport class WebGL1Pipeline implements Pipeline {\n  readonly id = 'webgl1';\n  private readonly filter = new CompatibilityFilter();\n  private readonly rtManager: SceneRTManager;\n  private readonly blitSprite: Sprite;\n\n  constructor(private readonly renderer: Renderer) {\n    this.rtManager = new SceneRTManager(renderer, false);\n    this.blitSprite = new Sprite(Texture.WHITE);\n  }\n\n  setup(): void {}\n\n  render(context: PipelineContext): void {\n    const { renderer, panels, quality, drawOpaqueScene } = context;\n    const targets = this.rtManager.ensure(\n      renderer.screen.width,\n      renderer.screen.height,\n      quality.renderScale,\n    );\n    \n    drawOpaqueScene(targets.sceneColor);\n    \n    this.blitSprite.texture = targets.sceneColor;\n    this.blitSprite.width = renderer.screen.width;\n    this.blitSprite.height = renderer.screen.height;\n    \n    renderer.render({ container: this.blitSprite, clear: true });\n    \n    const orderedPanels = [...panels].sort((a, b) => (a.zIndex ?? 0) - (b.zIndex ?? 0));\n    for (const panel of orderedPanels) {\n      this.applyFilter(panel, targets.sceneColor, quality);\n      renderer.render({ container: panel });\n    }\n  }\n\n  dispose(): void {\n    this.rtManager.dispose();\n  }\n\n  private applyFilter(\n    panel: GlassPanel,\n    sceneTexture: RenderTexture,\n    quality: RenderQualityOptions,\n  ): void {\n    const needsFilter =\n      Boolean(panel.normalMap || panel.dudvMap) ||\n      panel.glassMaterial.dispersion > 0.001 ||\n      panel.glassMaterial.roughness > 0.001;\n    if (!needsFilter) {\n      panel.filters = null;\n      return;\n    }\n    const resources = this.filter.resources;\n    // Assign textures to resources\n    (resources as any).uSceneColor = sceneTexture.source;\n    (resources as any).uNormalMap = (panel.normalMap ?? panel.dudvMap ?? Texture.WHITE).source;\n    \n    const uniforms = (resources as any).uniforms;\n    uniforms.uInvResolution = [1 / sceneTexture.width, 1 / sceneTexture.height];\n    uniforms.uDispersion = panel.glassMaterial.dispersion;\n    uniforms.uRoughness = panel.glassMaterial.roughness;\n    uniforms.uDisplacementScale = panel.glassMaterial.thickness * 0.1;\n    uniforms.uTint = hexToVec3(panel.glassMaterial.tint ?? 0xffffff);\n    uniforms.uOpacity = panel.glassMaterial.opacity;\n    uniforms.uEnableDispersion = quality.enableDispersion && panel.glassMaterial.dispersion > 0.001 ? 1 : 0;\n    \n    panel.filters = [this.filter];\n  }\n}\n","export const fullscreenVertex = `\nprecision mediump float;\nattribute vec2 aPosition;\nattribute vec2 aUV;\nvarying vec2 vUv;\nvoid main(void){\n  vUv = aUV;\n  vec2 pos = aPosition * 2.0 - 1.0;\n  gl_Position = vec4(pos, 0.0, 1.0);\n}\n`;\n\nexport const panelVertex = `\nprecision mediump float;\nattribute vec2 aPosition;\nattribute vec2 aUV;\nvarying vec2 vUv;\nuniform vec2 uPosition;\nuniform vec2 uScale;\nuniform vec2 uResolution;\nvoid main(void){\n  vUv = aUV;\n  vec2 worldPos = aPosition * uScale + uPosition;\n  vec2 clipPos = (worldPos / uResolution) * 2.0 - 1.0;\n  gl_Position = vec4(clipPos, 0.0, 1.0);\n}\n`;\n\nexport const refractionFragment = `\nprecision highp float;\nvarying vec2 vUv;\nuniform sampler2D uSceneColor;\nuniform sampler2D uNormalMap;\nuniform sampler2D uCausticsMap;\nuniform vec2 uInvResolution;\nuniform float uIOR;\nuniform float uThickness;\nuniform float uDispersion;\nuniform float uRoughness;\nuniform float uOpacity;\nuniform bool uEnableDispersion;\nuniform bool uEnableCaustics;\nuniform vec3 uTint;\nuniform float uSpecular;\nuniform float uShininess;\nuniform float uShadow;\nuniform vec3 uLightDir;\nuniform float uBlurSamples;\nuniform float uBlurSpread;\nuniform float uBlurAngle;\nuniform float uBlurAnisotropy;\nuniform float uBlurGamma;\nuniform float uAberrationR;\nuniform float uAberrationB;\nuniform float uAO;\nuniform float uAORadius;\nuniform float uNoiseScale;\nuniform float uNoiseIntensity;\nuniform float uNoiseRotation;\nuniform float uNoiseThreshold;\nuniform float uEdgeSupersampling;\nuniform float uEdgeSmoothWidth;\nuniform float uEdgeContrast;\nuniform float uEdgeAlphaFalloff;\nuniform float uEdgeMaskCutoff;\nuniform bool uEnableEdgeSmoothing;\nuniform bool uEnableContrastReduction;\nuniform bool uEnableAlphaFalloff;\nuniform bool uEnableTintOpacity;\nuniform float uEdgeBlur;\nuniform float uGlassSupersampling;\nuniform vec2 uPanelSize;\n\n// Simple value noise\nfloat hash(vec2 p) {\n  return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat valueNoise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  f = f * f * (3.0 - 2.0 * f); // smoothstep\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n  return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nvec2 rotateUV(vec2 uv, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\n}\n\nvec3 sampleScene(vec2 uv){\n  return texture2D(uSceneColor, clamp(uv, vec2(0.001), vec2(0.999))).rgb;\n}\n\nvec3 sampleDispersion(vec2 baseUV, vec2 offset){\n  if(!uEnableDispersion){\n    return sampleScene(baseUV + offset);\n  }\n  vec3 result;\n  result.r = sampleScene(baseUV + offset * (1.0 + uDispersion * uAberrationR)).r;\n  result.g = sampleScene(baseUV + offset).g;\n  result.b = sampleScene(baseUV + offset * (1.0 - uDispersion * uAberrationB)).b;\n  return result;\n}\n\nvec3 sampleFrostedColor(vec2 baseUV, vec2 offset){\n  // Scale blur by panel size relative to reference (200px)\n  float referenceSize = 200.0;\n  float avgPanelSize = (uPanelSize.x + uPanelSize.y) * 0.5;\n  float sizeScale = avgPanelSize / referenceSize;\n\n  float radius = uRoughness * uBlurSpread * sizeScale;\n  vec3 accum = vec3(0.0);\n  float totalWeight = 0.0;\n  int samples = int(uBlurSamples);\n\n  // Golden angle spiral for better sample distribution\n  float goldenAngle = 2.39996323;\n\n  // Directional blur rotation matrix\n  float ca = cos(uBlurAngle);\n  float sa = sin(uBlurAngle);\n\n  for(int i=0;i<32;i++){\n    if(i >= samples) break;\n\n    // Normalized distance from center (0 to 1)\n    float t = float(i) / float(samples - 1);\n\n    // Apply gamma curve to sample distribution\n    float curvedT = pow(t, uBlurGamma);\n    float r = curvedT * radius;\n\n    float angle = float(i) * goldenAngle;\n    vec2 dir = vec2(cos(angle), sin(angle));\n\n    // Apply anisotropy (stretch in one direction)\n    if(uBlurAnisotropy > 0.001){\n      // Rotate to blur angle, apply stretch, rotate back\n      vec2 rotated = vec2(ca * dir.x + sa * dir.y, -sa * dir.x + ca * dir.y);\n      rotated.y *= (1.0 - uBlurAnisotropy);\n      dir = vec2(ca * rotated.x - sa * rotated.y, sa * rotated.x + ca * rotated.y);\n    }\n\n    vec2 sampleOffset = dir * r * uInvResolution;\n\n    // Weight samples by distance (softer falloff)\n    float w = 1.0 - curvedT * 0.5;\n    accum += sampleDispersion(baseUV, offset + sampleOffset) * w;\n    totalWeight += w;\n  }\n  return accum / max(totalWeight, 1.0);\n}\n\nvoid main(){\n  vec2 screenUV = gl_FragCoord.xy * uInvResolution;\n\n  vec4 normalSample = texture2D(uNormalMap, vUv);\n  float mask = normalSample.a;\n\n  // Blur the mask at edges for softer borders\n  if (uEdgeBlur > 0.0 && mask < 0.9) {\n    float blurredMask = 0.0;\n    float blurWeight = 0.0;\n    vec2 texelSize = uInvResolution * uEdgeBlur;\n    for (int x = -2; x <= 2; x++) {\n      for (int y = -2; y <= 2; y++) {\n        vec2 offset = vec2(float(x), float(y)) * texelSize;\n        float sampleMask = texture2D(uNormalMap, vUv + offset).a;\n        float weight = 1.0 - length(vec2(float(x), float(y))) * 0.2;\n        blurredMask += sampleMask * weight;\n        blurWeight += weight;\n      }\n    }\n    mask = blurredMask / blurWeight;\n  }\n\n  // Discard pixels outside the masked area (border radius)\n  if (mask < uEdgeMaskCutoff) {\n    discard;\n  }\n\n  // Simple refraction offset based on normal map\n  vec2 normal = normalSample.xy * 2.0 - 1.0;\n\n  // Edge smoothing with configurable width\n  float edgeSmoothness = 1.0;\n  if (uEnableEdgeSmoothing) {\n    float smoothWidth = uEdgeSmoothWidth * (0.5 + 0.5 * uEdgeSupersampling);\n    edgeSmoothness = smoothstep(0.0, smoothWidth, mask);\n  }\n\n  float contrastReduction = 1.0;\n  if (uEnableContrastReduction) {\n    contrastReduction = mix(uEdgeContrast, 1.0, edgeSmoothness);\n  }\n\n  // Apply noise distortion to normal (anchored to container via vUv)\n  if (uNoiseIntensity > 0.001) {\n    vec2 noiseUV = rotateUV(vUv * uNoiseScale, uNoiseRotation * 3.14159 / 180.0);\n    float n = valueNoise(noiseUV);\n    float n2 = valueNoise(noiseUV + vec2(100.0, 100.0));\n    // Apply threshold\n    n = smoothstep(uNoiseThreshold, 1.0, n) * (1.0 - uNoiseThreshold) + n * uNoiseThreshold;\n    n2 = smoothstep(uNoiseThreshold, 1.0, n2) * (1.0 - uNoiseThreshold) + n2 * uNoiseThreshold;\n    vec2 noiseNormal = (vec2(n, n2) - 0.5) * 2.0 * uNoiseIntensity;\n    normal += noiseNormal;\n  }\n\n  vec2 offset = normal * uThickness * 0.1 * (uIOR - 1.0);\n\n  vec3 refracted;\n  if (uGlassSupersampling > 1.0) {\n    // Supersample the entire glass panel\n    vec3 ssColor = vec3(0.0);\n    int samples = int(uGlassSupersampling * uGlassSupersampling);\n    float ssStep = 1.0 / uGlassSupersampling;\n    int sampleIdx = 0;\n    for (int x = 0; x < 4; x++) {\n      if (x >= int(uGlassSupersampling)) break;\n      for (int y = 0; y < 4; y++) {\n        if (y >= int(uGlassSupersampling)) break;\n        vec2 ssOffset = (vec2(float(x), float(y)) * ssStep - 0.5 + ssStep * 0.5) * uInvResolution;\n        ssColor += sampleFrostedColor(screenUV + ssOffset, offset);\n        sampleIdx++;\n      }\n    }\n    refracted = ssColor / float(sampleIdx);\n  } else {\n    refracted = sampleFrostedColor(screenUV, offset);\n  }\n  // Apply tint as color mix instead of multiply to preserve visibility\n  float tintStrength = 0.3;\n  refracted = mix(refracted, refracted * uTint + uTint * 0.1, tintStrength);\n\n  // Calculate lighting from normal map (now includes noise)\n  vec3 N = normalize(vec3(normal, normalSample.b * 2.0 - 1.0));\n  float NdotL = max(0.0, dot(N, normalize(uLightDir)));\n\n  // Specular highlight (Blinn-Phong)\n  vec3 viewDir = vec3(0.0, 0.0, 1.0);\n  vec3 halfDir = normalize(normalize(uLightDir) + viewDir);\n  float spec = pow(max(0.0, dot(N, halfDir)), uShininess) * uSpecular;\n\n  // Shadow from normal facing away from light\n  float shadowFactor = 1.0 - uShadow * (1.0 - NdotL);\n\n  // Ambient occlusion based on edge distance (darker at edges/outside)\n  float edgeDist = length(normal);\n  float aoFactor = 1.0 - uAO * smoothstep(0.0, uAORadius, edgeDist);\n\n  // Apply lighting\n  refracted = refracted * shadowFactor * aoFactor + vec3(spec);\n\n  // Apply contrast reduction at edges and tint intensity to overall opacity\n  if (uEnableContrastReduction) {\n    refracted *= contrastReduction;\n  }\n\n  // Use normal map alpha as shape mask\n  float shapeMask = normalSample.a;\n  if (shapeMask < 0.5) discard;\n\n  gl_FragColor = vec4(refracted, 1.0);\n}\n`;\n\nexport const revealageFragment = `\nprecision mediump float;\nvarying vec2 vUv;\nuniform sampler2D uNormalMap;\nuniform float uOpacity;\nvoid main(){\n  vec4 normalSample = texture2D(uNormalMap, vUv);\n  float mask = normalSample.a;\n\n  // Discard pixels outside the masked area (border radius)\n  if (mask < 0.01) {\n    discard;\n  }\n\n  float alpha = uOpacity * mask;\n  float revealage = exp(-3.0 * alpha);\n  gl_FragColor = vec4(revealage);\n}\n`;\n\nexport const compositeFragment = `\nprecision mediump float;\nvarying vec2 vUv;\nuniform sampler2D uSceneColor;\nuniform sampler2D uAccum;\nuniform sampler2D uReveal;\nvoid main(){\n  vec4 accum = texture2D(uAccum, vUv);\n  vec3 scene = texture2D(uSceneColor, vUv).rgb;\n\n  // Simple alpha blend: accum.a is opacity\n  vec3 result = mix(scene, accum.rgb, accum.a);\n  gl_FragColor = vec4(result, 1.0);\n}\n`;\n","import {\n  Container,\n  Mesh,\n  MeshGeometry,\n  RenderTexture,\n  Shader,\n  Sprite,\n  State,\n  Texture,\n  UniformGroup,\n} from 'pixi.js';\nimport type { Renderer } from 'pixi.js';\nimport { SceneRTManager } from '../core/SceneRTManager.js';\nimport type { GlassPanel } from '../panels/GlassPanel.js';\nimport {\n  compositeFragment,\n  fullscreenVertex,\n  panelVertex,\n  refractionFragment,\n  revealageFragment,\n} from '../shaders/webgl2.js';\nimport type { Pipeline, PipelineContext } from './BasePipeline.js';\nimport type { RenderQualityOptions } from '../core/types.js';\nimport { hexToVec3 } from '../utils/index.js';\n\n// Fullscreen quad with 0..1 positions for clip space mapping\nconst QUAD_GEOMETRY = new MeshGeometry({\n  positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n  uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n  indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\nexport class WebGL2Pipeline implements Pipeline {\n  readonly id = 'webgl2';\n  private readonly rtManager: SceneRTManager;\n  private readonly refractShader: Shader;\n  private readonly revealageShader: Shader;\n  private readonly compositeShader: Shader;\n  private readonly fullScreenQuad: Mesh<MeshGeometry, Shader>;\n  private readonly shadowSprite: Sprite;\n  private readonly panelParent: Container;\n  private compositeRT?: RenderTexture;\n  private readonly compositeSprite: Sprite;\n  private accumRT?: RenderTexture;\n  private revealRT?: RenderTexture;\n\n  constructor(\n    private readonly renderer: Renderer,\n    useDepth: boolean,\n  ) {\n    this.rtManager = new SceneRTManager(renderer, useDepth);\n    const refractUniforms = new UniformGroup({\n      uPosition: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n      uScale: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uResolution: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uInvResolution: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uIOR: { value: 1, type: 'f32' },\n      uThickness: { value: 1, type: 'f32' },\n      uDispersion: { value: 0, type: 'f32' },\n      uRoughness: { value: 0, type: 'f32' },\n      uOpacity: { value: 1, type: 'f32' },\n      uEnableDispersion: { value: 0, type: 'f32' },\n      uEnableCaustics: { value: 0, type: 'f32' },\n      uTint: { value: new Float32Array([1, 1, 1]), type: 'vec3<f32>' },\n      uSpecular: { value: 0, type: 'f32' },\n      uShininess: { value: 32, type: 'f32' },\n      uShadow: { value: 0, type: 'f32' },\n      uLightDir: { value: new Float32Array([0.5, 0.5, 1]), type: 'vec3<f32>' },\n      uBlurSamples: { value: 8, type: 'f32' },\n      uBlurSpread: { value: 4, type: 'f32' },\n      uBlurAngle: { value: 0, type: 'f32' },\n      uBlurAnisotropy: { value: 0, type: 'f32' },\n      uBlurGamma: { value: 1, type: 'f32' },\n      uAberrationR: { value: 1, type: 'f32' },\n      uAberrationB: { value: 1, type: 'f32' },\n      uAO: { value: 0, type: 'f32' },\n      uAORadius: { value: 0.5, type: 'f32' },\n      uNoiseScale: { value: 20, type: 'f32' },\n      uNoiseIntensity: { value: 0, type: 'f32' },\n      uNoiseRotation: { value: 0, type: 'f32' },\n      uNoiseThreshold: { value: 0, type: 'f32' },\n      uEdgeSupersampling: { value: 1, type: 'f32' },\n      uEdgeSmoothWidth: { value: 0.15, type: 'f32' },\n      uEdgeContrast: { value: 0.7, type: 'f32' },\n      uEdgeAlphaFalloff: { value: 1, type: 'f32' },\n      uEdgeMaskCutoff: { value: 0.001, type: 'f32' },\n      uEnableEdgeSmoothing: { value: 1, type: 'f32' },\n      uEnableContrastReduction: { value: 1, type: 'f32' },\n      uEnableAlphaFalloff: { value: 1, type: 'f32' },\n      uEnableTintOpacity: { value: 1, type: 'f32' },\n      uEdgeBlur: { value: 0, type: 'f32' },\n      uGlassSupersampling: { value: 1, type: 'f32' },\n      uPanelSize: { value: new Float32Array([200, 200]), type: 'vec2<f32>' },\n    });\n    this.refractShader = Shader.from({\n      gl: { vertex: panelVertex, fragment: refractionFragment },\n      resources: {\n        uSceneColor: Texture.WHITE.source,\n        uNormalMap: Texture.WHITE.source,\n        uCausticsMap: Texture.WHITE.source,\n        panelUniforms: refractUniforms,\n      },\n    });\n    const revealUniforms = new UniformGroup({\n      uPosition: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n      uScale: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uResolution: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uOpacity: { value: 1, type: 'f32' },\n    });\n    this.revealageShader = Shader.from({\n      gl: { vertex: panelVertex, fragment: revealageFragment },\n      resources: {\n        uNormalMap: Texture.WHITE.source,\n        panelUniforms: revealUniforms,\n      },\n    });\n    this.compositeShader = Shader.from({\n      gl: { vertex: fullscreenVertex, fragment: compositeFragment },\n      resources: {\n        uSceneColor: Texture.WHITE.source,\n        uAccum: Texture.WHITE.source,\n        uReveal: Texture.WHITE.source,\n      },\n    });\n    this.fullScreenQuad = new Mesh({\n      geometry: QUAD_GEOMETRY,\n      shader: this.compositeShader,\n    });\n    this.fullScreenQuad.state = State.for2d();\n    this.fullScreenQuad.state.culling = false; // Disable culling\n    this.shadowSprite = new Sprite(Texture.WHITE);\n    this.panelParent = new Container();\n    this.panelParent.alpha = 1;\n    this.compositeSprite = new Sprite(Texture.EMPTY);\n    // Ensure composite sprite is visible and on top\n    this.compositeSprite.position.set(0, 0);\n    this.compositeSprite.visible = true;\n    this.compositeSprite.alpha = 1;\n    this.compositeSprite.zIndex = 9999; // Force on top\n  }\n\n  setup(): void {}\n\n  render(context: PipelineContext): void {\n    const { renderer, panels, quality, drawOpaqueScene } = context;\n    const width = renderer.screen.width;\n    const height = renderer.screen.height;\n    const targets = this.rtManager.ensure(width, height, quality.renderScale);\n    this.ensureAccumTargets(width, height);\n    this.ensureCompositeTarget(width, height);\n\n    drawOpaqueScene(targets.sceneColor);\n\n    this.clearTarget(this.accumRT, 0, 0, 0, 0);\n    this.clearTarget(this.revealRT, 1, 1, 1, 1);\n\n    for (const panel of panels) {\n      this.renderPanel(panel, quality, targets.sceneColor);\n    }\n\n    this.fullScreenQuad.shader = this.compositeShader;\n    (this.compositeShader as any).resources.uSceneColor = targets.sceneColor.source;\n    (this.compositeShader as any).resources.uAccum = this.accumRT?.source;\n    (this.compositeShader as any).resources.uReveal = this.revealRT?.source;\n\n    this.fullScreenQuad.width = renderer.screen.width;\n    this.fullScreenQuad.height = renderer.screen.height;\n\n    this.fullScreenQuad.updateLocalTransform();\n    this.fullScreenQuad.worldTransform.copyFrom(this.fullScreenQuad.localTransform);\n\n    // Render composite quad to texture\n    renderer.render({ container: this.fullScreenQuad, target: this.compositeRT, clear: true });\n\n    if (this.compositeRT) {\n      this.compositeSprite.texture = this.compositeRT;\n      this.compositeSprite.width = width;\n      this.compositeSprite.height = height;\n      this.compositeSprite.visible = true;\n    }\n\n    this.renderContactShadows(panels, quality);\n  }\n\n  dispose(): void {\n    this.rtManager.dispose();\n    this.accumRT?.destroy(true);\n    this.revealRT?.destroy(true);\n    this.compositeRT?.destroy(true);\n  }\n\n  private ensureAccumTargets(width: number, height: number): void {\n    const targetResolution = this.renderer.resolution;\n    if (!this.accumRT || this.accumRT.width !== width || this.accumRT.height !== height || this.accumRT.source.resolution !== targetResolution) {\n      this.accumRT?.destroy(true);\n      this.accumRT = RenderTexture.create({\n        width,\n        height,\n        resolution: targetResolution,\n      });\n    }\n    if (!this.revealRT || this.revealRT.width !== width || this.revealRT.height !== height || this.revealRT.source.resolution !== targetResolution) {\n      this.revealRT?.destroy(true);\n      this.revealRT = RenderTexture.create({\n        width,\n        height,\n        resolution: targetResolution,\n      });\n    }\n  }\n\n  private clearTarget(\n    target: RenderTexture | undefined,\n    r: number,\n    g: number,\n    b: number,\n    a: number,\n  ): void {\n    if (!target) return;\n    const dummy = new Container();\n    this.renderer.render({ container: dummy, target, clear: true, clearColor: [r, g, b, a] });\n  }\n\n  private renderPanel(\n    panel: GlassPanel,\n    quality: RenderQualityOptions,\n    sceneTarget: RenderTexture,\n  ): void {\n    if (!this.accumRT || !this.revealRT) return;\n    const normal = panel.normalMap ?? Texture.WHITE;\n    const screenWidth = this.renderer.screen.width;\n    const screenHeight = this.renderer.screen.height;\n\n    const resources = (this.refractShader as any).resources;\n    if (resources) {\n      resources.uSceneColor = sceneTarget.source;\n      resources.uNormalMap = normal.source;\n      resources.uCausticsMap = (panel.causticsAtlas ?? Texture.WHITE).source;\n\n      // Update uniforms through UniformGroup in v8\n      const uniforms = resources.panelUniforms?.uniforms;\n      if (uniforms) {\n        // Use accumRT resolution since gl_FragCoord is in accumRT pixel space\n        const res = this.accumRT?.source?._resolution ?? this.renderer.resolution;\n        uniforms.uPosition[0] = panel.position.x;\n        uniforms.uPosition[1] = panel.position.y;\n        uniforms.uScale[0] = panel.scale.x;\n        uniforms.uScale[1] = panel.scale.y;\n        uniforms.uResolution[0] = screenWidth;\n        uniforms.uResolution[1] = screenHeight;\n        uniforms.uInvResolution[0] = 1 / (screenWidth * res);\n        uniforms.uInvResolution[1] = 1 / (screenHeight * res);\n        uniforms.uIOR = panel.glassMaterial.ior;\n        uniforms.uThickness = panel.glassMaterial.thickness;\n        uniforms.uDispersion = panel.glassMaterial.dispersion;\n        uniforms.uRoughness = panel.glassMaterial.roughness;\n        uniforms.uOpacity = panel.glassMaterial.opacity ?? 1;\n        uniforms.uEnableDispersion =\n          quality.enableDispersion && panel.glassMaterial.dispersion > 0.001 ? 1 : 0;\n        uniforms.uEnableCaustics = quality.enableCaustics && Boolean(panel.causticsAtlas) ? 1 : 0;\n        const tint = hexToVec3(panel.glassMaterial.tint ?? 0xffffff);\n        uniforms.uTint[0] = tint[0];\n        uniforms.uTint[1] = tint[1];\n        uniforms.uTint[2] = tint[2];\n        uniforms.uSpecular = panel.glassMaterial.specular ?? 0;\n        uniforms.uShininess = panel.glassMaterial.shininess ?? 32;\n        uniforms.uShadow = panel.glassMaterial.shadow ?? 0;\n        const lightDir = panel.glassMaterial.lightDir ?? [0.5, 0.5, 1];\n        uniforms.uLightDir[0] = lightDir[0];\n        uniforms.uLightDir[1] = lightDir[1];\n        uniforms.uLightDir[2] = lightDir[2];\n        uniforms.uBlurSamples = panel.glassMaterial.blurSamples ?? 8;\n        uniforms.uBlurSpread = panel.glassMaterial.blurSpread ?? 4;\n        uniforms.uBlurAngle = (panel.glassMaterial.blurAngle ?? 0) * Math.PI / 180;\n        uniforms.uBlurAnisotropy = panel.glassMaterial.blurAnisotropy ?? 0;\n        uniforms.uBlurGamma = panel.glassMaterial.blurGamma ?? 1;\n        uniforms.uAberrationR = panel.glassMaterial.aberrationR ?? 1;\n        uniforms.uAberrationB = panel.glassMaterial.aberrationB ?? 1;\n        uniforms.uAO = panel.glassMaterial.ao ?? 0;\n        uniforms.uAORadius = panel.glassMaterial.aoRadius ?? 0.5;\n        uniforms.uNoiseScale = panel.glassMaterial.noiseScale ?? 20;\n        uniforms.uNoiseIntensity = panel.glassMaterial.noiseIntensity ?? 0;\n        uniforms.uNoiseRotation = panel.glassMaterial.noiseRotation ?? 0;\n        uniforms.uNoiseThreshold = panel.glassMaterial.noiseThreshold ?? 0;\n        uniforms.uEdgeSupersampling = quality.edgeSupersampling ?? 1;\n        uniforms.uEdgeSmoothWidth = panel.glassMaterial.edgeSmoothWidth ?? 0.15;\n        uniforms.uEdgeContrast = panel.glassMaterial.edgeContrast ?? 0.7;\n        uniforms.uEdgeAlphaFalloff = panel.glassMaterial.edgeAlphaFalloff ?? 1;\n        uniforms.uEdgeMaskCutoff = panel.glassMaterial.edgeMaskCutoff ?? 0.001;\n        uniforms.uEnableEdgeSmoothing = panel.glassMaterial.enableEdgeSmoothing === true ? 1 : 0;\n        uniforms.uEnableContrastReduction = panel.glassMaterial.enableContrastReduction === true ? 1 : 0;\n        uniforms.uEnableAlphaFalloff = panel.glassMaterial.enableAlphaFalloff === true ? 1 : 0;\n        uniforms.uEnableTintOpacity = panel.glassMaterial.enableTintOpacity === true ? 1 : 0;\n        uniforms.uEdgeBlur = panel.glassMaterial.edgeBlur ?? 0;\n        uniforms.uGlassSupersampling = panel.glassMaterial.glassSupersampling ?? 1;\n        uniforms.uPanelSize[0] = panel.scale.x;\n        uniforms.uPanelSize[1] = panel.scale.y;\n      }\n    }\n\n    const prevShader = panel.shader;\n    panel.shader = this.refractShader as any;\n    this.drawPanelToTarget(panel, this.accumRT);\n\n    panel.shader = this.revealageShader as any;\n\n    const revealResources = (this.revealageShader as any).resources;\n    if (revealResources) {\n      revealResources.uNormalMap = normal.source;\n\n      const revealUniforms = revealResources.panelUniforms?.uniforms;\n      if (revealUniforms) {\n        revealUniforms.uPosition[0] = panel.position.x;\n        revealUniforms.uPosition[1] = panel.position.y;\n        revealUniforms.uScale[0] = panel.scale.x;\n        revealUniforms.uScale[1] = panel.scale.y;\n        revealUniforms.uResolution[0] = screenWidth;\n        revealUniforms.uResolution[1] = screenHeight;\n        revealUniforms.uOpacity = panel.glassMaterial.opacity;\n      }\n    }\n\n    this.drawPanelToTarget(panel, this.revealRT);\n    panel.shader = prevShader;\n  }\n\n  private renderContactShadows(panels: GlassPanel[], quality: RenderQualityOptions): void {\n    if (!quality.enableContactShadows) return;\n    for (const panel of panels) {\n      if (!panel.sdfShadow) continue;\n      this.shadowSprite.texture = panel.sdfShadow;\n      this.shadowSprite.position.copyFrom(panel.position);\n      this.shadowSprite.scale.copyFrom(panel.scale);\n      this.shadowSprite.rotation = panel.rotation;\n      this.shadowSprite.alpha = Math.min(panel.glassMaterial.opacity + 0.2, 0.9);\n      // this.shadowSprite.state.blendMode = BLEND_MODES.MULTIPLY;\n      this.renderer.render(this.shadowSprite);\n    }\n  }\n\n  getCompositeDisplay(): Container | undefined {\n    return this.compositeSprite;\n  }\n\n  private drawPanelToTarget(panel: GlassPanel, target: RenderTexture): void {\n    const renderer = this.renderer;\n    const gl = (renderer as any).gl as WebGL2RenderingContext;\n\n    // Clear parent and add only this panel\n    this.panelParent.removeChildren();\n    this.panelParent.addChild(panel);\n\n    // Update transforms for detached container in v8\n    panel.updateLocalTransform();\n    panel.worldTransform.copyFrom(panel.localTransform);\n\n    // Use standard alpha blending\n    if (gl) {\n      gl.enable(gl.BLEND);\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n    }\n\n    renderer.render({ container: this.panelParent, target, clear: false });\n\n    // Reset blend state\n    if (gl) {\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    }\n  }\n\n  private ensureCompositeTarget(width: number, height: number): void {\n    const targetResolution = this.renderer.resolution;\n    if (\n      !this.compositeRT ||\n      this.compositeRT.width !== width ||\n      this.compositeRT.height !== height ||\n      this.compositeRT.source.resolution !== targetResolution\n    ) {\n      this.compositeRT?.destroy(true);\n      this.compositeRT = RenderTexture.create({\n        width,\n        height,\n        resolution: targetResolution,\n      });\n      this.compositeSprite.texture = this.compositeRT;\n    }\n  }\n}\n","import type { Container, RenderTexture, Renderer, WebGLRenderer } from 'pixi.js';\nimport { AdaptiveQualityController } from '../core/AdaptiveQualityController.js';\nimport { CapabilityProbe } from '../core/CapabilityProbe.js';\nimport { EventBus } from '../core/EventBus.js';\nimport type {\n  AdaptiveDecision,\n  FallbackEvent,\n  GlassPanelProps,\n  GlassSystemOptions,\n  RenderQualityOptions,\n} from '../core/types.js';\nimport type { GlassPanel } from '../panels/GlassPanel.js';\nimport { GlassPanel as GlassPanelImpl } from '../panels/GlassPanel.js';\nimport type { Pipeline } from '../pipelines/BasePipeline.js';\nimport { WebGL1Pipeline } from '../pipelines/WebGL1Pipeline.js';\nimport { WebGL2Pipeline } from '../pipelines/WebGL2Pipeline.js';\n\ninterface GlassSystemEvents {\n  'quality:decision': AdaptiveDecision;\n  fallback: FallbackEvent;\n  [key: string]: any; // Add index signature to satisfy EventMap\n}\n\nexport class GlassSystem {\n  private pipeline: Pipeline;\n  private readonly panels: GlassPanel[] = [];\n  private readonly quality = new AdaptiveQualityController();\n  private drawOpaqueScene: (target: RenderTexture) => void = () => {};\n  private readonly events = new EventBus<GlassSystemEvents>();\n\n  constructor(\n    private readonly renderer: Renderer,\n    _options: GlassSystemOptions = {},\n  ) {\n    const gl = (renderer as WebGLRenderer).gl;\n    const capability = new CapabilityProbe(gl).run();\n    this.pipeline =\n      capability.tier === 'webgl2'\n        ? new WebGL2Pipeline(renderer, true)\n        : new WebGL1Pipeline(renderer);\n    if (capability.tier === 'webgl1') {\n      this.emitFallback('webgl', 'MRT unavailable, using compatibility pipeline');\n    }\n  }\n\n  setOpaqueSceneCallback(draw: (target: RenderTexture) => void): void {\n    this.drawOpaqueScene = draw;\n  }\n\n  createPanel(props: GlassPanelProps): GlassPanel {\n    const panel = new GlassPanelImpl(props);\n    this.panels.push(panel);\n    return panel;\n  }\n\n  removePanel(panel: GlassPanel): void {\n    const idx = this.panels.indexOf(panel);\n    if (idx >= 0) {\n      this.panels.splice(idx, 1);\n      panel.destroy({ children: true, texture: false, textureSource: false });\n    }\n  }\n\n  render(): void {\n    const start = performance.now();\n    const quality = this.quality.getQuality();\n    this.pipeline.render({\n      renderer: this.renderer,\n      panels: this.panels,\n      quality,\n      drawOpaqueScene: this.drawOpaqueScene,\n    });\n    const duration = performance.now() - start;\n    this.quality.record({ cpuMs: duration, timestamp: start });\n    const decision = this.quality.evaluate();\n    if (decision) {\n      this.events.emit('quality:decision', decision);\n    }\n  }\n\n  setQuality(options: Partial<RenderQualityOptions>): void {\n    this.quality.setOverrides(options);\n  }\n\n  destroy(): void {\n    for (const panel of this.panels) {\n      panel.destroy({ children: true, texture: false, textureSource: false });\n    }\n    this.panels.length = 0;\n    this.pipeline.dispose();\n    this.events.removeAll();\n  }\n\n  on<K extends keyof GlassSystemEvents>(\n    event: K,\n    listener: (payload: GlassSystemEvents[K]) => void,\n  ): void {\n    this.events.on(event, listener);\n  }\n\n  off<K extends keyof GlassSystemEvents>(\n    event: K,\n    listener: (payload: GlassSystemEvents[K]) => void,\n  ): void {\n    this.events.off(event, listener);\n  }\n\n  getPipelineId(): string {\n    return this.pipeline.id;\n  }\n\n  getCompositeDisplay(): Container | undefined {\n    if (typeof this.pipeline.getCompositeDisplay === 'function') {\n      return this.pipeline.getCompositeDisplay();\n    }\n    return undefined;\n  }\n\n  private emitFallback(target: string, message: string): void {\n    const event: FallbackEvent = { target, message, timestamp: performance.now() };\n    console.warn(`GlassSystem fallback: ${target} - ${message}`);\n    this.events.emit('fallback', event);\n  }\n}\n","import { Container, Graphics, Text } from 'pixi.js';\nimport type { Renderer } from 'pixi.js';\nimport type { AdaptiveDecision, RenderQualityOptions, TelemetrySample } from '../core/types.js';\n\ninterface HudMetrics {\n  quality: RenderQualityOptions;\n  fps: number;\n  lastDecision?: AdaptiveDecision;\n  telemetry: TelemetrySample[];\n}\n\nexport class GlassHUD {\n  readonly container = new Container();\n  private readonly panel: Graphics;\n  private readonly text: Text;\n  private visible = false;\n\n  constructor(private readonly renderer: Renderer) {\n    this.panel = new Graphics()\n      .beginFill(0x000000, 0.65)\n      .drawRoundedRect(0, 0, 260, 120, 8)\n      .endFill();\n    this.text = new Text('Glass HUD', { fontSize: 12, fill: 0xffffff });\n    this.text.position.set(12, 10);\n    this.container.addChild(this.panel, this.text);\n    this.container.visible = this.visible;\n    this.container.position.set(12, 12);\n  }\n\n  setVisible(visible: boolean): void {\n    this.visible = visible;\n    this.container.visible = visible;\n  }\n\n  update(metrics: HudMetrics): void {\n    if (!this.visible) return;\n    const { quality, fps, lastDecision } = metrics;\n    const lines = [\n      `FPS: ${fps.toFixed(1)}`,\n      `Scale: ${(quality.renderScale * 100).toFixed(0)}%`,\n      `Blur taps: ${quality.maxBlurTaps}`,\n      `Dispersion: ${quality.enableDispersion ? 'on' : 'off'}`,\n      `Caustics: ${quality.enableCaustics ? 'on' : 'off'}`,\n    ];\n    if (lastDecision) {\n      lines.push(`Action: ${lastDecision.action}`);\n    }\n    this.text.text = lines.join('\\n');\n  }\n}\n","import { Container, Texture } from 'pixi.js';\nimport type { Renderer } from 'pixi.js';\nimport { GlassSystem } from './system/GlassSystem.js';\nimport { GlassPresets } from './materials/GlassPresets.js';\nimport type { GlassPanel } from './panels/GlassPanel.js';\nimport type { GlassMaterial, SurfaceShape } from './core/types.js';\n\nexport interface PositionTransform {\n  x: number;\n  y: number;\n  scaleX: number;\n  scaleY: number;\n  rotation: number;\n}\n\nexport type PositionTransformFn = (\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n) => PositionTransform;\n\nexport interface LightFollowParams {\n  followCursor: boolean;\n  smoothing?: number; // 0 - 1, amount of smoothing (0 = instant, 1 = very slow, default 0.9)\n  delay?: number; // 0 - 1, lag before movement starts (0 = instant, 1 = max lag, default 0.5)\n  curve?: number; // 0.5 - 3, z falloff curve (default 1.5)\n  zMin?: number; // minimum z value (default 0.05)\n  zMax?: number; // maximum z value (default 0.20)\n  edgeStretch?: number; // 0.1 - 2, how much to stretch toward edges (< 1 = more edge, > 1 = more center, default 0.5)\n}\n\nexport interface GlassOverlayOptions {\n  /**\n   * The container holding the background content that should be seen through the glass.\n   * This will be rendered into the glass system's backdrop texture.\n   */\n  background: Container;\n\n  /**\n   * The container where the glass composite effect should be added.\n   * Typically the same stage, or a layer above the background.\n   */\n  stage: Container;\n\n  /**\n   * Optional initial configuration for the GlassSystem.\n   */\n  systemOptions?: {\n    hudEnabled?: boolean;\n  };\n\n  /**\n   * Optional light follow cursor settings.\n   */\n  lightFollowParams?: LightFollowParams;\n}\n\nexport interface GlassItemConfig {\n  /**\n   * Custom material overrides for this element.\n   */\n  material?: Partial<GlassMaterial>;\n\n  /**\n   * Optional custom normal map. If not provided, a default rounded rect map is generated.\n   */\n  normalMap?: Texture;\n\n  /**\n   * Corner radius for the default normal map generation. Defaults to 20.\n   */\n  cornerRadius?: number;\n\n  /**\n   * Surface shape for the glass bevel. Defaults to 'squircle'.\n   * - circle: Simple circular arc (sharper edges)\n   * - squircle: Softer flatcurve transition (smoother, default)\n   * - concave: Bowl-like depression (light diverges outward)\n   * - lip: Raised rim with shallow center dip\n   */\n  surfaceShape?: SurfaceShape;\n\n  /**\n   * How far the bevel extends from the edge toward center (in pixels).\n   * Defaults to 12.\n   */\n  bevelSize?: number;\n\n  /**\n   * Flip the normal map on X axis. Defaults to false.\n   */\n  flipX?: boolean;\n\n  /**\n   * Flip the normal map on Y axis. Defaults to false.\n   */\n  flipY?: boolean;\n\n  /**\n   * Bezier curve control points for custom bevel shape [x1, y1, x2, y2].\n   * When provided, overrides surfaceShape.\n   */\n  bezierCurve?: [number, number, number, number];\n\n  /**\n   * Render as a circle. Sets corner radius to half the minimum dimension.\n   * Can also be triggered by adding 'glass-circle' class or data-glass-circle attribute.\n   */\n  isCircle?: boolean;\n}\n\n/**\n * A high-level wrapper for GlassSystem that synchronizes GlassPanels with DOM elements.\n * Ideal for adding glass effects to existing UI overlays in Nuxt/Vue/React projects.\n */\ninterface TrackedItem {\n  panel: GlassPanel;\n  config: GlassItemConfig;\n  lastRect?: DOMRect;\n  lastRadius: number;\n  visible: boolean;\n  isCircle: boolean;\n  polling: boolean;\n}\n\nexport class GlassOverlay {\n  public readonly system: GlassSystem;\n  private readonly tracked = new Map<HTMLElement, TrackedItem>();\n  private readonly background: Container;\n  private observer?: MutationObserver;\n  private resizeObserver?: ResizeObserver;\n  private intersectionObserver?: IntersectionObserver;\n  private positionTransform?: PositionTransformFn;\n\n  // Light follow cursor\n  private lightFollowParams?: LightFollowParams;\n  private currentLightDir: [number, number, number] = [0, 0, 0.15];\n  private targetLightDir: [number, number, number] = [0, 0, 0.15];\n  private delayedLightDir: [number, number, number] = [0, 0, 0.15];\n  private boundMouseMove?: (e: MouseEvent) => void;\n\n  private renderer: Renderer;\n\n  constructor(renderer: Renderer, options: GlassOverlayOptions) {\n    this.renderer = renderer;\n    this.background = options.background;\n    this.system = new GlassSystem(renderer, options.systemOptions);\n\n    this.system.setOpaqueSceneCallback((target) => {\n      renderer.render({ container: this.background, target, clear: true });\n    });\n\n    const composite = this.system.getCompositeDisplay();\n    if (composite) {\n      options.stage.addChild(composite);\n    }\n\n    // Set up light follow cursor\n    if (options.lightFollowParams) {\n      this.setLightFollowParams(options.lightFollowParams);\n    }\n  }\n\n  setLightFollowParams(params: LightFollowParams): void {\n    this.lightFollowParams = params;\n\n    if (params.followCursor && !this.boundMouseMove) {\n      this.boundMouseMove = (e: MouseEvent) => {\n        const curve = params.curve ?? 1.5;\n        const zMin = params.zMin ?? 0.05;\n        const zMax = params.zMax ?? 0.20;\n        const edgeStretch = params.edgeStretch ?? 0.5;\n\n        // Get canvas bounds for proper coordinate mapping\n        const canvas = this.renderer.canvas as HTMLCanvasElement;\n        const rect = canvas.getBoundingClientRect();\n\n        // Convert cursor position to -1 to 1 range relative to canvas\n        let x = ((e.clientX - rect.left) / rect.width) * 2 - 1;\n        let y = ((e.clientY - rect.top) / rect.height) * 2 - 1; // Y: top=-1, bottom=1\n\n        // Apply edge stretch - power curve controls how values spread\n        // < 1 = stretch toward edges, > 1 = compress toward center\n        x = Math.sign(x) * Math.pow(Math.abs(x), edgeStretch);\n        y = Math.sign(y) * Math.pow(Math.abs(y), edgeStretch);\n\n        // Z decreases toward edges based on curve, capped at zMax (0.20)\n        const dist = Math.sqrt(x * x + y * y);\n        const z = Math.max(zMin, Math.min(zMax, zMax - Math.pow(dist, curve) * zMax * 0.5));\n\n        this.targetLightDir = [x, y, z];\n      };\n      window.addEventListener('mousemove', this.boundMouseMove);\n    } else if (!params.followCursor && this.boundMouseMove) {\n      window.removeEventListener('mousemove', this.boundMouseMove);\n      this.boundMouseMove = undefined;\n    }\n  }\n\n  autoMount(selector: string = '.glass-panel'): void {\n    // Set up ResizeObserver for size changes\n    this.resizeObserver = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const element = entry.target as HTMLElement;\n        const item = this.tracked.get(element);\n        if (!item) continue;\n\n        const rect = element.getBoundingClientRect();\n        const lastRect = item.lastRect;\n\n        // Check if size changed significantly (more than 1px)\n        if (lastRect && (\n          Math.abs(rect.width - lastRect.width) > 1 ||\n          Math.abs(rect.height - lastRect.height) > 1\n        )) {\n          this.updatePanelGeometry(element, item);\n        }\n        item.lastRect = rect;\n      }\n    });\n\n    // Set up IntersectionObserver for visibility\n    this.intersectionObserver = new IntersectionObserver((entries) => {\n      for (const entry of entries) {\n        const element = entry.target as HTMLElement;\n        const item = this.tracked.get(element);\n        if (!item) continue;\n\n        item.visible = entry.isIntersecting;\n        const cssVisible = this.isCssVisible(element);\n        item.panel.visible = item.visible && cssVisible;\n      }\n    });\n\n    const existing = document.querySelectorAll<HTMLElement>(selector);\n    existing.forEach((el) => this.track(el));\n\n    this.observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.type === 'childList') {\n          mutation.addedNodes.forEach((node) => {\n            if (node instanceof HTMLElement && node.matches(selector)) {\n              this.track(node);\n            }\n            if (node instanceof HTMLElement) {\n              const children = node.querySelectorAll<HTMLElement>(selector);\n              children.forEach((child) => this.track(child));\n            }\n          });\n          mutation.removedNodes.forEach((node) => {\n            if (node instanceof HTMLElement && this.tracked.has(node)) {\n              this.untrack(node);\n            }\n          });\n        } else if (mutation.type === 'attributes') {\n          const target = mutation.target as HTMLElement;\n          if (mutation.attributeName === 'class') {\n            if (target.matches(selector)) {\n              this.track(target);\n            } else {\n              this.untrack(target);\n            }\n          } else if (mutation.attributeName === 'style') {\n            const item = this.tracked.get(target);\n            if (item) {\n              // Check for visibility changes\n              const cssVisible = this.isCssVisible(target);\n              item.panel.visible = cssVisible && item.visible;\n\n              // Check for border-radius changes\n              const rect = target.getBoundingClientRect();\n              const newRadius = this.parseBorderRadius(target, rect);\n              if (Math.abs(newRadius - item.lastRadius) > 0.5) {\n                this.updatePanelGeometry(target, item);\n              }\n            }\n          } else if (mutation.attributeName === 'hidden') {\n            const item = this.tracked.get(target);\n            if (item) {\n              const cssVisible = this.isCssVisible(target);\n              item.panel.visible = cssVisible && item.visible;\n            }\n          }\n        }\n      }\n      this.cleanup();\n    });\n\n    this.observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: ['class', 'style', 'hidden'],\n    });\n  }\n\n  track(element: HTMLElement, config: GlassItemConfig = {}): GlassPanel {\n    if (this.tracked.has(element)) {\n      return this.tracked.get(element)!.panel;\n    }\n\n    const dataIor = element.dataset.glassIor ? parseFloat(element.dataset.glassIor) : undefined;\n    const dataRoughness = element.dataset.glassRoughness\n      ? parseFloat(element.dataset.glassRoughness)\n      : undefined;\n\n    const material = {\n      ...GlassPresets.clear(),\n      ...config.material,\n    };\n\n    if (dataIor !== undefined) material.ior = dataIor;\n    if (dataRoughness !== undefined) material.roughness = dataRoughness;\n\n    // Calculate dynamic normal map based on initial size\n    const rect = element.getBoundingClientRect();\n\n    // Detect circle mode from config, class, or data attribute\n    const isCircle = config.isCircle ||\n                     element.classList.contains('glass-circle') ||\n                     element.hasAttribute('data-glass-circle');\n\n    let radius: number;\n    if (isCircle) {\n      // Circle: radius = half the smaller dimension\n      radius = Math.min(rect.width, rect.height) / 2;\n    } else {\n      const cssRadius = this.parseBorderRadius(element, rect);\n      radius = config.cornerRadius ?? cssRadius; // Config overrides CSS\n    }\n    const bevel = config.bevelSize ?? 12;\n\n    const shape = config.surfaceShape ?? 'squircle';\n    const flipX = config.flipX ?? false;\n    const flipY = config.flipY ?? false;\n    const bezierCurve = config.bezierCurve;\n\n    // For circles, use square dimensions\n    const circleSize = Math.floor(Math.min(rect.width, rect.height));\n    const mapWidth = isCircle ? circleSize : rect.width;\n    const mapHeight = isCircle ? circleSize : rect.height;\n\n    const normalMap =\n      config.normalMap || createRoundedRectNormalMap(mapWidth, mapHeight, radius, bevel, shape, flipX, flipY, bezierCurve);\n\n    const panel = this.system.createPanel({\n      material,\n      normalMap,\n    });\n\n    this.tracked.set(element, { panel, config, lastRect: rect, lastRadius: radius, visible: true, isCircle, polling: false });\n\n    // Set up observers for this element\n    this.resizeObserver?.observe(element);\n    this.intersectionObserver?.observe(element);\n\n    // Set up animation/transition listeners\n    element.addEventListener('transitionrun', this.handleAnimationStart);\n    element.addEventListener('transitionend', this.handleAnimationEnd);\n    element.addEventListener('transitioncancel', this.handleAnimationEnd);\n    element.addEventListener('animationstart', this.handleAnimationStart);\n    element.addEventListener('animationend', this.handleAnimationEnd);\n    element.addEventListener('animationcancel', this.handleAnimationEnd);\n\n    this.syncElement(element, panel);\n\n    return panel;\n  }\n\n  private handleAnimationStart = (e: Event) => {\n    const element = e.currentTarget as HTMLElement;\n    this.startPolling(element);\n  };\n\n  private handleAnimationEnd = (e: Event) => {\n    const element = e.currentTarget as HTMLElement;\n    // Check if any animations are still running\n    const animations = element.getAnimations();\n    if (animations.length === 0) {\n      this.stopPolling(element);\n    }\n  };\n\n  private startPolling(element: HTMLElement): void {\n    const item = this.tracked.get(element);\n    if (!item || item.polling) return;\n\n    item.polling = true;\n    const poll = () => {\n      if (!item.polling) return;\n      this.syncElement(element, item.panel);\n      requestAnimationFrame(poll);\n    };\n    requestAnimationFrame(poll);\n  }\n\n  private stopPolling(element: HTMLElement): void {\n    const item = this.tracked.get(element);\n    if (!item) return;\n\n    item.polling = false;\n    this.updatePanelGeometry(element, item);\n  }\n\n  untrack(element: HTMLElement): void {\n    const item = this.tracked.get(element);\n    if (item) {\n      item.polling = false;\n      this.resizeObserver?.unobserve(element);\n      this.intersectionObserver?.unobserve(element);\n      element.removeEventListener('transitionrun', this.handleAnimationStart);\n      element.removeEventListener('transitionend', this.handleAnimationEnd);\n      element.removeEventListener('transitioncancel', this.handleAnimationEnd);\n      element.removeEventListener('animationstart', this.handleAnimationStart);\n      element.removeEventListener('animationend', this.handleAnimationEnd);\n      element.removeEventListener('animationcancel', this.handleAnimationEnd);\n      this.system.removePanel(item.panel);\n      this.tracked.delete(element);\n    }\n  }\n\n  update(): void {\n    // Update light direction with delay and smoothing\n    if (this.lightFollowParams?.followCursor) {\n      // Delay: lerp delayed toward target (0 = instant, 1 = very slow)\n      const delay = this.lightFollowParams.delay ?? 0.5;\n      const delayFactor = 1 - delay * 0.97; // Convert to lerp factor (0.03 to 1)\n      this.delayedLightDir[0] += (this.targetLightDir[0] - this.delayedLightDir[0]) * delayFactor;\n      this.delayedLightDir[1] += (this.targetLightDir[1] - this.delayedLightDir[1]) * delayFactor;\n      this.delayedLightDir[2] += (this.targetLightDir[2] - this.delayedLightDir[2]) * delayFactor;\n\n      // Smoothing: lerp current toward delayed (0 = instant, 1 = very slow)\n      const smoothing = this.lightFollowParams.smoothing ?? 0.9;\n      const smoothFactor = 1 - smoothing * 0.97; // Convert to lerp factor (0.03 to 1)\n      this.currentLightDir[0] += (this.delayedLightDir[0] - this.currentLightDir[0]) * smoothFactor;\n      this.currentLightDir[1] += (this.delayedLightDir[1] - this.currentLightDir[1]) * smoothFactor;\n      this.currentLightDir[2] += (this.delayedLightDir[2] - this.currentLightDir[2]) * smoothFactor;\n\n      // Apply to all panels\n      for (const [, item] of this.tracked) {\n        item.panel.glassMaterial.lightDir = [...this.currentLightDir];\n      }\n    }\n\n    for (const [element, item] of this.tracked) {\n      this.syncElement(element, item.panel);\n    }\n    this.system.render();\n  }\n\n  resize(): void {\n    this.update();\n  }\n\n  setPositionTransform(transform: PositionTransformFn | undefined): void {\n    this.positionTransform = transform;\n  }\n\n  cleanup(): void {\n    for (const [element] of this.tracked) {\n      if (!document.body.contains(element)) {\n        this.untrack(element);\n      }\n    }\n  }\n\n  destroy(): void {\n    if (this.boundMouseMove) {\n      window.removeEventListener('mousemove', this.boundMouseMove);\n      this.boundMouseMove = undefined;\n    }\n    this.observer?.disconnect();\n    this.resizeObserver?.disconnect();\n    this.intersectionObserver?.disconnect();\n    this.system.destroy();\n    this.tracked.clear();\n  }\n\n  private syncElement(element: HTMLElement, panel: GlassPanel) {\n    const item = this.tracked.get(element);\n    const rect = element.getBoundingClientRect();\n\n    const x = rect.left + rect.width / 2;\n    const y = rect.top + rect.height / 2;\n\n    // For circles, use the smaller dimension for both width and height\n    let width = rect.width;\n    let height = rect.height;\n    if (item?.isCircle) {\n      const size = Math.floor(Math.min(rect.width, rect.height));\n      width = size;\n      height = size;\n    }\n\n    if (this.positionTransform) {\n      const t = this.positionTransform(x, y, width, height);\n      panel.position.set(t.x, t.y);\n      panel.scale.set(width * t.scaleX, height * t.scaleY);\n      panel.rotation = t.rotation;\n    } else {\n      panel.position.set(x, y);\n      panel.scale.set(width, height);\n      panel.rotation = 0;\n    }\n  }\n\n  private parseBorderRadius(element: HTMLElement, rect: DOMRect): number {\n    const style = window.getComputedStyle(element);\n\n    // Get all four corner radii (computed style always returns individual values)\n    const topLeft = style.borderTopLeftRadius;\n    const topRight = style.borderTopRightRadius;\n    const bottomRight = style.borderBottomRightRadius;\n    const bottomLeft = style.borderBottomLeftRadius;\n\n    // Parse a single radius value (handles px and %)\n    const parseValue = (value: string, dimension: number): number => {\n      if (value.endsWith('%')) {\n        return (parseFloat(value) / 100) * dimension;\n      }\n      return parseFloat(value) || 0;\n    };\n\n    // For elliptical corners (e.g., \"10px 20px\"), use the first value (horizontal)\n    const getFirstValue = (radius: string): string => {\n      return radius.split(' ')[0];\n    };\n\n    // Use average of width/height for percentage calculations\n    const avgDimension = (rect.width + rect.height) / 2;\n\n    // Parse all corners and return the average\n    const radii = [\n      parseValue(getFirstValue(topLeft), avgDimension),\n      parseValue(getFirstValue(topRight), avgDimension),\n      parseValue(getFirstValue(bottomRight), avgDimension),\n      parseValue(getFirstValue(bottomLeft), avgDimension),\n    ];\n\n    // Return average radius, or use the most common value\n    const avg = radii.reduce((a, b) => a + b, 0) / 4;\n    return avg || 20; // Default to 20 if parsing fails\n  }\n\n  private isCssVisible(element: HTMLElement): boolean {\n    if (element.hidden) return false;\n    const style = window.getComputedStyle(element);\n    return style.display !== 'none' &&\n           style.visibility !== 'hidden';\n  }\n\n  private updatePanelGeometry(element: HTMLElement, item: TrackedItem): void {\n    const rect = element.getBoundingClientRect();\n\n    // Detect circle mode\n    const isCircle = item.config.isCircle ||\n                     element.classList.contains('glass-circle') ||\n                     element.hasAttribute('data-glass-circle');\n\n    let radius: number;\n    if (isCircle) {\n      radius = Math.min(rect.width, rect.height) / 2;\n    } else {\n      const cssRadius = this.parseBorderRadius(element, rect);\n      radius = item.config.cornerRadius ?? cssRadius;\n    }\n    const bevel = item.config.bevelSize ?? 12;\n    const shape = item.config.surfaceShape ?? 'squircle';\n    const flipX = item.config.flipX ?? false;\n    const flipY = item.config.flipY ?? false;\n    const bezierCurve = item.config.bezierCurve;\n\n    // For circles, use square dimensions\n    const circleSize = Math.floor(Math.min(rect.width, rect.height));\n    const mapWidth = isCircle ? circleSize : rect.width;\n    const mapHeight = isCircle ? circleSize : rect.height;\n\n    // Regenerate normal map with new dimensions/radius\n    const normalMap = createRoundedRectNormalMap(\n      mapWidth, mapHeight, radius, bevel, shape, flipX, flipY, bezierCurve\n    );\n\n    // Update the panel's normal map\n    item.panel.setTextures({ normalMap });\n    item.lastRect = rect;\n    item.lastRadius = radius;\n  }\n}\n\n// Height functions for different surface shapes\n// t is normalized distance from inner edge (0) to outer edge (1)\nexport function heightCircle(t: number): number {\n  return Math.sqrt(Math.max(0, 2 * t - t * t));\n}\n\nfunction heightCircleDerivative(t: number): number {\n  const h = Math.sqrt(Math.max(0.0001, 2 * t - t * t));\n  return (1 - t) / h;\n}\n\nexport function heightSquircle(t: number): number {\n  const inner = 1 - Math.pow(1 - t, 4);\n  return Math.pow(Math.max(0, inner), 0.25);\n}\n\nfunction heightSquircleDerivative(t: number): number {\n  const inner = 1 - Math.pow(1 - t, 4);\n  if (inner <= 0.0001) return 0;\n  return Math.pow(1 - t, 3) / Math.pow(inner, 0.75);\n}\n\nexport function smootherstep(t: number): number {\n  const x = Math.max(0, Math.min(1, t));\n  return x * x * x * (x * (x * 6 - 15) + 10);\n}\n\nfunction smootherstepDerivative(t: number): number {\n  const x = Math.max(0, Math.min(1, t));\n  return 30 * x * x * (x - 1) * (x - 1);\n}\n\n// Cubic bezier evaluation\nfunction cubicBezier(t: number, p0: number, p1: number, p2: number, p3: number): number {\n  const mt = 1 - t;\n  return mt * mt * mt * p0 + 3 * mt * mt * t * p1 + 3 * mt * t * t * p2 + t * t * t * p3;\n}\n\nfunction cubicBezierDerivative(t: number, p0: number, p1: number, p2: number, p3: number): number {\n  const mt = 1 - t;\n  return 3 * mt * mt * (p1 - p0) + 6 * mt * t * (p2 - p1) + 3 * t * t * (p3 - p2);\n}\n\nexport function getBezierHeightAndDerivative(\n  t: number,\n  curve: [number, number, number, number],\n): { height: number; derivative: number } {\n  // curve = [x1, y1, x2, y2] control points for cubic bezier from (0,0) to (1,1)\n  const height = cubicBezier(t, 0, curve[1], curve[3], 1);\n  const derivative = cubicBezierDerivative(t, 0, curve[1], curve[3], 1);\n  return { height, derivative };\n}\n\nexport function getHeightAndDerivative(\n  t: number,\n  shape: SurfaceShape,\n  bezierCurve?: [number, number, number, number],\n): { height: number; derivative: number } {\n  // Use bezier curve if provided\n  if (bezierCurve) {\n    return getBezierHeightAndDerivative(t, bezierCurve);\n  }\n  switch (shape) {\n    case 'circle': {\n      return { height: heightCircle(t), derivative: heightCircleDerivative(t) };\n    }\n    case 'squircle': {\n      return { height: heightSquircle(t), derivative: heightSquircleDerivative(t) };\n    }\n    case 'concave': {\n      const h = heightSquircle(t);\n      const d = heightSquircleDerivative(t);\n      return { height: 1 - h, derivative: -d };\n    }\n    case 'lip': {\n      const convexH = heightSquircle(t);\n      const convexD = heightSquircleDerivative(t);\n      const concaveH = 1 - convexH;\n      const concaveD = -convexD;\n      const blend = smootherstep(t);\n      const blendD = smootherstepDerivative(t);\n      const height = convexH * (1 - blend) + concaveH * blend;\n      const derivative = convexD * (1 - blend) + concaveD * blend + (concaveH - convexH) * blendD;\n      return { height, derivative };\n    }\n    case 'dome': {\n      // Full hemisphere - height goes from 0 at edge to 1 at center\n      const h = Math.sqrt(Math.max(0, 1 - t * t));\n      const d = t > 0.001 ? -t / h : 0;\n      return { height: h, derivative: d };\n    }\n    case 'ridge': {\n      // Sharp peak - inverse of dome\n      const h = 1 - Math.sqrt(Math.max(0, 1 - t * t));\n      const d = t > 0.001 ? t / Math.sqrt(Math.max(0.001, 1 - t * t)) : 0;\n      return { height: h, derivative: d };\n    }\n    case 'wave': {\n      // Sinusoidal wave\n      const h = (1 - Math.cos(t * Math.PI)) / 2;\n      const d = (Math.PI * Math.sin(t * Math.PI)) / 2;\n      return { height: h, derivative: d };\n    }\n    case 'flat': {\n      // No bevel, completely flat\n      return { height: 0, derivative: 0 };\n    }\n  }\n}\n\nfunction createRoundedRectNormalMap(\n  width: number,\n  height: number,\n  radius: number,\n  bevel: number,\n  shape: SurfaceShape,\n  flipX: boolean = false,\n  flipY: boolean = false,\n  bezierCurve?: [number, number, number, number],\n): Texture {\n  const w = Math.ceil(width);\n  const h = Math.ceil(height);\n  const data = new Uint8Array(w * h * 4);\n\n  for (let y = 0; y < h; y++) {\n    for (let x = 0; x < w; x++) {\n      let nx = 0;\n      let ny = 0;\n      let nz = 1;\n      let alpha = 255;\n\n      // Use pixel centers for proper symmetry (pixels go 0 to w-1)\n      const cx = (w - 1) / 2;\n      const cy = (h - 1) / 2;\n      const relX = Math.abs(x - cx);\n      const relY = Math.abs(y - cy);\n\n      const innerW = w / 2 - radius;\n      const innerH = h / 2 - radius;\n\n      // Calculate distance to boundary and direction to boundary\n      let distToBoundary = 0;\n      let dirX = 0;\n      let dirY = 0;\n\n      // Find closest point on rounded rect boundary\n      let closestX = relX;\n      let closestY = relY;\n\n      if (relX <= innerW && relY <= innerH) {\n        // Inside flat center - closest point is on nearest edge\n        const toEdgeX = innerW + radius;\n        const toEdgeY = innerH + radius;\n        if (toEdgeX - relX < toEdgeY - relY) {\n          closestX = innerW + radius;\n          closestY = relY;\n        } else {\n          closestX = relX;\n          closestY = innerH + radius;\n        }\n        distToBoundary = Math.min(toEdgeX - relX, toEdgeY - relY);\n      } else if (relX > innerW && relY <= innerH) {\n        // Edge region (right/left)\n        closestX = innerW + radius;\n        closestY = relY;\n        distToBoundary = radius - (relX - innerW);\n      } else if (relY > innerH && relX <= innerW) {\n        // Edge region (top/bottom)\n        closestX = relX;\n        closestY = innerH + radius;\n        distToBoundary = radius - (relY - innerH);\n      } else {\n        // Corner region\n        const dx = relX - innerW;\n        const dy = relY - innerH;\n        const cornerDist = Math.sqrt(dx * dx + dy * dy);\n        distToBoundary = radius - cornerDist;\n        if (cornerDist > 0) {\n          closestX = innerW + (dx / cornerDist) * radius;\n          closestY = innerH + (dy / cornerDist) * radius;\n        }\n      }\n\n      // Hard cutoff for pixels outside the shape\n      if (distToBoundary < 0) {\n        alpha = 0;\n      }\n\n      // Direction points from pixel toward closest boundary point\n      const toDirX = closestX - relX;\n      const toDirY = closestY - relY;\n      const dirLen = Math.sqrt(toDirX * toDirX + toDirY * toDirY);\n      if (dirLen > 0.001) {\n        dirX = (x > cx ? 1 : -1) * (toDirX / dirLen);\n        dirY = (y > cy ? 1 : -1) * (toDirY / dirLen);\n      }\n\n      // Apply bevel based on distance to boundary\n      if (bevel > 0 && distToBoundary < bevel && distToBoundary >= 0) {\n        let t = 1 - distToBoundary / bevel;\n        if (flipY) t = 1 - t;\n        const { derivative } = getHeightAndDerivative(t, shape, bezierCurve);\n        const sign = flipY ? -1 : 1;\n        nx = dirX * derivative * 0.5 * sign;\n        ny = dirY * derivative * 0.5 * sign;\n        if (flipX) {\n          nx = -nx;\n          ny = -ny;\n        }\n      }\n\n      const len = Math.sqrt(nx * nx + ny * ny + nz * nz);\n      nx /= len;\n      ny /= len;\n      nz /= len;\n\n      const index = (y * w + x) * 4;\n      data[index] = ((nx * 0.5 + 0.5) * 255) | 0;\n      data[index + 1] = ((ny * 0.5 + 0.5) * 255) | 0;\n      data[index + 2] = ((nz * 0.5 + 0.5) * 255) | 0;\n      data[index + 3] = alpha;\n    }\n  }\n  return Texture.from({\n    resource: data,\n    width: w,\n    height: h,\n  });\n}\n"],"names":["CapabilityProbe","gl","isWebGL2","extensions","tier","names","map","name","ext","param","DEFAULT_QUALITY","DEGRADATION_STEPS","q","AdaptiveQualityController","targetFrameMs","sample","overrides","avgCpu","sum","s","avgGpu","step","SceneRTManager","renderer","useDepth","Rectangle","width","height","scale","targetResolution","RenderTexture","_a","_c","_b","EventBus","event","listener","listeners","payload","key","make","material","GlassPresets","ior","clamped","PANEL_COUNTER","QUAD_GEOMETRY","MeshGeometry","BASIC_VERT","BASIC_FRAG","GlassPanel","Mesh","props","state","State","Shader","partial","textures","hexToVec3","hex","CompatibilityFilter","Filter","fragment","GlProgram","Texture","WebGL1Pipeline","Sprite","context","panels","quality","drawOpaqueScene","targets","orderedPanels","a","b","panel","sceneTexture","resources","uniforms","fullscreenVertex","panelVertex","refractionFragment","revealageFragment","compositeFragment","WebGL2Pipeline","refractUniforms","UniformGroup","revealUniforms","Container","target","r","g","dummy","sceneTarget","normal","screenWidth","screenHeight","res","tint","lightDir","prevShader","revealResources","_d","GlassSystem","_options","capability","draw","GlassPanelImpl","idx","start","duration","decision","options","message","GlassHUD","Graphics","Text","visible","metrics","fps","lastDecision","lines","GlassOverlay","e","element","composite","params","curve","zMin","zMax","edgeStretch","rect","x","y","dist","z","selector","entries","entry","item","lastRect","cssVisible","el","mutations","mutation","node","child","newRadius","config","dataIor","dataRoughness","isCircle","radius","cssRadius","bevel","shape","flipX","flipY","bezierCurve","circleSize","mapWidth","mapHeight","normalMap","createRoundedRectNormalMap","poll","delayFactor","smoothFactor","transform","size","t","style","topLeft","topRight","bottomRight","bottomLeft","parseValue","value","dimension","getFirstValue","avgDimension","heightCircle","heightCircleDerivative","h","heightSquircle","inner","heightSquircleDerivative","smootherstep","smootherstepDerivative","cubicBezier","p0","p1","p2","p3","mt","cubicBezierDerivative","getBezierHeightAndDerivative","derivative","getHeightAndDerivative","d","convexH","convexD","concaveH","concaveD","blend","blendD","w","data","nx","ny","nz","alpha","cx","cy","relX","relY","innerW","innerH","distToBoundary","dirX","dirY","closestX","closestY","toEdgeX","toEdgeY","dx","dy","cornerDist","toDirX","toDirY","dirLen","sign","len","index"],"mappings":"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"}