{"version":3,"file":"pixi-adaptive-glass.es.js","sources":["../src/core/CapabilityProbe.ts","../src/core/AdaptiveQualityController.ts","../src/core/SceneRTManager.ts","../src/core/EventBus.ts","../src/materials/GlassPresets.ts","../src/panels/GlassPanel.ts","../src/utils/index.ts","../src/pipelines/WebGL1Pipeline.ts","../src/shaders/webgl2.ts","../src/pipelines/WebGL2Pipeline.ts","../src/system/GlassSystem.ts","../src/hud/GlassHUD.ts","../src/GlassOverlay.ts"],"sourcesContent":["import type { CapabilityResult, CapabilityTier } from './types.js';\n\nexport class CapabilityProbe {\n  private cached?: CapabilityResult;\n\n  constructor(private readonly gl: WebGLRenderingContext | WebGL2RenderingContext) {}\n\n  run(): CapabilityResult {\n    if (this.cached) {\n      return this.cached;\n    }\n\n    const isWebGL2 = this.isWebGL2Context(this.gl);\n    const extensions = this.queryExtensions([\n      'EXT_color_buffer_float',\n      'OES_texture_float_linear',\n      'OES_standard_derivatives',\n      'EXT_disjoint_timer_query_webgl2',\n      'EXT_disjoint_timer_query',\n    ]);\n\n    const tier: CapabilityTier = isWebGL2 && this.getMaxDrawBuffers() > 1 ? 'webgl2' : 'webgl1';\n\n    this.cached = {\n      tier,\n      maxDrawBuffers: this.getMaxDrawBuffers(),\n      extensions,\n    };\n    return this.cached;\n  }\n\n  private queryExtensions(names: string[]): Record<string, boolean> {\n    return names.reduce<Record<string, boolean>>((map, name) => {\n      map[name] = Boolean(this.gl.getExtension(name));\n      return map;\n    }, {});\n  }\n\n  private getMaxDrawBuffers(): number {\n    const ext = this.gl.getExtension('WEBGL_draw_buffers');\n    const param = this.isWebGL2Context(this.gl)\n      ? this.gl.MAX_DRAW_BUFFERS\n      : ext\n        ? ext.MAX_DRAW_BUFFERS_WEBGL\n        : 0;\n    if (!param) return 1;\n    const caps = this.gl.getParameter(param) as number | null;\n    return caps ?? 1;\n  }\n\n  private isWebGL2Context(\n    gl: WebGLRenderingContext | WebGL2RenderingContext,\n  ): gl is WebGL2RenderingContext {\n    return typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\n  }\n}\n","import type { AdaptiveAction, AdaptiveDecision, RenderQualityOptions, TelemetrySample } from './types.js';\n\nconst DEFAULT_QUALITY: RenderQualityOptions = {\n  renderScale: 1,\n  enableDispersion: true,\n  enableCaustics: true,\n  enableContactShadows: true,\n  maxBlurTaps: 9,\n  edgeSupersampling: 1,\n};\n\ntype DegradationStep = {\n  check: (q: RenderQualityOptions) => boolean;\n  apply: (q: RenderQualityOptions) => void;\n  action: AdaptiveAction;\n  reason: string;\n};\n\nconst DEGRADATION_STEPS: DegradationStep[] = [\n  { check: q => q.renderScale > 0.85, apply: q => { q.renderScale = 0.85; }, action: 'scale-rt-0-85', reason: 'Frame budget exceeded' },\n  { check: q => q.renderScale > 0.7, apply: q => { q.renderScale = 0.7; }, action: 'scale-rt-0-7', reason: 'Severe perf drop' },\n  { check: q => q.maxBlurTaps > 5, apply: q => { q.maxBlurTaps = 5; }, action: 'reduce-blur', reason: 'Sustained frame drops' },\n  { check: q => q.enableDispersion, apply: q => { q.enableDispersion = false; }, action: 'disable-dispersion', reason: 'Dispersion too expensive' },\n  { check: q => q.enableCaustics || q.enableContactShadows, apply: q => { q.enableCaustics = false; q.enableContactShadows = false; }, action: 'disable-caustics', reason: 'Optional overlays disabled' },\n];\n\nexport class AdaptiveQualityController {\n  private current: RenderQualityOptions = { ...DEFAULT_QUALITY };\n  private readonly telemetry: TelemetrySample[] = [];\n  private overrides: Partial<RenderQualityOptions> = {};\n\n  constructor(private readonly targetFrameMs = 100) {}\n\n  getQuality(): RenderQualityOptions {\n    return { ...this.current };\n  }\n\n  record(sample: TelemetrySample): void {\n    this.telemetry.push(sample);\n    if (this.telemetry.length > 120) {\n      this.telemetry.shift();\n    }\n  }\n\n  setOverrides(overrides: Partial<RenderQualityOptions>): void {\n    this.overrides = { ...this.overrides, ...overrides };\n    this.current = { ...this.current, ...this.overrides };\n  }\n\n  getTelemetry(): TelemetrySample[] {\n    return [...this.telemetry];\n  }\n\n  evaluate(): AdaptiveDecision | undefined {\n    if (this.telemetry.length < 30) return undefined;\n    const avgCpu = this.telemetry.reduce((sum, s) => sum + s.cpuMs, 0) / this.telemetry.length;\n    const avgGpu = this.telemetry.reduce((sum, s) => sum + (s.gpuMs ?? s.cpuMs), 0) / this.telemetry.length;\n    if (Math.max(avgCpu, avgGpu) <= this.targetFrameMs) return undefined;\n\n    for (const step of DEGRADATION_STEPS) {\n      if (step.check(this.current)) {\n        step.apply(this.current);\n        return { action: step.action, reason: step.reason };\n      }\n    }\n    return undefined;\n  }\n}\n","import { Rectangle, RenderTexture } from 'pixi.js';\nimport type { Renderer, WebGLRenderer } from 'pixi.js';\n\ninterface RtHandles {\n  sceneColor: RenderTexture;\n  sceneDepth?: RenderTexture;\n}\n\nexport class SceneRTManager {\n  private handles?: RtHandles;\n  private scale = 1;\n  private readonly clearRect = new Rectangle();\n\n  constructor(\n    private readonly renderer: Renderer,\n    private readonly useDepth: boolean,\n  ) {}\n\n  ensure(width: number, height: number, scale: number): RtHandles {\n    const targetResolution = this.renderer.resolution * scale;\n    if (\n      !this.handles ||\n      this.handles.sceneColor.width !== width ||\n      this.handles.sceneColor.height !== height ||\n      this.handles.sceneColor.source.resolution !== targetResolution\n    ) {\n      this.dispose();\n      this.handles = {\n        sceneColor: RenderTexture.create({\n          width,\n          height,\n          resolution: targetResolution,\n          scaleMode: 'linear',\n        }),\n        sceneDepth: this.useDepth\n          ? RenderTexture.create({\n              width,\n              height,\n              resolution: targetResolution,\n              scaleMode: 'nearest',\n            })\n          : undefined,\n      };\n      this.scale = scale;\n    }\n    return this.handles;\n  }\n\n  clearTargets(): void {\n    if (!this.handles) return;\n    this.clearRect.width = this.handles.sceneColor.width;\n    this.clearRect.height = this.handles.sceneColor.height;\n    \n    const renderer = this.renderer as WebGLRenderer;\n    renderer.renderTarget.bind(this.handles.sceneColor);\n    const gl = renderer.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    if (this.handles.sceneDepth) {\n      renderer.renderTarget.bind(this.handles.sceneDepth);\n      gl.clearColor(1, 0, 0, 1); \n      gl.clearDepth(1.0);\n      gl.clear(gl.DEPTH_BUFFER_BIT);\n    }\n  }\n\n  dispose(): void {\n    this.handles?.sceneColor.destroy(true);\n    this.handles?.sceneDepth?.destroy(true);\n    this.handles = undefined;\n  }\n}\n","type Listener<T> = (payload: T) => void;\n\ntype EventMap = Record<string, unknown>;\n\nexport class EventBus<Events extends EventMap> {\n  private listeners: { [K in keyof Events]?: Set<Listener<Events[K]>> } = {};\n\n  on<K extends keyof Events>(event: K, listener: Listener<Events[K]>): void {\n    let listeners = this.listeners[event];\n    if (!listeners) {\n      listeners = new Set();\n      this.listeners[event] = listeners;\n    }\n    listeners.add(listener);\n  }\n\n  off<K extends keyof Events>(event: K, listener: Listener<Events[K]>): void {\n    this.listeners[event]?.delete(listener);\n  }\n\n  emit<K extends keyof Events>(event: K, payload: Events[K]): void {\n    const listeners = this.listeners[event];\n    if (!listeners) return;\n    for (const listener of listeners) {\n      listener(payload);\n    }\n  }\n\n  removeAll(): void {\n    for (const key of Object.keys(this.listeners) as Array<keyof Events>) {\n      this.listeners[key]?.clear();\n    }\n  }\n}\n","import type { GlassMaterial } from '../core/types.js';\n\nconst make = (material: GlassMaterial): GlassMaterial => material;\n\nexport const GlassPresets = {\n  water(): GlassMaterial {\n    return make({\n      ior: 1.333,\n      thickness: 0.6,\n      roughness: 0.1,\n      dispersion: 0.02,\n      opacity: 1.0,\n      tint: 0x9fd9ff,\n    });\n  },\n  crownGlass(): GlassMaterial {\n    return make({\n      ior: 1.52,\n      thickness: 0.8,\n      roughness: 0.05,\n      dispersion: 0.04,\n      opacity: 1.0,\n      tint: 0xffffff,\n    });\n  },\n  acrylic(): GlassMaterial {\n    return make({\n      ior: 1.49,\n      thickness: 0.7,\n      roughness: 0.12,\n      dispersion: 0.01,\n      opacity: 1.0,\n      tint: 0xf7f7f7,\n    });\n  },\n  clear(): GlassMaterial {\n    return make({\n      ior: 1.52,\n      thickness: 0.8,\n      roughness: 0.05,\n      dispersion: 0.04,\n      opacity: 1.0,\n      tint: 0xffffff,\n    });\n  },\n  fromIOR(ior: number): GlassMaterial {\n    const clamped = Math.min(Math.max(ior, 1.0), 2.0);\n    return make({\n      ior: clamped,\n      thickness: 0.75,\n      roughness: 0.08,\n      dispersion: (clamped - 1) * 0.05,\n      opacity: 1.0,\n      tint: 0xffffff,\n    });\n  },\n};\n","  import { Mesh, MeshGeometry, Shader, State } from 'pixi.js';\nimport type { Texture } from 'pixi.js';\nimport type { CapabilityTier, GlassMaterial, GlassPanelProps } from '../core/types.js';\n\nlet PANEL_COUNTER = 0;\n\n// Use MeshGeometry which auto-maps to aPosition and aUV attributes\n// Centered geometry (-0.5 to 0.5) - position is center, scale is size\nconst QUAD_GEOMETRY = new MeshGeometry({\n  positions: new Float32Array([-0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5]),\n  uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n  indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\nconst BASIC_VERT = `\nprecision mediump float;\nattribute vec2 aPosition;\nattribute vec2 aUV;\nvarying vec2 vUv;\nuniform mat3 translationMatrix;\nuniform mat3 projectionMatrix;\nuniform mat3 uTextureMatrix;\nvoid main(void){\n  vUv = aUV;\n  gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aPosition, 1.0)).xy, 0.0, 1.0);\n}\n`;\n\nconst BASIC_FRAG = `\nprecision mediump float;\nvarying vec2 vUv;\nvoid main(void){\n  gl_FragColor = vec4(vUv, 0.0, 1.0);\n}\n`;\n\nexport class GlassPanel extends Mesh {\n  id: string;\n  glassMaterial: GlassMaterial;\n  normalMap?: Texture;\n  dudvMap?: Texture;\n  causticsAtlas?: Texture;\n  sdfShadow?: Texture;\n  private tier: CapabilityTier = 'webgl1';\n\n  constructor(props: GlassPanelProps) {\n    const state = State.for2d();\n    state.culling = false; // Disable culling to avoid winding order issues\n\n    super({\n      geometry: props.geometry ?? QUAD_GEOMETRY,\n      shader: Shader.from({\n        gl: {\n          vertex: BASIC_VERT,\n          fragment: BASIC_FRAG,\n        },\n      }) as any,\n      state,\n    });\n    this.id = props.id ?? `glass-panel-${++PANEL_COUNTER}`;\n    this.glassMaterial = props.material;\n    this.normalMap = props.normalMap;\n    this.dudvMap = props.dudvMap;\n    this.causticsAtlas = props.causticsAtlas;\n    this.sdfShadow = props.sdfShadow;\n    if (props.filters) {\n      this.filters = props.filters;\n    }\n  }\n\n  setMaterial(partial: Partial<GlassMaterial>): void {\n    this.glassMaterial = { ...this.glassMaterial, ...partial };\n  }\n\n  setTextures(textures: Partial<Omit<GlassPanelProps, 'material' | 'geometry'>>): void {\n    if (textures.normalMap) this.normalMap = textures.normalMap;\n    if (textures.dudvMap) this.dudvMap = textures.dudvMap;\n    if (textures.causticsAtlas) this.causticsAtlas = textures.causticsAtlas;\n    if (textures.sdfShadow) this.sdfShadow = textures.sdfShadow;\n  }\n\n  setTier(tier: CapabilityTier): void {\n    this.tier = tier;\n  }\n\n  getTier(): CapabilityTier {\n    return this.tier;\n  }\n}\n","export function hexToVec3(hex: number): [number, number, number] {\n  return [\n    ((hex >> 16) & 0xff) / 255,\n    ((hex >> 8) & 0xff) / 255,\n    (hex & 0xff) / 255,\n  ];\n}\n","import { Filter, Sprite, Texture, GlProgram } from 'pixi.js';\nimport type { RenderTexture, Renderer } from 'pixi.js';\nimport { SceneRTManager } from '../core/SceneRTManager.js';\nimport type { RenderQualityOptions } from '../core/types.js';\nimport type { GlassPanel } from '../panels/GlassPanel.js';\nimport type { Pipeline, PipelineContext } from './BasePipeline.js';\nimport { hexToVec3 } from '../utils/index.js';\n\nclass CompatibilityFilter extends Filter {\n  constructor() {\n    const fragment = `\n      precision mediump float;\n      varying vec2 vTextureCoord;\n      uniform sampler2D uSceneColor;\n      uniform sampler2D uNormalMap;\n      uniform vec2 uInvResolution;\n      uniform float uDispersion;\n      uniform float uRoughness;\n      uniform float uDisplacementScale;\n      uniform vec3 uTint;\n      uniform float uOpacity;\n      uniform bool uEnableDispersion;\n      vec3 sampleScene(vec2 uv){\n        return texture2D(uSceneColor, clamp(uv, vec2(0.001), vec2(0.999))).rgb;\n      }\n      void main(){\n        vec3 normal = texture2D(uNormalMap, vTextureCoord).xyz * 2.0 - 1.0;\n        vec2 offset = normal.xy * uDisplacementScale;\n        vec2 baseUV = vTextureCoord + offset;\n        vec3 color = sampleScene(baseUV);\n        if(uEnableDispersion){\n          color.r = sampleScene(baseUV + offset * (1.0 + uDispersion)).r;\n          color.b = sampleScene(baseUV - offset * (1.0 + uDispersion)).b;\n        }\n        float radius = uRoughness * 4.0;\n        if(radius > 0.001){\n          vec3 blurAccum = vec3(0.0);\n          float taps = 0.0;\n          for(int i=0;i<4;i++){\n            float angle = 6.2831853 * float(i) / 4.0;\n            vec2 sampleOffset = vec2(cos(angle), sin(angle)) * radius * uInvResolution;\n            blurAccum += sampleScene(baseUV + sampleOffset);\n            taps += 1.0;\n          }\n          color = mix(color, blurAccum / max(taps, 1.0), 0.7);\n        }\n        gl_FragColor = vec4(color * uTint * uOpacity, uOpacity);\n      }\n    `;\n    super({\n      glProgram: new GlProgram({\n          vertex: `\n            attribute vec2 aVertexPosition;\n            attribute vec2 aTextureCoord;\n            uniform mat3 projectionMatrix;\n            varying vec2 vTextureCoord;\n            void main(void){\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n                vTextureCoord = aTextureCoord;\n            }\n          `,\n          fragment,\n      }),\n      resources: {\n        uSceneColor: Texture.WHITE.source,\n        uNormalMap: Texture.WHITE.source,\n        uniforms: {\n            uInvResolution: { value: [1, 1], type: 'vec2<f32>' },\n            uDispersion: { value: 0, type: 'f32' },\n            uRoughness: { value: 0, type: 'f32' },\n            uDisplacementScale: { value: 0.01, type: 'f32' },\n            uTint: { value: [1, 1, 1], type: 'vec3<f32>' },\n            uOpacity: { value: 1, type: 'f32' },\n            uEnableDispersion: { value: 0, type: 'f32' }, // boolean as float\n        }\n      },\n    });\n  }\n}\n\nexport class WebGL1Pipeline implements Pipeline {\n  readonly id = 'webgl1';\n  private readonly filter = new CompatibilityFilter();\n  private readonly rtManager: SceneRTManager;\n  private readonly blitSprite: Sprite;\n\n  constructor(private readonly renderer: Renderer) {\n    this.rtManager = new SceneRTManager(renderer, false);\n    this.blitSprite = new Sprite(Texture.WHITE);\n  }\n\n  setup(): void {}\n\n  render(context: PipelineContext): void {\n    const { renderer, panels, quality, drawOpaqueScene } = context;\n    const targets = this.rtManager.ensure(\n      renderer.screen.width,\n      renderer.screen.height,\n      quality.renderScale,\n    );\n    \n    drawOpaqueScene(targets.sceneColor);\n    \n    this.blitSprite.texture = targets.sceneColor;\n    this.blitSprite.width = renderer.screen.width;\n    this.blitSprite.height = renderer.screen.height;\n    \n    renderer.render({ container: this.blitSprite, clear: true });\n    \n    const orderedPanels = [...panels].sort((a, b) => (a.zIndex ?? 0) - (b.zIndex ?? 0));\n    for (const panel of orderedPanels) {\n      this.applyFilter(panel, targets.sceneColor, quality);\n      renderer.render({ container: panel });\n    }\n  }\n\n  dispose(): void {\n    this.rtManager.dispose();\n  }\n\n  private applyFilter(\n    panel: GlassPanel,\n    sceneTexture: RenderTexture,\n    quality: RenderQualityOptions,\n  ): void {\n    const needsFilter =\n      Boolean(panel.normalMap || panel.dudvMap) ||\n      panel.glassMaterial.dispersion > 0.001 ||\n      panel.glassMaterial.roughness > 0.001;\n    if (!needsFilter) {\n      panel.filters = null;\n      return;\n    }\n    const resources = this.filter.resources;\n    // Assign textures to resources\n    (resources as any).uSceneColor = sceneTexture.source;\n    (resources as any).uNormalMap = (panel.normalMap ?? panel.dudvMap ?? Texture.WHITE).source;\n    \n    const uniforms = (resources as any).uniforms;\n    uniforms.uInvResolution = [1 / sceneTexture.width, 1 / sceneTexture.height];\n    uniforms.uDispersion = panel.glassMaterial.dispersion;\n    uniforms.uRoughness = panel.glassMaterial.roughness;\n    uniforms.uDisplacementScale = panel.glassMaterial.thickness * 0.1;\n    uniforms.uTint = hexToVec3(panel.glassMaterial.tint ?? 0xffffff);\n    uniforms.uOpacity = panel.glassMaterial.opacity;\n    uniforms.uEnableDispersion = quality.enableDispersion && panel.glassMaterial.dispersion > 0.001 ? 1 : 0;\n    \n    panel.filters = [this.filter];\n  }\n}\n","export const fullscreenVertex = `\nprecision mediump float;\nattribute vec2 aPosition;\nattribute vec2 aUV;\nvarying vec2 vUv;\nvoid main(void){\n  vUv = aUV;\n  vec2 pos = aPosition * 2.0 - 1.0;\n  gl_Position = vec4(pos, 0.0, 1.0);\n}\n`;\n\nexport const panelVertex = `\nprecision mediump float;\nattribute vec2 aPosition;\nattribute vec2 aUV;\nvarying vec2 vUv;\nuniform vec2 uPosition;\nuniform vec2 uScale;\nuniform vec2 uResolution;\nvoid main(void){\n  vUv = aUV;\n  vec2 worldPos = aPosition * uScale + uPosition;\n  vec2 clipPos = (worldPos / uResolution) * 2.0 - 1.0;\n  gl_Position = vec4(clipPos, 0.0, 1.0);\n}\n`;\n\nexport const refractionFragment = `\nprecision highp float;\nvarying vec2 vUv;\nuniform sampler2D uSceneColor;\nuniform sampler2D uNormalMap;\nuniform sampler2D uCausticsMap;\nuniform vec2 uInvResolution;\nuniform float uIOR;\nuniform float uThickness;\nuniform float uDispersion;\nuniform float uRoughness;\nuniform float uOpacity;\nuniform bool uEnableDispersion;\nuniform bool uEnableCaustics;\nuniform vec3 uTint;\nuniform float uSpecular;\nuniform float uShininess;\nuniform float uShadow;\nuniform vec3 uLightDir;\nuniform float uBlurSamples;\nuniform float uBlurSpread;\nuniform float uBlurAngle;\nuniform float uBlurAnisotropy;\nuniform float uBlurGamma;\nuniform float uAberrationR;\nuniform float uAberrationB;\nuniform float uAO;\nuniform float uAORadius;\nuniform float uNoiseScale;\nuniform float uNoiseIntensity;\nuniform float uNoiseRotation;\nuniform float uNoiseThreshold;\nuniform float uEdgeSupersampling;\nuniform float uEdgeSmoothWidth;\nuniform float uEdgeContrast;\nuniform float uEdgeAlphaFalloff;\nuniform float uEdgeMaskCutoff;\nuniform bool uEnableEdgeSmoothing;\nuniform bool uEnableContrastReduction;\nuniform bool uEnableAlphaFalloff;\nuniform bool uEnableTintOpacity;\nuniform float uEdgeBlur;\nuniform float uGlassSupersampling;\nuniform vec2 uPanelSize;\n\n// Simple value noise\nfloat hash(vec2 p) {\n  return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat valueNoise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  f = f * f * (3.0 - 2.0 * f); // smoothstep\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n  return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nvec2 rotateUV(vec2 uv, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\n}\n\nvec3 sampleScene(vec2 uv){\n  return texture2D(uSceneColor, clamp(uv, vec2(0.001), vec2(0.999))).rgb;\n}\n\nvec3 sampleDispersion(vec2 baseUV, vec2 offset){\n  if(!uEnableDispersion){\n    return sampleScene(baseUV + offset);\n  }\n  vec3 result;\n  result.r = sampleScene(baseUV + offset * (1.0 + uDispersion * uAberrationR)).r;\n  result.g = sampleScene(baseUV + offset).g;\n  result.b = sampleScene(baseUV + offset * (1.0 - uDispersion * uAberrationB)).b;\n  return result;\n}\n\nvec3 sampleFrostedColor(vec2 baseUV, vec2 offset){\n  // Scale blur by panel size relative to reference (200px)\n  float referenceSize = 200.0;\n  float avgPanelSize = (uPanelSize.x + uPanelSize.y) * 0.5;\n  float sizeScale = avgPanelSize / referenceSize;\n\n  float radius = uRoughness * uBlurSpread * sizeScale;\n  vec3 accum = vec3(0.0);\n  float totalWeight = 0.0;\n  int samples = int(uBlurSamples);\n\n  // Golden angle spiral for better sample distribution\n  float goldenAngle = 2.39996323;\n\n  // Directional blur rotation matrix\n  float ca = cos(uBlurAngle);\n  float sa = sin(uBlurAngle);\n\n  for(int i=0;i<32;i++){\n    if(i >= samples) break;\n\n    // Normalized distance from center (0 to 1)\n    float t = float(i) / float(samples - 1);\n\n    // Apply gamma curve to sample distribution\n    float curvedT = pow(t, uBlurGamma);\n    float r = curvedT * radius;\n\n    float angle = float(i) * goldenAngle;\n    vec2 dir = vec2(cos(angle), sin(angle));\n\n    // Apply anisotropy (stretch in one direction)\n    if(uBlurAnisotropy > 0.001){\n      // Rotate to blur angle, apply stretch, rotate back\n      vec2 rotated = vec2(ca * dir.x + sa * dir.y, -sa * dir.x + ca * dir.y);\n      rotated.y *= (1.0 - uBlurAnisotropy);\n      dir = vec2(ca * rotated.x - sa * rotated.y, sa * rotated.x + ca * rotated.y);\n    }\n\n    vec2 sampleOffset = dir * r * uInvResolution;\n\n    // Weight samples by distance (softer falloff)\n    float w = 1.0 - curvedT * 0.5;\n    accum += sampleDispersion(baseUV, offset + sampleOffset) * w;\n    totalWeight += w;\n  }\n  return accum / max(totalWeight, 1.0);\n}\n\nvoid main(){\n  vec2 screenUV = gl_FragCoord.xy * uInvResolution;\n\n  vec4 normalSample = texture2D(uNormalMap, vUv);\n  float mask = normalSample.a;\n\n  // Blur the mask at edges for softer borders\n  if (uEdgeBlur > 0.0 && mask < 0.9) {\n    float blurredMask = 0.0;\n    float blurWeight = 0.0;\n    vec2 texelSize = uInvResolution * uEdgeBlur;\n    for (int x = -2; x <= 2; x++) {\n      for (int y = -2; y <= 2; y++) {\n        vec2 offset = vec2(float(x), float(y)) * texelSize;\n        float sampleMask = texture2D(uNormalMap, vUv + offset).a;\n        float weight = 1.0 - length(vec2(float(x), float(y))) * 0.2;\n        blurredMask += sampleMask * weight;\n        blurWeight += weight;\n      }\n    }\n    mask = blurredMask / blurWeight;\n  }\n\n  // Discard pixels outside the masked area (border radius)\n  if (mask < uEdgeMaskCutoff) {\n    discard;\n  }\n\n  // Simple refraction offset based on normal map\n  vec2 normal = normalSample.xy * 2.0 - 1.0;\n\n  // Edge smoothing with configurable width\n  float edgeSmoothness = 1.0;\n  if (uEnableEdgeSmoothing) {\n    float smoothWidth = uEdgeSmoothWidth * (0.5 + 0.5 * uEdgeSupersampling);\n    edgeSmoothness = smoothstep(0.0, smoothWidth, mask);\n  }\n\n  float contrastReduction = 1.0;\n  if (uEnableContrastReduction) {\n    contrastReduction = mix(uEdgeContrast, 1.0, edgeSmoothness);\n  }\n\n  // Apply noise distortion to normal (anchored to container via vUv)\n  if (uNoiseIntensity > 0.001) {\n    vec2 noiseUV = rotateUV(vUv * uNoiseScale, uNoiseRotation * 3.14159 / 180.0);\n    float n = valueNoise(noiseUV);\n    float n2 = valueNoise(noiseUV + vec2(100.0, 100.0));\n    // Apply threshold\n    n = smoothstep(uNoiseThreshold, 1.0, n) * (1.0 - uNoiseThreshold) + n * uNoiseThreshold;\n    n2 = smoothstep(uNoiseThreshold, 1.0, n2) * (1.0 - uNoiseThreshold) + n2 * uNoiseThreshold;\n    vec2 noiseNormal = (vec2(n, n2) - 0.5) * 2.0 * uNoiseIntensity;\n    normal += noiseNormal;\n  }\n\n  vec2 offset = normal * uThickness * 0.1 * (uIOR - 1.0);\n\n  vec3 refracted;\n  if (uGlassSupersampling > 1.0) {\n    // Supersample the entire glass panel\n    vec3 ssColor = vec3(0.0);\n    int samples = int(uGlassSupersampling * uGlassSupersampling);\n    float ssStep = 1.0 / uGlassSupersampling;\n    int sampleIdx = 0;\n    for (int x = 0; x < 4; x++) {\n      if (x >= int(uGlassSupersampling)) break;\n      for (int y = 0; y < 4; y++) {\n        if (y >= int(uGlassSupersampling)) break;\n        vec2 ssOffset = (vec2(float(x), float(y)) * ssStep - 0.5 + ssStep * 0.5) * uInvResolution;\n        ssColor += sampleFrostedColor(screenUV + ssOffset, offset);\n        sampleIdx++;\n      }\n    }\n    refracted = ssColor / float(sampleIdx);\n  } else {\n    refracted = sampleFrostedColor(screenUV, offset);\n  }\n  // Apply tint as color mix instead of multiply to preserve visibility\n  float tintStrength = 0.3;\n  refracted = mix(refracted, refracted * uTint + uTint * 0.1, tintStrength);\n\n  // Calculate lighting from normal map (now includes noise)\n  vec3 N = normalize(vec3(normal, normalSample.b * 2.0 - 1.0));\n  float NdotL = max(0.0, dot(N, normalize(uLightDir)));\n\n  // Specular highlight (Blinn-Phong)\n  vec3 viewDir = vec3(0.0, 0.0, 1.0);\n  vec3 halfDir = normalize(normalize(uLightDir) + viewDir);\n  float spec = pow(max(0.0, dot(N, halfDir)), uShininess) * uSpecular;\n\n  // Shadow from normal facing away from light\n  float shadowFactor = 1.0 - uShadow * (1.0 - NdotL);\n\n  // Ambient occlusion based on edge distance (darker at edges/outside)\n  float edgeDist = length(normal);\n  float aoFactor = 1.0 - uAO * smoothstep(0.0, uAORadius, edgeDist);\n\n  // Apply lighting\n  refracted = refracted * shadowFactor * aoFactor + vec3(spec);\n\n  // Apply contrast reduction at edges and tint intensity to overall opacity\n  if (uEnableContrastReduction) {\n    refracted *= contrastReduction;\n  }\n\n  // Use normal map alpha as shape mask\n  float shapeMask = normalSample.a;\n  if (shapeMask < 0.5) discard;\n\n  gl_FragColor = vec4(refracted, 1.0);\n}\n`;\n\nexport const revealageFragment = `\nprecision mediump float;\nvarying vec2 vUv;\nuniform sampler2D uNormalMap;\nuniform float uOpacity;\nvoid main(){\n  vec4 normalSample = texture2D(uNormalMap, vUv);\n  float mask = normalSample.a;\n\n  // Discard pixels outside the masked area (border radius)\n  if (mask < 0.01) {\n    discard;\n  }\n\n  float alpha = uOpacity * mask;\n  float revealage = exp(-3.0 * alpha);\n  gl_FragColor = vec4(revealage);\n}\n`;\n\nexport const compositeFragment = `\nprecision mediump float;\nvarying vec2 vUv;\nuniform sampler2D uSceneColor;\nuniform sampler2D uAccum;\nuniform sampler2D uReveal;\nvoid main(){\n  vec4 accum = texture2D(uAccum, vUv);\n  vec3 scene = texture2D(uSceneColor, vUv).rgb;\n\n  // Simple alpha blend: accum.a is opacity\n  vec3 result = mix(scene, accum.rgb, accum.a);\n  gl_FragColor = vec4(result, 1.0);\n}\n`;\n","import {\n  Container,\n  Mesh,\n  MeshGeometry,\n  RenderTexture,\n  Shader,\n  Sprite,\n  State,\n  Texture,\n  UniformGroup,\n} from 'pixi.js';\nimport type { Renderer } from 'pixi.js';\nimport { SceneRTManager } from '../core/SceneRTManager.js';\nimport type { GlassPanel } from '../panels/GlassPanel.js';\nimport {\n  compositeFragment,\n  fullscreenVertex,\n  panelVertex,\n  refractionFragment,\n  revealageFragment,\n} from '../shaders/webgl2.js';\nimport type { Pipeline, PipelineContext } from './BasePipeline.js';\nimport type { RenderQualityOptions } from '../core/types.js';\nimport { hexToVec3 } from '../utils/index.js';\n\n// Fullscreen quad with 0..1 positions for clip space mapping\nconst QUAD_GEOMETRY = new MeshGeometry({\n  positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n  uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n  indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\nexport class WebGL2Pipeline implements Pipeline {\n  readonly id = 'webgl2';\n  private readonly rtManager: SceneRTManager;\n  private readonly refractShader: Shader;\n  private readonly revealageShader: Shader;\n  private readonly compositeShader: Shader;\n  private readonly fullScreenQuad: Mesh<MeshGeometry, Shader>;\n  private readonly shadowSprite: Sprite;\n  private readonly panelParent: Container;\n  private compositeRT?: RenderTexture;\n  private readonly compositeSprite: Sprite;\n  private accumRT?: RenderTexture;\n  private revealRT?: RenderTexture;\n\n  constructor(\n    private readonly renderer: Renderer,\n    useDepth: boolean,\n  ) {\n    this.rtManager = new SceneRTManager(renderer, useDepth);\n    const refractUniforms = new UniformGroup({\n      uPosition: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n      uScale: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uResolution: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uInvResolution: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uIOR: { value: 1, type: 'f32' },\n      uThickness: { value: 1, type: 'f32' },\n      uDispersion: { value: 0, type: 'f32' },\n      uRoughness: { value: 0, type: 'f32' },\n      uOpacity: { value: 1, type: 'f32' },\n      uEnableDispersion: { value: 0, type: 'f32' },\n      uEnableCaustics: { value: 0, type: 'f32' },\n      uTint: { value: new Float32Array([1, 1, 1]), type: 'vec3<f32>' },\n      uSpecular: { value: 0, type: 'f32' },\n      uShininess: { value: 32, type: 'f32' },\n      uShadow: { value: 0, type: 'f32' },\n      uLightDir: { value: new Float32Array([0.5, 0.5, 1]), type: 'vec3<f32>' },\n      uBlurSamples: { value: 8, type: 'f32' },\n      uBlurSpread: { value: 4, type: 'f32' },\n      uBlurAngle: { value: 0, type: 'f32' },\n      uBlurAnisotropy: { value: 0, type: 'f32' },\n      uBlurGamma: { value: 1, type: 'f32' },\n      uAberrationR: { value: 1, type: 'f32' },\n      uAberrationB: { value: 1, type: 'f32' },\n      uAO: { value: 0, type: 'f32' },\n      uAORadius: { value: 0.5, type: 'f32' },\n      uNoiseScale: { value: 20, type: 'f32' },\n      uNoiseIntensity: { value: 0, type: 'f32' },\n      uNoiseRotation: { value: 0, type: 'f32' },\n      uNoiseThreshold: { value: 0, type: 'f32' },\n      uEdgeSupersampling: { value: 1, type: 'f32' },\n      uEdgeSmoothWidth: { value: 0.15, type: 'f32' },\n      uEdgeContrast: { value: 0.7, type: 'f32' },\n      uEdgeAlphaFalloff: { value: 1, type: 'f32' },\n      uEdgeMaskCutoff: { value: 0.001, type: 'f32' },\n      uEnableEdgeSmoothing: { value: 1, type: 'f32' },\n      uEnableContrastReduction: { value: 1, type: 'f32' },\n      uEnableAlphaFalloff: { value: 1, type: 'f32' },\n      uEnableTintOpacity: { value: 1, type: 'f32' },\n      uEdgeBlur: { value: 0, type: 'f32' },\n      uGlassSupersampling: { value: 1, type: 'f32' },\n      uPanelSize: { value: new Float32Array([200, 200]), type: 'vec2<f32>' },\n    });\n    this.refractShader = Shader.from({\n      gl: { vertex: panelVertex, fragment: refractionFragment },\n      resources: {\n        uSceneColor: Texture.WHITE.source,\n        uNormalMap: Texture.WHITE.source,\n        uCausticsMap: Texture.WHITE.source,\n        panelUniforms: refractUniforms,\n      },\n    });\n    const revealUniforms = new UniformGroup({\n      uPosition: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n      uScale: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uResolution: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uOpacity: { value: 1, type: 'f32' },\n    });\n    this.revealageShader = Shader.from({\n      gl: { vertex: panelVertex, fragment: revealageFragment },\n      resources: {\n        uNormalMap: Texture.WHITE.source,\n        panelUniforms: revealUniforms,\n      },\n    });\n    this.compositeShader = Shader.from({\n      gl: { vertex: fullscreenVertex, fragment: compositeFragment },\n      resources: {\n        uSceneColor: Texture.WHITE.source,\n        uAccum: Texture.WHITE.source,\n        uReveal: Texture.WHITE.source,\n      },\n    });\n    this.fullScreenQuad = new Mesh({\n      geometry: QUAD_GEOMETRY,\n      shader: this.compositeShader,\n    });\n    this.fullScreenQuad.state = State.for2d();\n    this.fullScreenQuad.state.culling = false; // Disable culling\n    this.shadowSprite = new Sprite(Texture.WHITE);\n    this.panelParent = new Container();\n    this.panelParent.alpha = 1;\n    this.compositeSprite = new Sprite(Texture.EMPTY);\n    // Ensure composite sprite is visible and on top\n    this.compositeSprite.position.set(0, 0);\n    this.compositeSprite.visible = true;\n    this.compositeSprite.alpha = 1;\n    this.compositeSprite.zIndex = 9999; // Force on top\n  }\n\n  setup(): void {}\n\n  render(context: PipelineContext): void {\n    const { renderer, panels, quality, drawOpaqueScene } = context;\n    const width = renderer.screen.width;\n    const height = renderer.screen.height;\n    const targets = this.rtManager.ensure(width, height, quality.renderScale);\n    this.ensureAccumTargets(width, height);\n    this.ensureCompositeTarget(width, height);\n\n    drawOpaqueScene(targets.sceneColor);\n\n    this.clearTarget(this.accumRT, 0, 0, 0, 0);\n    this.clearTarget(this.revealRT, 1, 1, 1, 1);\n\n    for (const panel of panels) {\n      this.renderPanel(panel, quality, targets.sceneColor);\n    }\n\n    this.fullScreenQuad.shader = this.compositeShader;\n    (this.compositeShader as any).resources.uSceneColor = targets.sceneColor.source;\n    (this.compositeShader as any).resources.uAccum = this.accumRT?.source;\n    (this.compositeShader as any).resources.uReveal = this.revealRT?.source;\n\n    this.fullScreenQuad.width = renderer.screen.width;\n    this.fullScreenQuad.height = renderer.screen.height;\n\n    this.fullScreenQuad.updateLocalTransform();\n    this.fullScreenQuad.worldTransform.copyFrom(this.fullScreenQuad.localTransform);\n\n    // Render composite quad to texture\n    renderer.render({ container: this.fullScreenQuad, target: this.compositeRT, clear: true });\n\n    if (this.compositeRT) {\n      this.compositeSprite.texture = this.compositeRT;\n      this.compositeSprite.width = width;\n      this.compositeSprite.height = height;\n      this.compositeSprite.visible = true;\n    }\n\n    this.renderContactShadows(panels, quality);\n  }\n\n  dispose(): void {\n    this.rtManager.dispose();\n    this.accumRT?.destroy(true);\n    this.revealRT?.destroy(true);\n    this.compositeRT?.destroy(true);\n  }\n\n  private ensureAccumTargets(width: number, height: number): void {\n    const targetResolution = this.renderer.resolution;\n    if (!this.accumRT || this.accumRT.width !== width || this.accumRT.height !== height || this.accumRT.source.resolution !== targetResolution) {\n      this.accumRT?.destroy(true);\n      this.accumRT = RenderTexture.create({\n        width,\n        height,\n        resolution: targetResolution,\n      });\n    }\n    if (!this.revealRT || this.revealRT.width !== width || this.revealRT.height !== height || this.revealRT.source.resolution !== targetResolution) {\n      this.revealRT?.destroy(true);\n      this.revealRT = RenderTexture.create({\n        width,\n        height,\n        resolution: targetResolution,\n      });\n    }\n  }\n\n  private clearTarget(\n    target: RenderTexture | undefined,\n    r: number,\n    g: number,\n    b: number,\n    a: number,\n  ): void {\n    if (!target) return;\n    const dummy = new Container();\n    this.renderer.render({ container: dummy, target, clear: true, clearColor: [r, g, b, a] });\n  }\n\n  private renderPanel(\n    panel: GlassPanel,\n    quality: RenderQualityOptions,\n    sceneTarget: RenderTexture,\n  ): void {\n    if (!this.accumRT || !this.revealRT) return;\n    const normal = panel.normalMap ?? Texture.WHITE;\n    const screenWidth = this.renderer.screen.width;\n    const screenHeight = this.renderer.screen.height;\n\n    const resources = (this.refractShader as any).resources;\n    if (resources) {\n      resources.uSceneColor = sceneTarget.source;\n      resources.uNormalMap = normal.source;\n      resources.uCausticsMap = (panel.causticsAtlas ?? Texture.WHITE).source;\n\n      // Update uniforms through UniformGroup in v8\n      const uniforms = resources.panelUniforms?.uniforms;\n      if (uniforms) {\n        // Use accumRT resolution since gl_FragCoord is in accumRT pixel space\n        const res = this.accumRT?.source?._resolution ?? this.renderer.resolution;\n        uniforms.uPosition[0] = panel.position.x;\n        uniforms.uPosition[1] = panel.position.y;\n        uniforms.uScale[0] = panel.scale.x;\n        uniforms.uScale[1] = panel.scale.y;\n        uniforms.uResolution[0] = screenWidth;\n        uniforms.uResolution[1] = screenHeight;\n        uniforms.uInvResolution[0] = 1 / (screenWidth * res);\n        uniforms.uInvResolution[1] = 1 / (screenHeight * res);\n        uniforms.uIOR = panel.glassMaterial.ior;\n        uniforms.uThickness = panel.glassMaterial.thickness;\n        uniforms.uDispersion = panel.glassMaterial.dispersion;\n        uniforms.uRoughness = panel.glassMaterial.roughness;\n        uniforms.uOpacity = panel.glassMaterial.opacity ?? 1;\n        uniforms.uEnableDispersion =\n          quality.enableDispersion && panel.glassMaterial.dispersion > 0.001 ? 1 : 0;\n        uniforms.uEnableCaustics = quality.enableCaustics && Boolean(panel.causticsAtlas) ? 1 : 0;\n        const tint = hexToVec3(panel.glassMaterial.tint ?? 0xffffff);\n        uniforms.uTint[0] = tint[0];\n        uniforms.uTint[1] = tint[1];\n        uniforms.uTint[2] = tint[2];\n        uniforms.uSpecular = panel.glassMaterial.specular ?? 0;\n        uniforms.uShininess = panel.glassMaterial.shininess ?? 32;\n        uniforms.uShadow = panel.glassMaterial.shadow ?? 0;\n        const lightDir = panel.glassMaterial.lightDir ?? [0.5, 0.5, 1];\n        uniforms.uLightDir[0] = lightDir[0];\n        uniforms.uLightDir[1] = lightDir[1];\n        uniforms.uLightDir[2] = lightDir[2];\n        uniforms.uBlurSamples = panel.glassMaterial.blurSamples ?? 8;\n        uniforms.uBlurSpread = panel.glassMaterial.blurSpread ?? 4;\n        uniforms.uBlurAngle = (panel.glassMaterial.blurAngle ?? 0) * Math.PI / 180;\n        uniforms.uBlurAnisotropy = panel.glassMaterial.blurAnisotropy ?? 0;\n        uniforms.uBlurGamma = panel.glassMaterial.blurGamma ?? 1;\n        uniforms.uAberrationR = panel.glassMaterial.aberrationR ?? 1;\n        uniforms.uAberrationB = panel.glassMaterial.aberrationB ?? 1;\n        uniforms.uAO = panel.glassMaterial.ao ?? 0;\n        uniforms.uAORadius = panel.glassMaterial.aoRadius ?? 0.5;\n        uniforms.uNoiseScale = panel.glassMaterial.noiseScale ?? 20;\n        uniforms.uNoiseIntensity = panel.glassMaterial.noiseIntensity ?? 0;\n        uniforms.uNoiseRotation = panel.glassMaterial.noiseRotation ?? 0;\n        uniforms.uNoiseThreshold = panel.glassMaterial.noiseThreshold ?? 0;\n        uniforms.uEdgeSupersampling = quality.edgeSupersampling ?? 1;\n        uniforms.uEdgeSmoothWidth = panel.glassMaterial.edgeSmoothWidth ?? 0.15;\n        uniforms.uEdgeContrast = panel.glassMaterial.edgeContrast ?? 0.7;\n        uniforms.uEdgeAlphaFalloff = panel.glassMaterial.edgeAlphaFalloff ?? 1;\n        uniforms.uEdgeMaskCutoff = panel.glassMaterial.edgeMaskCutoff ?? 0.001;\n        uniforms.uEnableEdgeSmoothing = panel.glassMaterial.enableEdgeSmoothing === true ? 1 : 0;\n        uniforms.uEnableContrastReduction = panel.glassMaterial.enableContrastReduction === true ? 1 : 0;\n        uniforms.uEnableAlphaFalloff = panel.glassMaterial.enableAlphaFalloff === true ? 1 : 0;\n        uniforms.uEnableTintOpacity = panel.glassMaterial.enableTintOpacity === true ? 1 : 0;\n        uniforms.uEdgeBlur = panel.glassMaterial.edgeBlur ?? 0;\n        uniforms.uGlassSupersampling = panel.glassMaterial.glassSupersampling ?? 1;\n        uniforms.uPanelSize[0] = panel.scale.x;\n        uniforms.uPanelSize[1] = panel.scale.y;\n      }\n    }\n\n    const prevShader = panel.shader;\n    panel.shader = this.refractShader as any;\n    this.drawPanelToTarget(panel, this.accumRT);\n\n    panel.shader = this.revealageShader as any;\n\n    const revealResources = (this.revealageShader as any).resources;\n    if (revealResources) {\n      revealResources.uNormalMap = normal.source;\n\n      const revealUniforms = revealResources.panelUniforms?.uniforms;\n      if (revealUniforms) {\n        revealUniforms.uPosition[0] = panel.position.x;\n        revealUniforms.uPosition[1] = panel.position.y;\n        revealUniforms.uScale[0] = panel.scale.x;\n        revealUniforms.uScale[1] = panel.scale.y;\n        revealUniforms.uResolution[0] = screenWidth;\n        revealUniforms.uResolution[1] = screenHeight;\n        revealUniforms.uOpacity = panel.glassMaterial.opacity;\n      }\n    }\n\n    this.drawPanelToTarget(panel, this.revealRT);\n    panel.shader = prevShader;\n  }\n\n  private renderContactShadows(panels: GlassPanel[], quality: RenderQualityOptions): void {\n    if (!quality.enableContactShadows) return;\n    for (const panel of panels) {\n      if (!panel.sdfShadow) continue;\n      this.shadowSprite.texture = panel.sdfShadow;\n      this.shadowSprite.position.copyFrom(panel.position);\n      this.shadowSprite.scale.copyFrom(panel.scale);\n      this.shadowSprite.rotation = panel.rotation;\n      this.shadowSprite.alpha = Math.min(panel.glassMaterial.opacity + 0.2, 0.9);\n      // this.shadowSprite.state.blendMode = BLEND_MODES.MULTIPLY;\n      this.renderer.render(this.shadowSprite);\n    }\n  }\n\n  getCompositeDisplay(): Container | undefined {\n    return this.compositeSprite;\n  }\n\n  private drawPanelToTarget(panel: GlassPanel, target: RenderTexture): void {\n    const renderer = this.renderer;\n    const gl = (renderer as any).gl as WebGL2RenderingContext;\n\n    // Clear parent and add only this panel\n    this.panelParent.removeChildren();\n    this.panelParent.addChild(panel);\n\n    // Update transforms for detached container in v8\n    panel.updateLocalTransform();\n    panel.worldTransform.copyFrom(panel.localTransform);\n\n    // Use standard alpha blending\n    if (gl) {\n      gl.enable(gl.BLEND);\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n    }\n\n    renderer.render({ container: this.panelParent, target, clear: false });\n\n    // Reset blend state\n    if (gl) {\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    }\n  }\n\n  private ensureCompositeTarget(width: number, height: number): void {\n    const targetResolution = this.renderer.resolution;\n    if (\n      !this.compositeRT ||\n      this.compositeRT.width !== width ||\n      this.compositeRT.height !== height ||\n      this.compositeRT.source.resolution !== targetResolution\n    ) {\n      this.compositeRT?.destroy(true);\n      this.compositeRT = RenderTexture.create({\n        width,\n        height,\n        resolution: targetResolution,\n      });\n      this.compositeSprite.texture = this.compositeRT;\n    }\n  }\n}\n","import type { Container, RenderTexture, Renderer, WebGLRenderer } from 'pixi.js';\nimport { AdaptiveQualityController } from '../core/AdaptiveQualityController.js';\nimport { CapabilityProbe } from '../core/CapabilityProbe.js';\nimport { EventBus } from '../core/EventBus.js';\nimport type {\n  AdaptiveDecision,\n  FallbackEvent,\n  GlassPanelProps,\n  GlassSystemOptions,\n  RenderQualityOptions,\n} from '../core/types.js';\nimport type { GlassPanel } from '../panels/GlassPanel.js';\nimport { GlassPanel as GlassPanelImpl } from '../panels/GlassPanel.js';\nimport type { Pipeline } from '../pipelines/BasePipeline.js';\nimport { WebGL1Pipeline } from '../pipelines/WebGL1Pipeline.js';\nimport { WebGL2Pipeline } from '../pipelines/WebGL2Pipeline.js';\n\ninterface GlassSystemEvents {\n  'quality:decision': AdaptiveDecision;\n  fallback: FallbackEvent;\n  [key: string]: any; // Add index signature to satisfy EventMap\n}\n\nexport class GlassSystem {\n  private pipeline: Pipeline;\n  private readonly panels: GlassPanel[] = [];\n  private readonly quality = new AdaptiveQualityController();\n  private drawOpaqueScene: (target: RenderTexture) => void = () => {};\n  private readonly events = new EventBus<GlassSystemEvents>();\n\n  constructor(\n    private readonly renderer: Renderer,\n    _options: GlassSystemOptions = {},\n  ) {\n    const gl = (renderer as WebGLRenderer).gl;\n    const capability = new CapabilityProbe(gl).run();\n    this.pipeline =\n      capability.tier === 'webgl2'\n        ? new WebGL2Pipeline(renderer, true)\n        : new WebGL1Pipeline(renderer);\n    if (capability.tier === 'webgl1') {\n      this.emitFallback('webgl', 'MRT unavailable, using compatibility pipeline');\n    }\n  }\n\n  setOpaqueSceneCallback(draw: (target: RenderTexture) => void): void {\n    this.drawOpaqueScene = draw;\n  }\n\n  createPanel(props: GlassPanelProps): GlassPanel {\n    const panel = new GlassPanelImpl(props);\n    this.panels.push(panel);\n    return panel;\n  }\n\n  removePanel(panel: GlassPanel): void {\n    const idx = this.panels.indexOf(panel);\n    if (idx >= 0) {\n      this.panels.splice(idx, 1);\n      panel.destroy({ children: true, texture: false, textureSource: false });\n    }\n  }\n\n  render(): void {\n    const start = performance.now();\n    const quality = this.quality.getQuality();\n    this.pipeline.render({\n      renderer: this.renderer,\n      panels: this.panels,\n      quality,\n      drawOpaqueScene: this.drawOpaqueScene,\n    });\n    const duration = performance.now() - start;\n    this.quality.record({ cpuMs: duration, timestamp: start });\n    const decision = this.quality.evaluate();\n    if (decision) {\n      this.events.emit('quality:decision', decision);\n    }\n  }\n\n  setQuality(options: Partial<RenderQualityOptions>): void {\n    this.quality.setOverrides(options);\n  }\n\n  destroy(): void {\n    for (const panel of this.panels) {\n      panel.destroy({ children: true, texture: false, textureSource: false });\n    }\n    this.panels.length = 0;\n    this.pipeline.dispose();\n    this.events.removeAll();\n  }\n\n  on<K extends keyof GlassSystemEvents>(\n    event: K,\n    listener: (payload: GlassSystemEvents[K]) => void,\n  ): void {\n    this.events.on(event, listener);\n  }\n\n  off<K extends keyof GlassSystemEvents>(\n    event: K,\n    listener: (payload: GlassSystemEvents[K]) => void,\n  ): void {\n    this.events.off(event, listener);\n  }\n\n  getPipelineId(): string {\n    return this.pipeline.id;\n  }\n\n  getCompositeDisplay(): Container | undefined {\n    if (typeof this.pipeline.getCompositeDisplay === 'function') {\n      return this.pipeline.getCompositeDisplay();\n    }\n    return undefined;\n  }\n\n  private emitFallback(target: string, message: string): void {\n    const event: FallbackEvent = { target, message, timestamp: performance.now() };\n    console.warn(`GlassSystem fallback: ${target} - ${message}`);\n    this.events.emit('fallback', event);\n  }\n}\n","import { Container, Graphics, Text } from 'pixi.js';\nimport type { Renderer } from 'pixi.js';\nimport type { AdaptiveDecision, RenderQualityOptions, TelemetrySample } from '../core/types.js';\n\ninterface HudMetrics {\n  quality: RenderQualityOptions;\n  fps: number;\n  lastDecision?: AdaptiveDecision;\n  telemetry: TelemetrySample[];\n}\n\nexport class GlassHUD {\n  readonly container = new Container();\n  private readonly panel: Graphics;\n  private readonly text: Text;\n  private visible = false;\n\n  constructor(private readonly renderer: Renderer) {\n    this.panel = new Graphics()\n      .beginFill(0x000000, 0.65)\n      .drawRoundedRect(0, 0, 260, 120, 8)\n      .endFill();\n    this.text = new Text('Glass HUD', { fontSize: 12, fill: 0xffffff });\n    this.text.position.set(12, 10);\n    this.container.addChild(this.panel, this.text);\n    this.container.visible = this.visible;\n    this.container.position.set(12, 12);\n  }\n\n  setVisible(visible: boolean): void {\n    this.visible = visible;\n    this.container.visible = visible;\n  }\n\n  update(metrics: HudMetrics): void {\n    if (!this.visible) return;\n    const { quality, fps, lastDecision } = metrics;\n    const lines = [\n      `FPS: ${fps.toFixed(1)}`,\n      `Scale: ${(quality.renderScale * 100).toFixed(0)}%`,\n      `Blur taps: ${quality.maxBlurTaps}`,\n      `Dispersion: ${quality.enableDispersion ? 'on' : 'off'}`,\n      `Caustics: ${quality.enableCaustics ? 'on' : 'off'}`,\n    ];\n    if (lastDecision) {\n      lines.push(`Action: ${lastDecision.action}`);\n    }\n    this.text.text = lines.join('\\n');\n  }\n}\n","import { Container, Texture } from 'pixi.js';\nimport type { Renderer } from 'pixi.js';\nimport { GlassSystem } from './system/GlassSystem.js';\nimport { GlassPresets } from './materials/GlassPresets.js';\nimport type { GlassPanel } from './panels/GlassPanel.js';\nimport type { GlassMaterial, SurfaceShape } from './core/types.js';\n\nexport interface PositionTransform {\n  x: number;\n  y: number;\n  scaleX: number;\n  scaleY: number;\n  rotation: number;\n}\n\nexport type PositionTransformFn = (\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n) => PositionTransform;\n\nexport interface LightFollowParams {\n  followCursor: boolean;\n  smoothing?: number; // 0 - 1, amount of smoothing (0 = instant, 1 = very slow, default 0.9)\n  delay?: number; // 0 - 1, lag before movement starts (0 = instant, 1 = max lag, default 0.5)\n  curve?: number; // 0.5 - 3, z falloff curve (default 1.5)\n  zMin?: number; // minimum z value (default 0.05)\n  zMax?: number; // maximum z value (default 0.20)\n  edgeStretch?: number; // 0.1 - 2, how much to stretch toward edges (< 1 = more edge, > 1 = more center, default 0.5)\n}\n\nexport interface GlassOverlayOptions {\n  /**\n   * The container holding the background content that should be seen through the glass.\n   * This will be rendered into the glass system's backdrop texture.\n   */\n  background: Container;\n\n  /**\n   * The container where the glass composite effect should be added.\n   * Typically the same stage, or a layer above the background.\n   */\n  stage: Container;\n\n  /**\n   * Optional initial configuration for the GlassSystem.\n   */\n  systemOptions?: {\n    hudEnabled?: boolean;\n  };\n\n  /**\n   * Optional light follow cursor settings.\n   */\n  lightFollowParams?: LightFollowParams;\n}\n\nexport interface GlassItemConfig {\n  /**\n   * Custom material overrides for this element.\n   */\n  material?: Partial<GlassMaterial>;\n\n  /**\n   * Optional custom normal map. If not provided, a default rounded rect map is generated.\n   */\n  normalMap?: Texture;\n\n  /**\n   * Corner radius for the default normal map generation. Defaults to 20.\n   */\n  cornerRadius?: number;\n\n  /**\n   * Surface shape for the glass bevel. Defaults to 'squircle'.\n   * - circle: Simple circular arc (sharper edges)\n   * - squircle: Softer flatcurve transition (smoother, default)\n   * - concave: Bowl-like depression (light diverges outward)\n   * - lip: Raised rim with shallow center dip\n   */\n  surfaceShape?: SurfaceShape;\n\n  /**\n   * How far the bevel extends from the edge toward center (in pixels).\n   * Defaults to 12.\n   */\n  bevelSize?: number;\n\n  /**\n   * Flip the normal map on X axis. Defaults to false.\n   */\n  flipX?: boolean;\n\n  /**\n   * Flip the normal map on Y axis. Defaults to false.\n   */\n  flipY?: boolean;\n\n  /**\n   * Bezier curve control points for custom bevel shape [x1, y1, x2, y2].\n   * When provided, overrides surfaceShape.\n   */\n  bezierCurve?: [number, number, number, number];\n\n  /**\n   * Render as a circle. Sets corner radius to half the minimum dimension.\n   * Can also be triggered by adding 'glass-circle' class or data-glass-circle attribute.\n   */\n  isCircle?: boolean;\n}\n\n/**\n * A high-level wrapper for GlassSystem that synchronizes GlassPanels with DOM elements.\n * Ideal for adding glass effects to existing UI overlays in Nuxt/Vue/React projects.\n */\ninterface TrackedItem {\n  panel: GlassPanel;\n  config: GlassItemConfig;\n  lastRect?: DOMRect;\n  lastRadius: number;\n  visible: boolean;\n  isCircle: boolean;\n  polling: boolean;\n}\n\nexport class GlassOverlay {\n  public readonly system: GlassSystem;\n  private readonly tracked = new Map<HTMLElement, TrackedItem>();\n  private readonly background: Container;\n  private observer?: MutationObserver;\n  private resizeObserver?: ResizeObserver;\n  private intersectionObserver?: IntersectionObserver;\n  private positionTransform?: PositionTransformFn;\n\n  // Light follow cursor\n  private lightFollowParams?: LightFollowParams;\n  private currentLightDir: [number, number, number] = [0, 0, 0.15];\n  private targetLightDir: [number, number, number] = [0, 0, 0.15];\n  private delayedLightDir: [number, number, number] = [0, 0, 0.15];\n  private boundMouseMove?: (e: MouseEvent) => void;\n\n  private renderer: Renderer;\n\n  constructor(renderer: Renderer, options: GlassOverlayOptions) {\n    this.renderer = renderer;\n    this.background = options.background;\n    this.system = new GlassSystem(renderer, options.systemOptions);\n\n    this.system.setOpaqueSceneCallback((target) => {\n      renderer.render({ container: this.background, target, clear: true });\n    });\n\n    const composite = this.system.getCompositeDisplay();\n    if (composite) {\n      options.stage.addChild(composite);\n    }\n\n    // Set up light follow cursor\n    if (options.lightFollowParams) {\n      this.setLightFollowParams(options.lightFollowParams);\n    }\n  }\n\n  setLightFollowParams(params: LightFollowParams): void {\n    this.lightFollowParams = params;\n\n    if (params.followCursor && !this.boundMouseMove) {\n      this.boundMouseMove = (e: MouseEvent) => {\n        const curve = params.curve ?? 1.5;\n        const zMin = params.zMin ?? 0.05;\n        const zMax = params.zMax ?? 0.20;\n        const edgeStretch = params.edgeStretch ?? 0.5;\n\n        // Get canvas bounds for proper coordinate mapping\n        const canvas = this.renderer.canvas as HTMLCanvasElement;\n        const rect = canvas.getBoundingClientRect();\n\n        // Convert cursor position to -1 to 1 range relative to canvas\n        let x = ((e.clientX - rect.left) / rect.width) * 2 - 1;\n        let y = ((e.clientY - rect.top) / rect.height) * 2 - 1; // Y: top=-1, bottom=1\n\n        // Apply edge stretch - power curve controls how values spread\n        // < 1 = stretch toward edges, > 1 = compress toward center\n        x = Math.sign(x) * Math.pow(Math.abs(x), edgeStretch);\n        y = Math.sign(y) * Math.pow(Math.abs(y), edgeStretch);\n\n        // Z decreases toward edges based on curve, capped at zMax (0.20)\n        const dist = Math.sqrt(x * x + y * y);\n        const z = Math.max(zMin, Math.min(zMax, zMax - Math.pow(dist, curve) * zMax * 0.5));\n\n        this.targetLightDir = [x, y, z];\n      };\n      window.addEventListener('mousemove', this.boundMouseMove);\n    } else if (!params.followCursor && this.boundMouseMove) {\n      window.removeEventListener('mousemove', this.boundMouseMove);\n      this.boundMouseMove = undefined;\n    }\n  }\n\n  autoMount(selector: string = '.glass-panel'): void {\n    // Set up ResizeObserver for size changes\n    this.resizeObserver = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const element = entry.target as HTMLElement;\n        const item = this.tracked.get(element);\n        if (!item) continue;\n\n        const rect = element.getBoundingClientRect();\n        const lastRect = item.lastRect;\n\n        // Check if size changed significantly (more than 1px)\n        if (lastRect && (\n          Math.abs(rect.width - lastRect.width) > 1 ||\n          Math.abs(rect.height - lastRect.height) > 1\n        )) {\n          this.updatePanelGeometry(element, item);\n        }\n        item.lastRect = rect;\n      }\n    });\n\n    // Set up IntersectionObserver for visibility\n    this.intersectionObserver = new IntersectionObserver((entries) => {\n      for (const entry of entries) {\n        const element = entry.target as HTMLElement;\n        const item = this.tracked.get(element);\n        if (!item) continue;\n\n        item.visible = entry.isIntersecting;\n        const cssVisible = this.isCssVisible(element);\n        item.panel.visible = item.visible && cssVisible;\n      }\n    });\n\n    const existing = document.querySelectorAll<HTMLElement>(selector);\n    existing.forEach((el) => this.track(el));\n\n    this.observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.type === 'childList') {\n          mutation.addedNodes.forEach((node) => {\n            if (node instanceof HTMLElement && node.matches(selector)) {\n              this.track(node);\n            }\n            if (node instanceof HTMLElement) {\n              const children = node.querySelectorAll<HTMLElement>(selector);\n              children.forEach((child) => this.track(child));\n            }\n          });\n          mutation.removedNodes.forEach((node) => {\n            if (node instanceof HTMLElement && this.tracked.has(node)) {\n              this.untrack(node);\n            }\n          });\n        } else if (mutation.type === 'attributes') {\n          const target = mutation.target as HTMLElement;\n          if (mutation.attributeName === 'class') {\n            if (target.matches(selector)) {\n              this.track(target);\n            } else {\n              this.untrack(target);\n            }\n          } else if (mutation.attributeName === 'style') {\n            const item = this.tracked.get(target);\n            if (item) {\n              // Check for visibility changes\n              const cssVisible = this.isCssVisible(target);\n              item.panel.visible = cssVisible && item.visible;\n\n              // Check for border-radius changes\n              const rect = target.getBoundingClientRect();\n              const newRadius = this.parseBorderRadius(target, rect);\n              if (Math.abs(newRadius - item.lastRadius) > 0.5) {\n                this.updatePanelGeometry(target, item);\n              }\n            }\n          } else if (mutation.attributeName === 'hidden') {\n            const item = this.tracked.get(target);\n            if (item) {\n              const cssVisible = this.isCssVisible(target);\n              item.panel.visible = cssVisible && item.visible;\n            }\n          }\n        }\n      }\n      this.cleanup();\n    });\n\n    this.observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: ['class', 'style', 'hidden'],\n    });\n  }\n\n  track(element: HTMLElement, config: GlassItemConfig = {}): GlassPanel {\n    if (this.tracked.has(element)) {\n      return this.tracked.get(element)!.panel;\n    }\n\n    const dataIor = element.dataset.glassIor ? parseFloat(element.dataset.glassIor) : undefined;\n    const dataRoughness = element.dataset.glassRoughness\n      ? parseFloat(element.dataset.glassRoughness)\n      : undefined;\n\n    const material = {\n      ...GlassPresets.clear(),\n      ...config.material,\n    };\n\n    if (dataIor !== undefined) material.ior = dataIor;\n    if (dataRoughness !== undefined) material.roughness = dataRoughness;\n\n    // Calculate dynamic normal map based on initial size\n    const rect = element.getBoundingClientRect();\n\n    // Detect circle mode from config, class, or data attribute\n    const isCircle = config.isCircle ||\n                     element.classList.contains('glass-circle') ||\n                     element.hasAttribute('data-glass-circle');\n\n    let radius: number;\n    if (isCircle) {\n      // Circle: radius = half the smaller dimension\n      radius = Math.min(rect.width, rect.height) / 2;\n    } else {\n      const cssRadius = this.parseBorderRadius(element, rect);\n      radius = config.cornerRadius ?? cssRadius; // Config overrides CSS\n    }\n    const bevel = config.bevelSize ?? 12;\n\n    const shape = config.surfaceShape ?? 'squircle';\n    const flipX = config.flipX ?? false;\n    const flipY = config.flipY ?? false;\n    const bezierCurve = config.bezierCurve;\n\n    // For circles, use square dimensions\n    const circleSize = Math.floor(Math.min(rect.width, rect.height));\n    const mapWidth = isCircle ? circleSize : rect.width;\n    const mapHeight = isCircle ? circleSize : rect.height;\n\n    const normalMap =\n      config.normalMap || createRoundedRectNormalMap(mapWidth, mapHeight, radius, bevel, shape, flipX, flipY, bezierCurve);\n\n    const panel = this.system.createPanel({\n      material,\n      normalMap,\n    });\n\n    this.tracked.set(element, { panel, config, lastRect: rect, lastRadius: radius, visible: true, isCircle, polling: false });\n\n    // Set up observers for this element\n    this.resizeObserver?.observe(element);\n    this.intersectionObserver?.observe(element);\n\n    // Set up animation/transition listeners\n    element.addEventListener('transitionrun', this.handleAnimationStart);\n    element.addEventListener('transitionend', this.handleAnimationEnd);\n    element.addEventListener('transitioncancel', this.handleAnimationEnd);\n    element.addEventListener('animationstart', this.handleAnimationStart);\n    element.addEventListener('animationend', this.handleAnimationEnd);\n    element.addEventListener('animationcancel', this.handleAnimationEnd);\n\n    this.syncElement(element, panel);\n\n    return panel;\n  }\n\n  private handleAnimationStart = (e: Event) => {\n    const element = e.currentTarget as HTMLElement;\n    this.startPolling(element);\n  };\n\n  private handleAnimationEnd = (e: Event) => {\n    const element = e.currentTarget as HTMLElement;\n    // Check if any animations are still running\n    const animations = element.getAnimations();\n    if (animations.length === 0) {\n      this.stopPolling(element);\n    }\n  };\n\n  private startPolling(element: HTMLElement): void {\n    const item = this.tracked.get(element);\n    if (!item || item.polling) return;\n\n    item.polling = true;\n    const poll = () => {\n      if (!item.polling) return;\n      this.syncElement(element, item.panel);\n      requestAnimationFrame(poll);\n    };\n    requestAnimationFrame(poll);\n  }\n\n  private stopPolling(element: HTMLElement): void {\n    const item = this.tracked.get(element);\n    if (!item) return;\n\n    item.polling = false;\n    this.updatePanelGeometry(element, item);\n  }\n\n  untrack(element: HTMLElement): void {\n    const item = this.tracked.get(element);\n    if (item) {\n      item.polling = false;\n      this.resizeObserver?.unobserve(element);\n      this.intersectionObserver?.unobserve(element);\n      element.removeEventListener('transitionrun', this.handleAnimationStart);\n      element.removeEventListener('transitionend', this.handleAnimationEnd);\n      element.removeEventListener('transitioncancel', this.handleAnimationEnd);\n      element.removeEventListener('animationstart', this.handleAnimationStart);\n      element.removeEventListener('animationend', this.handleAnimationEnd);\n      element.removeEventListener('animationcancel', this.handleAnimationEnd);\n      this.system.removePanel(item.panel);\n      this.tracked.delete(element);\n    }\n  }\n\n  update(): void {\n    // Update light direction with delay and smoothing\n    if (this.lightFollowParams?.followCursor) {\n      // Delay: lerp delayed toward target (0 = instant, 1 = very slow)\n      const delay = this.lightFollowParams.delay ?? 0.5;\n      const delayFactor = 1 - delay * 0.97; // Convert to lerp factor (0.03 to 1)\n      this.delayedLightDir[0] += (this.targetLightDir[0] - this.delayedLightDir[0]) * delayFactor;\n      this.delayedLightDir[1] += (this.targetLightDir[1] - this.delayedLightDir[1]) * delayFactor;\n      this.delayedLightDir[2] += (this.targetLightDir[2] - this.delayedLightDir[2]) * delayFactor;\n\n      // Smoothing: lerp current toward delayed (0 = instant, 1 = very slow)\n      const smoothing = this.lightFollowParams.smoothing ?? 0.9;\n      const smoothFactor = 1 - smoothing * 0.97; // Convert to lerp factor (0.03 to 1)\n      this.currentLightDir[0] += (this.delayedLightDir[0] - this.currentLightDir[0]) * smoothFactor;\n      this.currentLightDir[1] += (this.delayedLightDir[1] - this.currentLightDir[1]) * smoothFactor;\n      this.currentLightDir[2] += (this.delayedLightDir[2] - this.currentLightDir[2]) * smoothFactor;\n\n      // Apply to all panels\n      for (const [, item] of this.tracked) {\n        item.panel.glassMaterial.lightDir = [...this.currentLightDir];\n      }\n    }\n\n    for (const [element, item] of this.tracked) {\n      this.syncElement(element, item.panel);\n    }\n    this.system.render();\n  }\n\n  resize(): void {\n    this.update();\n  }\n\n  setPositionTransform(transform: PositionTransformFn | undefined): void {\n    this.positionTransform = transform;\n  }\n\n  cleanup(): void {\n    for (const [element] of this.tracked) {\n      if (!document.body.contains(element)) {\n        this.untrack(element);\n      }\n    }\n  }\n\n  destroy(): void {\n    if (this.boundMouseMove) {\n      window.removeEventListener('mousemove', this.boundMouseMove);\n      this.boundMouseMove = undefined;\n    }\n    this.observer?.disconnect();\n    this.resizeObserver?.disconnect();\n    this.intersectionObserver?.disconnect();\n    this.system.destroy();\n    this.tracked.clear();\n  }\n\n  private syncElement(element: HTMLElement, panel: GlassPanel) {\n    const item = this.tracked.get(element);\n    const rect = element.getBoundingClientRect();\n\n    const x = rect.left + rect.width / 2;\n    const y = rect.top + rect.height / 2;\n\n    // For circles, use the smaller dimension for both width and height\n    let width = rect.width;\n    let height = rect.height;\n    if (item?.isCircle) {\n      const size = Math.floor(Math.min(rect.width, rect.height));\n      width = size;\n      height = size;\n    }\n\n    if (this.positionTransform) {\n      const t = this.positionTransform(x, y, width, height);\n      panel.position.set(t.x, t.y);\n      panel.scale.set(width * t.scaleX, height * t.scaleY);\n      panel.rotation = t.rotation;\n    } else {\n      panel.position.set(x, y);\n      panel.scale.set(width, height);\n      panel.rotation = 0;\n    }\n  }\n\n  private parseBorderRadius(element: HTMLElement, rect: DOMRect): number {\n    const style = window.getComputedStyle(element);\n\n    // Get all four corner radii (computed style always returns individual values)\n    const topLeft = style.borderTopLeftRadius;\n    const topRight = style.borderTopRightRadius;\n    const bottomRight = style.borderBottomRightRadius;\n    const bottomLeft = style.borderBottomLeftRadius;\n\n    // Parse a single radius value (handles px and %)\n    const parseValue = (value: string, dimension: number): number => {\n      if (value.endsWith('%')) {\n        return (parseFloat(value) / 100) * dimension;\n      }\n      return parseFloat(value) || 0;\n    };\n\n    // For elliptical corners (e.g., \"10px 20px\"), use the first value (horizontal)\n    const getFirstValue = (radius: string): string => {\n      return radius.split(' ')[0];\n    };\n\n    // Use average of width/height for percentage calculations\n    const avgDimension = (rect.width + rect.height) / 2;\n\n    // Parse all corners and return the average\n    const radii = [\n      parseValue(getFirstValue(topLeft), avgDimension),\n      parseValue(getFirstValue(topRight), avgDimension),\n      parseValue(getFirstValue(bottomRight), avgDimension),\n      parseValue(getFirstValue(bottomLeft), avgDimension),\n    ];\n\n    // Return average radius, or use the most common value\n    const avg = radii.reduce((a, b) => a + b, 0) / 4;\n    return avg || 20; // Default to 20 if parsing fails\n  }\n\n  private isCssVisible(element: HTMLElement): boolean {\n    if (element.hidden) return false;\n    const style = window.getComputedStyle(element);\n    return style.display !== 'none' &&\n           style.visibility !== 'hidden';\n  }\n\n  private updatePanelGeometry(element: HTMLElement, item: TrackedItem): void {\n    const rect = element.getBoundingClientRect();\n\n    // Detect circle mode\n    const isCircle = item.config.isCircle ||\n                     element.classList.contains('glass-circle') ||\n                     element.hasAttribute('data-glass-circle');\n\n    let radius: number;\n    if (isCircle) {\n      radius = Math.min(rect.width, rect.height) / 2;\n    } else {\n      const cssRadius = this.parseBorderRadius(element, rect);\n      radius = item.config.cornerRadius ?? cssRadius;\n    }\n    const bevel = item.config.bevelSize ?? 12;\n    const shape = item.config.surfaceShape ?? 'squircle';\n    const flipX = item.config.flipX ?? false;\n    const flipY = item.config.flipY ?? false;\n    const bezierCurve = item.config.bezierCurve;\n\n    // For circles, use square dimensions\n    const circleSize = Math.floor(Math.min(rect.width, rect.height));\n    const mapWidth = isCircle ? circleSize : rect.width;\n    const mapHeight = isCircle ? circleSize : rect.height;\n\n    // Regenerate normal map with new dimensions/radius\n    const normalMap = createRoundedRectNormalMap(\n      mapWidth, mapHeight, radius, bevel, shape, flipX, flipY, bezierCurve\n    );\n\n    // Update the panel's normal map\n    item.panel.setTextures({ normalMap });\n    item.lastRect = rect;\n    item.lastRadius = radius;\n  }\n}\n\n// Height functions for different surface shapes\n// t is normalized distance from inner edge (0) to outer edge (1)\nexport function heightCircle(t: number): number {\n  return Math.sqrt(Math.max(0, 2 * t - t * t));\n}\n\nfunction heightCircleDerivative(t: number): number {\n  const h = Math.sqrt(Math.max(0.0001, 2 * t - t * t));\n  return (1 - t) / h;\n}\n\nexport function heightSquircle(t: number): number {\n  const inner = 1 - Math.pow(1 - t, 4);\n  return Math.pow(Math.max(0, inner), 0.25);\n}\n\nfunction heightSquircleDerivative(t: number): number {\n  const inner = 1 - Math.pow(1 - t, 4);\n  if (inner <= 0.0001) return 0;\n  return Math.pow(1 - t, 3) / Math.pow(inner, 0.75);\n}\n\nexport function smootherstep(t: number): number {\n  const x = Math.max(0, Math.min(1, t));\n  return x * x * x * (x * (x * 6 - 15) + 10);\n}\n\nfunction smootherstepDerivative(t: number): number {\n  const x = Math.max(0, Math.min(1, t));\n  return 30 * x * x * (x - 1) * (x - 1);\n}\n\n// Cubic bezier evaluation\nfunction cubicBezier(t: number, p0: number, p1: number, p2: number, p3: number): number {\n  const mt = 1 - t;\n  return mt * mt * mt * p0 + 3 * mt * mt * t * p1 + 3 * mt * t * t * p2 + t * t * t * p3;\n}\n\nfunction cubicBezierDerivative(t: number, p0: number, p1: number, p2: number, p3: number): number {\n  const mt = 1 - t;\n  return 3 * mt * mt * (p1 - p0) + 6 * mt * t * (p2 - p1) + 3 * t * t * (p3 - p2);\n}\n\nexport function getBezierHeightAndDerivative(\n  t: number,\n  curve: [number, number, number, number],\n): { height: number; derivative: number } {\n  // curve = [x1, y1, x2, y2] control points for cubic bezier from (0,0) to (1,1)\n  const height = cubicBezier(t, 0, curve[1], curve[3], 1);\n  const derivative = cubicBezierDerivative(t, 0, curve[1], curve[3], 1);\n  return { height, derivative };\n}\n\nexport function getHeightAndDerivative(\n  t: number,\n  shape: SurfaceShape,\n  bezierCurve?: [number, number, number, number],\n): { height: number; derivative: number } {\n  // Use bezier curve if provided\n  if (bezierCurve) {\n    return getBezierHeightAndDerivative(t, bezierCurve);\n  }\n  switch (shape) {\n    case 'circle': {\n      return { height: heightCircle(t), derivative: heightCircleDerivative(t) };\n    }\n    case 'squircle': {\n      return { height: heightSquircle(t), derivative: heightSquircleDerivative(t) };\n    }\n    case 'concave': {\n      const h = heightSquircle(t);\n      const d = heightSquircleDerivative(t);\n      return { height: 1 - h, derivative: -d };\n    }\n    case 'lip': {\n      const convexH = heightSquircle(t);\n      const convexD = heightSquircleDerivative(t);\n      const concaveH = 1 - convexH;\n      const concaveD = -convexD;\n      const blend = smootherstep(t);\n      const blendD = smootherstepDerivative(t);\n      const height = convexH * (1 - blend) + concaveH * blend;\n      const derivative = convexD * (1 - blend) + concaveD * blend + (concaveH - convexH) * blendD;\n      return { height, derivative };\n    }\n    case 'dome': {\n      // Full hemisphere - height goes from 0 at edge to 1 at center\n      const h = Math.sqrt(Math.max(0, 1 - t * t));\n      const d = t > 0.001 ? -t / h : 0;\n      return { height: h, derivative: d };\n    }\n    case 'ridge': {\n      // Sharp peak - inverse of dome\n      const h = 1 - Math.sqrt(Math.max(0, 1 - t * t));\n      const d = t > 0.001 ? t / Math.sqrt(Math.max(0.001, 1 - t * t)) : 0;\n      return { height: h, derivative: d };\n    }\n    case 'wave': {\n      // Sinusoidal wave\n      const h = (1 - Math.cos(t * Math.PI)) / 2;\n      const d = (Math.PI * Math.sin(t * Math.PI)) / 2;\n      return { height: h, derivative: d };\n    }\n    case 'flat': {\n      // No bevel, completely flat\n      return { height: 0, derivative: 0 };\n    }\n  }\n}\n\nfunction createRoundedRectNormalMap(\n  width: number,\n  height: number,\n  radius: number,\n  bevel: number,\n  shape: SurfaceShape,\n  flipX: boolean = false,\n  flipY: boolean = false,\n  bezierCurve?: [number, number, number, number],\n): Texture {\n  const w = Math.ceil(width);\n  const h = Math.ceil(height);\n  const data = new Uint8Array(w * h * 4);\n\n  for (let y = 0; y < h; y++) {\n    for (let x = 0; x < w; x++) {\n      let nx = 0;\n      let ny = 0;\n      let nz = 1;\n      let alpha = 255;\n\n      // Use pixel centers for proper symmetry (pixels go 0 to w-1)\n      const cx = (w - 1) / 2;\n      const cy = (h - 1) / 2;\n      const relX = Math.abs(x - cx);\n      const relY = Math.abs(y - cy);\n\n      const innerW = w / 2 - radius;\n      const innerH = h / 2 - radius;\n\n      // Calculate distance to boundary and direction to boundary\n      let distToBoundary = 0;\n      let dirX = 0;\n      let dirY = 0;\n\n      // Find closest point on rounded rect boundary\n      let closestX = relX;\n      let closestY = relY;\n\n      if (relX <= innerW && relY <= innerH) {\n        // Inside flat center - closest point is on nearest edge\n        const toEdgeX = innerW + radius;\n        const toEdgeY = innerH + radius;\n        if (toEdgeX - relX < toEdgeY - relY) {\n          closestX = innerW + radius;\n          closestY = relY;\n        } else {\n          closestX = relX;\n          closestY = innerH + radius;\n        }\n        distToBoundary = Math.min(toEdgeX - relX, toEdgeY - relY);\n      } else if (relX > innerW && relY <= innerH) {\n        // Edge region (right/left)\n        closestX = innerW + radius;\n        closestY = relY;\n        distToBoundary = radius - (relX - innerW);\n      } else if (relY > innerH && relX <= innerW) {\n        // Edge region (top/bottom)\n        closestX = relX;\n        closestY = innerH + radius;\n        distToBoundary = radius - (relY - innerH);\n      } else {\n        // Corner region\n        const dx = relX - innerW;\n        const dy = relY - innerH;\n        const cornerDist = Math.sqrt(dx * dx + dy * dy);\n        distToBoundary = radius - cornerDist;\n        if (cornerDist > 0) {\n          closestX = innerW + (dx / cornerDist) * radius;\n          closestY = innerH + (dy / cornerDist) * radius;\n        }\n      }\n\n      // Hard cutoff for pixels outside the shape\n      if (distToBoundary < 0) {\n        alpha = 0;\n      }\n\n      // Direction points from pixel toward closest boundary point\n      const toDirX = closestX - relX;\n      const toDirY = closestY - relY;\n      const dirLen = Math.sqrt(toDirX * toDirX + toDirY * toDirY);\n      if (dirLen > 0.001) {\n        dirX = (x > cx ? 1 : -1) * (toDirX / dirLen);\n        dirY = (y > cy ? 1 : -1) * (toDirY / dirLen);\n      }\n\n      // Apply bevel based on distance to boundary\n      if (bevel > 0 && distToBoundary < bevel && distToBoundary >= 0) {\n        let t = 1 - distToBoundary / bevel;\n        if (flipY) t = 1 - t;\n        const { derivative } = getHeightAndDerivative(t, shape, bezierCurve);\n        const sign = flipY ? -1 : 1;\n        nx = dirX * derivative * 0.5 * sign;\n        ny = dirY * derivative * 0.5 * sign;\n        if (flipX) {\n          nx = -nx;\n          ny = -ny;\n        }\n      }\n\n      const len = Math.sqrt(nx * nx + ny * ny + nz * nz);\n      nx /= len;\n      ny /= len;\n      nz /= len;\n\n      const index = (y * w + x) * 4;\n      data[index] = ((nx * 0.5 + 0.5) * 255) | 0;\n      data[index + 1] = ((ny * 0.5 + 0.5) * 255) | 0;\n      data[index + 2] = ((nz * 0.5 + 0.5) * 255) | 0;\n      data[index + 3] = alpha;\n    }\n  }\n  return Texture.from({\n    resource: data,\n    width: w,\n    height: h,\n  });\n}\n"],"names":["CapabilityProbe","gl","isWebGL2","extensions","tier","names","map","name","ext","param","DEFAULT_QUALITY","DEGRADATION_STEPS","q","AdaptiveQualityController","targetFrameMs","sample","overrides","avgCpu","sum","s","avgGpu","step","SceneRTManager","renderer","useDepth","Rectangle","width","height","scale","targetResolution","RenderTexture","_a","_c","_b","EventBus","event","listener","listeners","payload","key","make","material","GlassPresets","ior","clamped","PANEL_COUNTER","QUAD_GEOMETRY","MeshGeometry","BASIC_VERT","BASIC_FRAG","GlassPanel","Mesh","props","state","State","Shader","partial","textures","hexToVec3","hex","CompatibilityFilter","Filter","fragment","GlProgram","Texture","WebGL1Pipeline","Sprite","context","panels","quality","drawOpaqueScene","targets","orderedPanels","a","b","panel","sceneTexture","resources","uniforms","fullscreenVertex","panelVertex","refractionFragment","revealageFragment","compositeFragment","WebGL2Pipeline","refractUniforms","UniformGroup","revealUniforms","Container","target","r","g","dummy","sceneTarget","normal","screenWidth","screenHeight","res","tint","lightDir","prevShader","revealResources","_d","GlassSystem","_options","capability","draw","GlassPanelImpl","idx","start","duration","decision","options","message","GlassHUD","Graphics","Text","visible","metrics","fps","lastDecision","lines","GlassOverlay","e","element","composite","params","curve","zMin","zMax","edgeStretch","rect","x","y","dist","z","selector","entries","entry","item","lastRect","cssVisible","el","mutations","mutation","node","child","newRadius","config","dataIor","dataRoughness","isCircle","radius","cssRadius","bevel","shape","flipX","flipY","bezierCurve","circleSize","mapWidth","mapHeight","normalMap","createRoundedRectNormalMap","poll","delayFactor","smoothFactor","transform","size","t","style","topLeft","topRight","bottomRight","bottomLeft","parseValue","value","dimension","getFirstValue","avgDimension","heightCircle","heightCircleDerivative","h","heightSquircle","inner","heightSquircleDerivative","smootherstep","smootherstepDerivative","cubicBezier","p0","p1","p2","p3","mt","cubicBezierDerivative","getBezierHeightAndDerivative","derivative","getHeightAndDerivative","d","convexH","convexD","concaveH","concaveD","blend","blendD","w","data","nx","ny","nz","alpha","cx","cy","relX","relY","innerW","innerH","distToBoundary","dirX","dirY","closestX","closestY","toEdgeX","toEdgeY","dx","dy","cornerDist","toDirX","toDirY","dirLen","sign","len","index"],"mappings":"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"}