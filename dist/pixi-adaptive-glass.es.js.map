{"version":3,"file":"pixi-adaptive-glass.es.js","sources":["../src/core/CapabilityProbe.ts","../src/core/AdaptiveQualityController.ts","../src/core/SceneRTManager.ts","../src/core/EventBus.ts","../src/materials/GlassPresets.ts","../src/panels/GlassPanel.ts","../src/geometry/height-functions.ts","../src/utils/PillGeometry.ts","../src/utils/index.ts","../src/pipelines/WebGL1Pipeline.ts","../src/shaders/webgl2.ts","../src/pipelines/WebGL2Pipeline.ts","../src/system/GlassSystem.ts","../src/hud/GlassHUD.ts","../src/overlay/light-follow.ts","../src/overlay/dom-tracking.ts","../src/geometry/distance.ts","../src/geometry/normal-map.ts","../src/GlassOverlay.ts"],"sourcesContent":["import type { CapabilityResult, CapabilityTier } from './types.js';\n\nexport class CapabilityProbe {\n  private cached?: CapabilityResult;\n\n  constructor(private readonly gl: WebGLRenderingContext | WebGL2RenderingContext) {}\n\n  run(): CapabilityResult {\n    if (this.cached) {\n      return this.cached;\n    }\n\n    const isWebGL2 = this.isWebGL2Context(this.gl);\n    const extensions = this.queryExtensions([\n      'EXT_color_buffer_float',\n      'OES_texture_float_linear',\n      'OES_standard_derivatives',\n      'EXT_disjoint_timer_query_webgl2',\n      'EXT_disjoint_timer_query',\n    ]);\n\n    const tier: CapabilityTier = isWebGL2 && this.getMaxDrawBuffers() > 1 ? 'webgl2' : 'webgl1';\n\n    this.cached = {\n      tier,\n      maxDrawBuffers: this.getMaxDrawBuffers(),\n      extensions,\n    };\n    return this.cached;\n  }\n\n  private queryExtensions(names: string[]): Record<string, boolean> {\n    return names.reduce<Record<string, boolean>>((map, name) => {\n      map[name] = Boolean(this.gl.getExtension(name));\n      return map;\n    }, {});\n  }\n\n  private getMaxDrawBuffers(): number {\n    const ext = this.gl.getExtension('WEBGL_draw_buffers');\n    const param = this.isWebGL2Context(this.gl)\n      ? this.gl.MAX_DRAW_BUFFERS\n      : ext\n        ? ext.MAX_DRAW_BUFFERS_WEBGL\n        : 0;\n    if (!param) return 1;\n    const caps = this.gl.getParameter(param) as number | null;\n    return caps ?? 1;\n  }\n\n  private isWebGL2Context(\n    gl: WebGLRenderingContext | WebGL2RenderingContext,\n  ): gl is WebGL2RenderingContext {\n    return typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\n  }\n}\n","import type { AdaptiveAction, AdaptiveDecision, RenderQualityOptions, TelemetrySample } from './types.js';\n\nconst DEFAULT_QUALITY: RenderQualityOptions = {\n  renderScale: 1,\n  enableDispersion: true,\n  enableCaustics: true,\n  enableContactShadows: true,\n  maxBlurTaps: 9,\n  edgeSupersampling: 1,\n};\n\ntype DegradationStep = {\n  check: (q: RenderQualityOptions) => boolean;\n  apply: (q: RenderQualityOptions) => void;\n  action: AdaptiveAction;\n  reason: string;\n};\n\nconst DEGRADATION_STEPS: DegradationStep[] = [\n  { check: q => q.renderScale > 0.85, apply: q => { q.renderScale = 0.85; }, action: 'scale-rt-0-85', reason: 'Frame budget exceeded' },\n  { check: q => q.renderScale > 0.7, apply: q => { q.renderScale = 0.7; }, action: 'scale-rt-0-7', reason: 'Severe perf drop' },\n  { check: q => q.maxBlurTaps > 5, apply: q => { q.maxBlurTaps = 5; }, action: 'reduce-blur', reason: 'Sustained frame drops' },\n  { check: q => q.enableDispersion, apply: q => { q.enableDispersion = false; }, action: 'disable-dispersion', reason: 'Dispersion too expensive' },\n  { check: q => q.enableCaustics || q.enableContactShadows, apply: q => { q.enableCaustics = false; q.enableContactShadows = false; }, action: 'disable-caustics', reason: 'Optional overlays disabled' },\n];\n\nexport class AdaptiveQualityController {\n  private current: RenderQualityOptions = { ...DEFAULT_QUALITY };\n  private readonly telemetry: TelemetrySample[] = [];\n  private overrides: Partial<RenderQualityOptions> = {};\n\n  constructor(private readonly targetFrameMs = 100) {}\n\n  getQuality(): RenderQualityOptions {\n    return { ...this.current };\n  }\n\n  record(sample: TelemetrySample): void {\n    this.telemetry.push(sample);\n    if (this.telemetry.length > 120) {\n      this.telemetry.shift();\n    }\n  }\n\n  setOverrides(overrides: Partial<RenderQualityOptions>): void {\n    this.overrides = { ...this.overrides, ...overrides };\n    this.current = { ...this.current, ...this.overrides };\n  }\n\n  getTelemetry(): TelemetrySample[] {\n    return [...this.telemetry];\n  }\n\n  evaluate(): AdaptiveDecision | undefined {\n    if (this.telemetry.length < 30) return undefined;\n    const avgCpu = this.telemetry.reduce((sum, s) => sum + s.cpuMs, 0) / this.telemetry.length;\n    const avgGpu = this.telemetry.reduce((sum, s) => sum + (s.gpuMs ?? s.cpuMs), 0) / this.telemetry.length;\n    if (Math.max(avgCpu, avgGpu) <= this.targetFrameMs) return undefined;\n\n    for (const step of DEGRADATION_STEPS) {\n      if (step.check(this.current)) {\n        step.apply(this.current);\n        return { action: step.action, reason: step.reason };\n      }\n    }\n    return undefined;\n  }\n}\n","import { Rectangle, RenderTexture } from 'pixi.js';\nimport type { Renderer, WebGLRenderer } from 'pixi.js';\n\ninterface RtHandles {\n  sceneColor: RenderTexture;\n  sceneDepth?: RenderTexture;\n}\n\nexport class SceneRTManager {\n  private handles?: RtHandles;\n  private scale = 1;\n  private readonly clearRect = new Rectangle();\n\n  constructor(\n    private readonly renderer: Renderer,\n    private readonly useDepth: boolean,\n  ) {}\n\n  ensure(width: number, height: number, scale: number): RtHandles {\n    const targetResolution = this.renderer.resolution * scale;\n    if (\n      !this.handles ||\n      this.handles.sceneColor.width !== width ||\n      this.handles.sceneColor.height !== height ||\n      this.handles.sceneColor.source.resolution !== targetResolution\n    ) {\n      this.dispose();\n      this.handles = {\n        sceneColor: RenderTexture.create({\n          width,\n          height,\n          resolution: targetResolution,\n          scaleMode: 'linear',\n        }),\n        sceneDepth: this.useDepth\n          ? RenderTexture.create({\n              width,\n              height,\n              resolution: targetResolution,\n              scaleMode: 'nearest',\n            })\n          : undefined,\n      };\n      this.scale = scale;\n    }\n    return this.handles;\n  }\n\n  clearTargets(): void {\n    if (!this.handles) return;\n    this.clearRect.width = this.handles.sceneColor.width;\n    this.clearRect.height = this.handles.sceneColor.height;\n    \n    const renderer = this.renderer as WebGLRenderer;\n    renderer.renderTarget.bind(this.handles.sceneColor);\n    const gl = renderer.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    if (this.handles.sceneDepth) {\n      renderer.renderTarget.bind(this.handles.sceneDepth);\n      gl.clearColor(1, 0, 0, 1); \n      gl.clearDepth(1.0);\n      gl.clear(gl.DEPTH_BUFFER_BIT);\n    }\n  }\n\n  dispose(): void {\n    this.handles?.sceneColor.destroy(true);\n    this.handles?.sceneDepth?.destroy(true);\n    this.handles = undefined;\n  }\n}\n","type Listener<T> = (payload: T) => void;\n\ntype EventMap = Record<string, unknown>;\n\nexport class EventBus<Events extends EventMap> {\n  private listeners: { [K in keyof Events]?: Set<Listener<Events[K]>> } = {};\n\n  on<K extends keyof Events>(event: K, listener: Listener<Events[K]>): void {\n    let listeners = this.listeners[event];\n    if (!listeners) {\n      listeners = new Set();\n      this.listeners[event] = listeners;\n    }\n    listeners.add(listener);\n  }\n\n  off<K extends keyof Events>(event: K, listener: Listener<Events[K]>): void {\n    this.listeners[event]?.delete(listener);\n  }\n\n  emit<K extends keyof Events>(event: K, payload: Events[K]): void {\n    const listeners = this.listeners[event];\n    if (!listeners) return;\n    for (const listener of listeners) {\n      listener(payload);\n    }\n  }\n\n  removeAll(): void {\n    for (const key of Object.keys(this.listeners) as Array<keyof Events>) {\n      this.listeners[key]?.clear();\n    }\n  }\n}\n","import type { GlassMaterial } from '../core/types.js';\n\nconst make = (material: GlassMaterial): GlassMaterial => material;\n\nexport const GlassPresets = {\n  water(): GlassMaterial {\n    return make({\n      ior: 1.333,\n      thickness: 0.6,\n      roughness: 0.1,\n      dispersion: 0.02,\n      opacity: 1.0,\n      tint: 0x9fd9ff,\n    });\n  },\n  crownGlass(): GlassMaterial {\n    return make({\n      ior: 1.52,\n      thickness: 0.8,\n      roughness: 0.05,\n      dispersion: 0.04,\n      opacity: 1.0,\n      tint: 0xffffff,\n    });\n  },\n  acrylic(): GlassMaterial {\n    return make({\n      ior: 1.49,\n      thickness: 0.7,\n      roughness: 0.12,\n      dispersion: 0.01,\n      opacity: 1.0,\n      tint: 0xf7f7f7,\n    });\n  },\n  clear(): GlassMaterial {\n    return make({\n      ior: 1.52,\n      thickness: 0.8,\n      roughness: 0.05,\n      dispersion: 0.04,\n      opacity: 1.0,\n      tint: 0xffffff,\n    });\n  },\n  fromIOR(ior: number): GlassMaterial {\n    const clamped = Math.min(Math.max(ior, 1.0), 2.0);\n    return make({\n      ior: clamped,\n      thickness: 0.75,\n      roughness: 0.08,\n      dispersion: (clamped - 1) * 0.05,\n      opacity: 1.0,\n      tint: 0xffffff,\n    });\n  },\n};\n","  import { Mesh, MeshGeometry, Shader, State } from 'pixi.js';\nimport type { Texture } from 'pixi.js';\nimport type { CapabilityTier, GlassMaterial, GlassPanelProps } from '../core/types.js';\n\nlet PANEL_COUNTER = 0;\n\n// Use MeshGeometry which auto-maps to aPosition and aUV attributes\n// Centered geometry (-0.5 to 0.5) - position is center, scale is size\nconst QUAD_GEOMETRY = new MeshGeometry({\n  positions: new Float32Array([-0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5]),\n  uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n  indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\nconst BASIC_VERT = `\nprecision mediump float;\nattribute vec2 aPosition;\nattribute vec2 aUV;\nvarying vec2 vUv;\nuniform mat3 translationMatrix;\nuniform mat3 projectionMatrix;\nuniform mat3 uTextureMatrix;\nvoid main(void){\n  vUv = aUV;\n  gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aPosition, 1.0)).xy, 0.0, 1.0);\n}\n`;\n\nconst BASIC_FRAG = `\nprecision mediump float;\nvarying vec2 vUv;\nvoid main(void){\n  gl_FragColor = vec4(vUv, 0.0, 1.0);\n}\n`;\n\nexport class GlassPanel extends Mesh {\n  id: string;\n  glassMaterial: GlassMaterial;\n  normalMap?: Texture;\n  dudvMap?: Texture;\n  causticsAtlas?: Texture;\n  sdfShadow?: Texture;\n  private tier: CapabilityTier = 'webgl1';\n\n  constructor(props: GlassPanelProps) {\n    const state = State.for2d();\n    state.culling = false; // Disable culling to avoid winding order issues\n\n    super({\n      geometry: props.geometry ?? QUAD_GEOMETRY,\n      shader: Shader.from({\n        gl: {\n          vertex: BASIC_VERT,\n          fragment: BASIC_FRAG,\n        },\n      }) as any,\n      state,\n    });\n    this.id = props.id ?? `glass-panel-${++PANEL_COUNTER}`;\n    this.glassMaterial = props.material;\n    this.normalMap = props.normalMap;\n    this.dudvMap = props.dudvMap;\n    this.causticsAtlas = props.causticsAtlas;\n    this.sdfShadow = props.sdfShadow;\n    if (props.filters) {\n      this.filters = props.filters;\n    }\n  }\n\n  setMaterial(partial: Partial<GlassMaterial>): void {\n    this.glassMaterial = { ...this.glassMaterial, ...partial };\n  }\n\n  setTextures(textures: Partial<Omit<GlassPanelProps, 'material' | 'geometry'>>): void {\n    if (textures.normalMap) this.normalMap = textures.normalMap;\n    if (textures.dudvMap) this.dudvMap = textures.dudvMap;\n    if (textures.causticsAtlas) this.causticsAtlas = textures.causticsAtlas;\n    if (textures.sdfShadow) this.sdfShadow = textures.sdfShadow;\n  }\n\n  setTier(tier: CapabilityTier): void {\n    this.tier = tier;\n  }\n\n  getTier(): CapabilityTier {\n    return this.tier;\n  }\n}\n","import type { SurfaceShape } from '../core/types.js';\n\n/**\n * Convert distance to boundary into normalized t parameter.\n * t=0 at boundary edge, t=1 at plateau/center.\n */\nexport function distanceToT(distToBoundary: number, bevel: number): number {\n  return distToBoundary / bevel;\n}\n\n// Height functions for different surface shapes\n// t is normalized distance into bevel: 0 at boundary edge, 1 at plateau\n// height goes from 0 (edge) to 1 (plateau/center)\nexport function heightCircle(t: number): number {\n  return Math.sqrt(Math.max(0, 2 * t - t * t));\n}\n\nfunction heightCircleDerivative(t: number): number {\n  const h = Math.sqrt(Math.max(0.0001, 2 * t - t * t));\n  return (1 - t) / h;\n}\n\nexport function heightSquircle(t: number): number {\n  // Superellipse with n=3 for gentler curve between circle (n=2) and box (n=infinity)\n  // Using (1 - (1-t)^3)^(1/3) for smooth gradient\n  const inner = 1 - Math.pow(1 - t, 3);\n  return Math.pow(Math.max(0, inner), 1/3);\n}\n\nfunction heightSquircleDerivative(t: number): number {\n  const inner = 1 - Math.pow(1 - t, 3);\n  if (inner <= 0.0001) return 0;\n  // d/dt of (1 - (1-t)^3)^(1/3) = (1-t)^2 / (1 - (1-t)^3)^(2/3)\n  return Math.pow(1 - t, 2) / Math.pow(inner, 2/3);\n}\n\nexport function smootherstep(t: number): number {\n  const x = Math.max(0, Math.min(1, t));\n  return x * x * x * (x * (x * 6 - 15) + 10);\n}\n\nfunction smootherstepDerivative(t: number): number {\n  const x = Math.max(0, Math.min(1, t));\n  return 30 * x * x * (x - 1) * (x - 1);\n}\n\nexport function getHeightAndDerivative(\n  t: number,\n  shape: SurfaceShape\n): { height: number; derivative: number } {\n\n  switch (shape) {\n    case 'circle': {\n      // Circle profile: 0 at edge (t=0), 1 at plateau (t=1)\n      return { height: heightCircle(t), derivative: heightCircleDerivative(t) };\n    }\n    case 'squircle': {\n      // Squircle profile: 0 at edge (t=0), 1 at plateau (t=1)\n      return { height: heightSquircle(t), derivative: heightSquircleDerivative(t) };\n    }\n    case 'concave': {\n      // Quadratic ease-in: slow start, fast finish\n      const h = t * t;\n      const d = 2 * t;\n      return { height: h, derivative: d };\n    }\n    case 'lip': {\n      // S-curve: slow start, fast middle, slow end\n      const h = t < 0.5 ? 2 * t * t : 1 - 2 * (1 - t) * (1 - t);\n      const d = t < 0.5 ? 4 * t : 4 * (1 - t);\n      return { height: h, derivative: d };\n    }\n    case 'dome': {\n      // Full hemisphere - 0 at edge (t=0), 1 at plateau (t=1)\n      const s = 1 - t;\n      const h = Math.sqrt(Math.max(0, 1 - s * s));\n      const d = s > 0.001 ? s / h : 0;\n      return { height: h, derivative: d };\n    }\n    case 'wave': {\n      // Sinusoidal wave\n      const h = (1 - Math.cos(t * Math.PI)) / 2;\n      const d = (Math.PI * Math.sin(t * Math.PI)) / 2;\n      return { height: h, derivative: d };\n    }\n    case 'flat': {\n      // No bevel, completely flat at max height\n      return { height: 1, derivative: 0 };\n    }\n    case 'ramp': {\n      // Linear test pattern - height = t, derivative = 1\n      return { height: t, derivative: 1 };\n    }\n  }\n}\n","import { MeshGeometry, Texture } from 'pixi.js';\nimport type { SurfaceShape } from '../core/types.js';\nimport { distanceToT, getHeightAndDerivative } from '../geometry/height-functions.js';\n\n/**\n * Creates a pill/stadium geometry that can expand from circle to pill shape.\n * When expansion = 0, it's a perfect circle.\n * When expansion > 0, it becomes a pill/stadium shape.\n *\n * Uses normalized coordinates (-0.5 to 0.5) like the default QUAD_GEOMETRY,\n * so panel.scale controls the actual size.\n */\nexport function createPillGeometry(\n  radius: number,\n  expansion: number = 0,\n  segments: number = 32\n): MeshGeometry {\n  const halfExpansion = expansion / 2;\n\n  // Center vertex + vertices for both semicircles\n  const vertexCount = 1 + segments;\n  const positions = new Float32Array(vertexCount * 2);\n  const uvs = new Float32Array(vertexCount * 2);\n\n  // Total dimensions - scale is applied by panel\n  const totalWidth = radius * 2 + expansion;\n  const totalHeight = radius * 2;\n\n  // Center vertex at origin\n  positions[0] = 0;\n  positions[1] = 0;\n  uvs[0] = 0.5;\n  uvs[1] = 0.5;\n\n  // Generate vertices around the perimeter\n  for (let i = 0; i < segments; i++) {\n    const angle = (i / segments) * Math.PI * 2 - Math.PI / 2;\n    const idx = (i + 1) * 2;\n\n    let x: number, y: number;\n\n    // Right semicircle (angles -90째 to 90째)\n    if (angle >= -Math.PI / 2 && angle <= Math.PI / 2) {\n      x = Math.cos(angle) * radius + halfExpansion;\n      y = Math.sin(angle) * radius;\n    }\n    // Left semicircle (angles 90째 to 270째)\n    else {\n      x = Math.cos(angle) * radius - halfExpansion;\n      y = Math.sin(angle) * radius;\n    }\n\n    // Normalize: x to -0.5..0.5 over totalWidth, y to -0.5..0.5 over totalHeight\n    // This keeps circle round when width=height, elongates when width>height\n    positions[idx] = x / totalWidth;\n    positions[idx + 1] = y / totalHeight;\n\n    // UVs: 0..1 range\n    uvs[idx] = x / totalWidth + 0.5;\n    uvs[idx + 1] = y / totalHeight + 0.5;\n  }\n\n  // Create triangle fan from center\n  const triangleCount = segments;\n  const indices = new Uint32Array(triangleCount * 3);\n\n  for (let i = 0; i < segments; i++) {\n    const triIdx = i * 3;\n    indices[triIdx] = 0; // center\n    indices[triIdx + 1] = i + 1;\n    indices[triIdx + 2] = ((i + 1) % segments) + 1;\n  }\n\n  return new MeshGeometry({\n    positions,\n    uvs,\n    indices,\n  });\n}\n\n/**\n * Updates an existing pill geometry with new expansion value.\n * More efficient than recreating the geometry.\n */\nexport function updatePillGeometry(\n  geometry: MeshGeometry,\n  radius: number,\n  expansion: number,\n  segments: number = 32\n): void {\n  const posAttr = geometry.getAttribute('aPosition');\n  const uvAttr = geometry.getAttribute('aUV');\n  if (!posAttr || !uvAttr) return;\n\n  const positions = posAttr.buffer.data as Float32Array;\n  const uvs = uvAttr.buffer.data as Float32Array;\n  const halfExpansion = expansion / 2;\n\n  const totalWidth = radius * 2 + expansion;\n  const totalHeight = radius * 2;\n\n  for (let i = 0; i < segments; i++) {\n    const angle = (i / segments) * Math.PI * 2 - Math.PI / 2;\n    const idx = (i + 1) * 2;\n\n    let x: number, y: number;\n\n    if (angle >= -Math.PI / 2 && angle <= Math.PI / 2) {\n      x = Math.cos(angle) * radius + halfExpansion;\n      y = Math.sin(angle) * radius;\n    } else {\n      x = Math.cos(angle) * radius - halfExpansion;\n      y = Math.sin(angle) * radius;\n    }\n\n    // Normalize to -0.5 to 0.5 range\n    positions[idx] = x / totalWidth;\n    positions[idx + 1] = y / totalHeight;\n\n    // UVs normalized to 0-1 range\n    uvs[idx] = (x / totalWidth) + 0.5;\n    uvs[idx + 1] = (y / totalHeight) + 0.5;\n  }\n\n  posAttr.buffer.update();\n  uvAttr.buffer.update();\n}\n\n/**\n * Creates a normal map for a pill/stadium shape with bevel effects.\n * The pill is a rectangle with semicircular caps on each end.\n */\nexport function createPillNormalMap(\n  width: number,\n  height: number,\n  expansion: number,\n  bevel: number,\n  shape: SurfaceShape,\n  invertNormals: boolean = false,\n): Texture {\n  const w = Math.ceil(width);\n  const h = Math.ceil(height);\n  const data = new Uint8Array(w * h * 4);\n\n  // Pill dimensions: height determines the radius of the caps\n  const radius = h / 2;\n  const halfExpansion = expansion / 2;\n\n  for (let y = 0; y < h; y++) {\n    for (let x = 0; x < w; x++) {\n      let nx = 0;\n      let ny = 0;\n      let nz = 1;\n      let alpha = 255;\n\n      // Use pixel centers for proper symmetry\n      const cx = (w - 1) / 2;\n      const cy = (h - 1) / 2;\n      const relX = x - cx;\n      const relY = y - cy;\n\n      // Calculate distance to pill boundary\n      let distToBoundary = 0;\n      let dirX = 0;\n      let dirY = 0;\n\n      const absX = Math.abs(relX);\n      const absY = Math.abs(relY);\n\n      if (absX <= halfExpansion) {\n        // In the rectangular middle section\n        distToBoundary = radius - absY;\n        dirX = 0;\n        dirY = relY > 0 ? 1 : -1;\n      } else {\n        // In one of the semicircular caps\n        const capCenterX = relX > 0 ? halfExpansion : -halfExpansion;\n        const dx = relX - capCenterX;\n        const dy = relY;\n        const distFromCapCenter = Math.sqrt(dx * dx + dy * dy);\n        distToBoundary = radius - distFromCapCenter;\n\n        if (distFromCapCenter > 0.001) {\n          dirX = dx / distFromCapCenter;\n          dirY = dy / distFromCapCenter;\n        }\n      }\n\n      // Hard cutoff for pixels outside the shape\n      if (distToBoundary < 0) {\n        alpha = 0;\n      }\n\n      // Apply bevel based on distance to boundary\n      if (bevel > 0 && distToBoundary < bevel && distToBoundary >= 0) {\n        const t = distanceToT(distToBoundary, bevel);\n        const { derivative } = getHeightAndDerivative(t, shape);\n        nx = dirX * derivative * 0.5;\n        ny = dirY * derivative * 0.5;\n        if (invertNormals) {\n          nx = -nx;\n          ny = -ny;\n        }\n      }\n\n      const len = Math.sqrt(nx * nx + ny * ny + nz * nz);\n      nx /= len;\n      ny /= len;\n      nz /= len;\n\n      const index = (y * w + x) * 4;\n      data[index] = ((nx * 0.5 + 0.5) * 255) | 0;\n      data[index + 1] = ((ny * 0.5 + 0.5) * 255) | 0;\n      data[index + 2] = ((nz * 0.5 + 0.5) * 255) | 0;\n      data[index + 3] = alpha;\n    }\n  }\n\n  return Texture.from({\n    resource: data,\n    width: w,\n    height: h,\n  });\n}\n","import type { EdgeMaskConfig, EdgeTactic } from '../core/types.js';\n\nexport function hexToVec3(hex: number): [number, number, number] {\n  return [\n    ((hex >> 16) & 0xff) / 255,\n    ((hex >> 8) & 0xff) / 255,\n    (hex & 0xff) / 255,\n  ];\n}\n\nexport function createDefaultEdgeTactic(overrides?: Partial<EdgeTactic>): EdgeTactic {\n  return {\n    enabled: false,\n    rangeStart: 0,\n    rangeEnd: 0.3,\n    strength: 1,\n    opacity: 1,\n    ...overrides,\n  };\n}\n\nexport function createDefaultEdgeMask(overrides?: Partial<EdgeMaskConfig>): EdgeMaskConfig {\n  return {\n    cutoff: 0.001,\n    blur: 0,\n    invert: false,\n    smoothing: createDefaultEdgeTactic({ rangeEnd: 0.3, strength: 1 }),\n    contrast: createDefaultEdgeTactic({ rangeEnd: 0.3, strength: 0.7 }),\n    alpha: createDefaultEdgeTactic({ rangeEnd: 0.2, strength: 1 }),\n    tint: createDefaultEdgeTactic({ rangeEnd: 0.5, strength: 0.5 }),\n    darken: createDefaultEdgeTactic({ rangeEnd: 0.3, strength: 0.3 }),\n    desaturate: createDefaultEdgeTactic({ rangeEnd: 0.4, strength: 0.5 }),\n    ...overrides,\n  };\n}\n\nexport { createPillGeometry, updatePillGeometry, createPillNormalMap } from './PillGeometry.js';\n","import { Filter, Sprite, Texture, GlProgram } from 'pixi.js';\nimport type { RenderTexture, Renderer } from 'pixi.js';\nimport { SceneRTManager } from '../core/SceneRTManager.js';\nimport type { RenderQualityOptions } from '../core/types.js';\nimport type { GlassPanel } from '../panels/GlassPanel.js';\nimport type { Pipeline, PipelineContext } from './BasePipeline.js';\nimport { hexToVec3 } from '../utils/index.js';\n\nclass CompatibilityFilter extends Filter {\n  constructor() {\n    const fragment = `\n      precision mediump float;\n      varying vec2 vTextureCoord;\n      uniform sampler2D uSceneColor;\n      uniform sampler2D uNormalMap;\n      uniform vec2 uInvResolution;\n      uniform float uDispersion;\n      uniform float uRoughness;\n      uniform float uDisplacementScale;\n      uniform vec3 uTint;\n      uniform float uOpacity;\n      uniform bool uEnableDispersion;\n      vec3 sampleScene(vec2 uv){\n        return texture2D(uSceneColor, clamp(uv, vec2(0.001), vec2(0.999))).rgb;\n      }\n      void main(){\n        vec3 normal = texture2D(uNormalMap, vTextureCoord).xyz * 2.0 - 1.0;\n        vec2 offset = normal.xy * uDisplacementScale;\n        vec2 baseUV = vTextureCoord + offset;\n        vec3 color = sampleScene(baseUV);\n        if(uEnableDispersion){\n          color.r = sampleScene(baseUV + offset * (1.0 + uDispersion)).r;\n          color.b = sampleScene(baseUV - offset * (1.0 + uDispersion)).b;\n        }\n        float radius = uRoughness * 4.0;\n        if(radius > 0.001){\n          vec3 blurAccum = vec3(0.0);\n          float taps = 0.0;\n          for(int i=0;i<4;i++){\n            float angle = 6.2831853 * float(i) / 4.0;\n            vec2 sampleOffset = vec2(cos(angle), sin(angle)) * radius * uInvResolution;\n            blurAccum += sampleScene(baseUV + sampleOffset);\n            taps += 1.0;\n          }\n          color = mix(color, blurAccum / max(taps, 1.0), 0.7);\n        }\n        gl_FragColor = vec4(color * uTint * uOpacity, uOpacity);\n      }\n    `;\n    super({\n      glProgram: new GlProgram({\n          vertex: `\n            attribute vec2 aVertexPosition;\n            attribute vec2 aTextureCoord;\n            uniform mat3 projectionMatrix;\n            varying vec2 vTextureCoord;\n            void main(void){\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n                vTextureCoord = aTextureCoord;\n            }\n          `,\n          fragment,\n      }),\n      resources: {\n        uSceneColor: Texture.WHITE.source,\n        uNormalMap: Texture.WHITE.source,\n        uniforms: {\n            uInvResolution: { value: [1, 1], type: 'vec2<f32>' },\n            uDispersion: { value: 0, type: 'f32' },\n            uRoughness: { value: 0, type: 'f32' },\n            uDisplacementScale: { value: 0.01, type: 'f32' },\n            uTint: { value: [1, 1, 1], type: 'vec3<f32>' },\n            uOpacity: { value: 1, type: 'f32' },\n            uEnableDispersion: { value: 0, type: 'f32' }, // boolean as float\n        }\n      },\n    });\n  }\n}\n\nexport class WebGL1Pipeline implements Pipeline {\n  readonly id = 'webgl1';\n  private readonly filter = new CompatibilityFilter();\n  private readonly rtManager: SceneRTManager;\n  private readonly blitSprite: Sprite;\n\n  constructor(private readonly renderer: Renderer) {\n    this.rtManager = new SceneRTManager(renderer, false);\n    this.blitSprite = new Sprite(Texture.WHITE);\n  }\n\n  setup(): void {}\n\n  render(context: PipelineContext): void {\n    const { renderer, panels, quality, drawOpaqueScene } = context;\n    const targets = this.rtManager.ensure(\n      renderer.screen.width,\n      renderer.screen.height,\n      quality.renderScale,\n    );\n    \n    drawOpaqueScene(targets.sceneColor);\n    \n    this.blitSprite.texture = targets.sceneColor;\n    this.blitSprite.width = renderer.screen.width;\n    this.blitSprite.height = renderer.screen.height;\n    \n    renderer.render({ container: this.blitSprite, clear: true });\n    \n    const orderedPanels = [...panels].sort((a, b) => (a.zIndex ?? 0) - (b.zIndex ?? 0));\n    for (const panel of orderedPanels) {\n      this.applyFilter(panel, targets.sceneColor, quality);\n      renderer.render({ container: panel });\n    }\n  }\n\n  dispose(): void {\n    this.rtManager.dispose();\n  }\n\n  private applyFilter(\n    panel: GlassPanel,\n    sceneTexture: RenderTexture,\n    quality: RenderQualityOptions,\n  ): void {\n    const needsFilter =\n      Boolean(panel.normalMap || panel.dudvMap) ||\n      panel.glassMaterial.dispersion > 0.001 ||\n      panel.glassMaterial.roughness > 0.001;\n    if (!needsFilter) {\n      panel.filters = null;\n      return;\n    }\n    const resources = this.filter.resources;\n    // Assign textures to resources\n    (resources as any).uSceneColor = sceneTexture.source;\n    (resources as any).uNormalMap = (panel.normalMap ?? panel.dudvMap ?? Texture.WHITE).source;\n    \n    const uniforms = (resources as any).uniforms;\n    uniforms.uInvResolution = [1 / sceneTexture.width, 1 / sceneTexture.height];\n    uniforms.uDispersion = panel.glassMaterial.dispersion;\n    uniforms.uRoughness = panel.glassMaterial.roughness;\n    uniforms.uDisplacementScale = panel.glassMaterial.thickness * 0.1;\n    uniforms.uTint = hexToVec3(panel.glassMaterial.tint ?? 0xffffff);\n    uniforms.uOpacity = panel.glassMaterial.opacity;\n    uniforms.uEnableDispersion = quality.enableDispersion && panel.glassMaterial.dispersion > 0.001 ? 1 : 0;\n    \n    panel.filters = [this.filter];\n  }\n}\n","export const fullscreenVertex = `\nprecision mediump float;\nattribute vec2 aPosition;\nattribute vec2 aUV;\nvarying vec2 vUv;\nvoid main(void){\n  vUv = aUV;\n  vec2 pos = aPosition * 2.0 - 1.0;\n  gl_Position = vec4(pos, 0.0, 1.0);\n}\n`;\n\n// JFA Seed shader - identifies edge pixels from shape mask\nexport const jfaSeedFragment = `\nprecision highp float;\nvarying vec2 vUv;\nuniform sampler2D uNormalMap;\nuniform vec2 uTexelSize;\n\nvoid main() {\n  float center = texture2D(uNormalMap, vUv).a;\n\n  // Check if this is an edge pixel (shape mask transitions)\n  bool isEdge = false;\n\n  // Sample 8 neighbors for better edge detection\n  for (int dy = -1; dy <= 1; dy++) {\n    for (int dx = -1; dx <= 1; dx++) {\n      if (dx == 0 && dy == 0) continue;\n      vec2 offset = vec2(float(dx), float(dy)) * uTexelSize;\n      float neighbor = texture2D(uNormalMap, vUv + offset).a;\n\n      // Edge if center is inside shape but any neighbor is outside\n      if (center > 0.5 && neighbor < 0.5) {\n        isEdge = true;\n        break;\n      }\n    }\n    if (isEdge) break;\n  }\n\n  // Also check UV boundaries as edges\n  if (center > 0.5) {\n    if (vUv.x < uTexelSize.x || vUv.x > 1.0 - uTexelSize.x ||\n        vUv.y < uTexelSize.y || vUv.y > 1.0 - uTexelSize.y) {\n      isEdge = true;\n    }\n  }\n\n  if (isEdge) {\n    // Store own position as seed (normalized 0-1)\n    gl_FragColor = vec4(vUv, 0.0, 1.0);\n  } else if (center > 0.5) {\n    // Inside shape but not edge - mark as needing distance calc\n    gl_FragColor = vec4(-1.0, -1.0, 0.0, 1.0);\n  } else {\n    // Outside shape\n    gl_FragColor = vec4(-1.0, -1.0, 0.0, 0.0);\n  }\n}\n`;\n\n// JFA Flood shader - propagates nearest seed positions\nexport const jfaFloodFragment = `\nprecision highp float;\nvarying vec2 vUv;\nuniform sampler2D uPrevPass;\nuniform vec2 uTexelSize;\nuniform float uStepSize;\n\nvoid main() {\n  vec4 bestSeed = texture2D(uPrevPass, vUv);\n  float bestDist = 999999.0;\n\n  // Calculate distance to current best seed\n  if (bestSeed.x >= 0.0) {\n    vec2 diff = vUv - bestSeed.xy;\n    bestDist = dot(diff, diff);\n  }\n\n  // Check 8 neighbors at current step size\n  for (int dy = -1; dy <= 1; dy++) {\n    for (int dx = -1; dx <= 1; dx++) {\n      if (dx == 0 && dy == 0) continue;\n\n      vec2 neighborUV = vUv + vec2(float(dx), float(dy)) * uStepSize * uTexelSize;\n\n      // Bounds check\n      if (neighborUV.x < 0.0 || neighborUV.x > 1.0 || neighborUV.y < 0.0 || neighborUV.y > 1.0) {\n        continue;\n      }\n\n      vec4 neighborSeed = texture2D(uPrevPass, neighborUV);\n\n      // If neighbor has a valid seed\n      if (neighborSeed.x >= 0.0) {\n        vec2 diff = vUv - neighborSeed.xy;\n        float dist = dot(diff, diff);\n\n        if (dist < bestDist) {\n          bestDist = dist;\n          bestSeed = neighborSeed;\n        }\n      }\n    }\n  }\n\n  gl_FragColor = bestSeed;\n}\n`;\n\n// JFA Distance shader - converts seed positions to actual distances\nexport const jfaDistanceFragment = `\nprecision highp float;\nvarying vec2 vUv;\nuniform sampler2D uSeedMap;\nuniform float uMaxDistance;\n\nvoid main() {\n  vec4 seed = texture2D(uSeedMap, vUv);\n\n  if (seed.x < 0.0) {\n    // No seed found (outside shape or error)\n    gl_FragColor = vec4(0.0, 0.0, 0.0, seed.a);\n    return;\n  }\n\n  // Calculate actual distance\n  vec2 diff = vUv - seed.xy;\n  float dist = length(diff);\n\n  // Normalize to 0-1 range based on max distance\n  float normalizedDist = clamp(dist / uMaxDistance, 0.0, 1.0);\n\n  gl_FragColor = vec4(normalizedDist, normalizedDist, normalizedDist, seed.a);\n}\n`;\n\nexport const panelVertex = `\nprecision mediump float;\nattribute vec2 aPosition;\nattribute vec2 aUV;\nvarying vec2 vUv;\nuniform vec2 uPosition;\nuniform vec2 uScale;\nuniform vec2 uResolution;\nvoid main(void){\n  vUv = aUV;\n  vec2 worldPos = aPosition * uScale + uPosition;\n  vec2 clipPos = (worldPos / uResolution) * 2.0 - 1.0;\n  gl_Position = vec4(clipPos, 0.0, 1.0);\n}\n`;\n\nexport const refractionFragment = `\nprecision highp float;\nvarying vec2 vUv;\nuniform sampler2D uSceneColor;\nuniform sampler2D uNormalMap;\nuniform sampler2D uCausticsMap;\nuniform sampler2D uDistanceField;\nuniform vec2 uInvResolution;\nuniform float uIOR;\nuniform float uThickness;\nuniform float uDispersion;\nuniform float uRoughness;\nuniform float uOpacity;\nuniform bool uEnableDispersion;\nuniform bool uEnableCaustics;\nuniform vec3 uTint;\nuniform float uSpecular;\nuniform float uShininess;\nuniform float uShadow;\nuniform vec3 uLightDir;\nuniform float uBlurSamples;\nuniform float uBlurSpread;\nuniform float uBlurAngle;\nuniform float uBlurAnisotropy;\nuniform float uBlurGamma;\nuniform float uAberrationR;\nuniform float uAberrationB;\nuniform float uAO;\nuniform float uAORadius;\nuniform float uNoiseScale;\nuniform float uNoiseIntensity;\nuniform float uNoiseRotation;\nuniform float uNoiseThreshold;\nuniform float uEdgeSupersampling;\nuniform float uGlassSupersampling;\nuniform vec4 uEdgeIor; // rangeStart, rangeEnd, strength, enabled\nuniform vec2 uPanelSize;\n\n// Edge mask system\nuniform float uEdgeMaskCutoff;\nuniform float uEdgeMaskBlur;\nuniform bool uEdgeMaskInvert;\n\n// Edge tactics: vec4(rangeStart, rangeEnd, strength, opacity)\nuniform vec4 uEdgeSmoothing;\nuniform vec4 uEdgeContrast;\nuniform vec4 uEdgeAlpha;\nuniform vec4 uEdgeTint;\nuniform vec4 uEdgeDarken;\nuniform vec4 uEdgeDesaturate;\n\n// Tactic enable flags\nuniform bool uEnableSmoothing;\nuniform bool uEnableContrast;\nuniform bool uEnableAlpha;\nuniform bool uEnableTint;\nuniform bool uEnableDarken;\nuniform bool uEnableDesaturate;\n// Debug mode: 0=off, 1=edgeDist, 2=shapeMask, 3=normals\nuniform float uDebugMode;\n\n// Simple value noise\nfloat hash(vec2 p) {\n  return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat valueNoise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  f = f * f * (3.0 - 2.0 * f); // smoothstep\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n  return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nvec2 rotateUV(vec2 uv, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\n}\n\nvec3 sampleScene(vec2 uv){\n  return texture2D(uSceneColor, clamp(uv, vec2(0.001), vec2(0.999))).rgb;\n}\n\nvec3 sampleDispersion(vec2 baseUV, vec2 offset){\n  if(!uEnableDispersion){\n    return sampleScene(baseUV + offset);\n  }\n  vec3 result;\n  result.r = sampleScene(baseUV + offset * (1.0 + uDispersion * uAberrationR)).r;\n  result.g = sampleScene(baseUV + offset).g;\n  result.b = sampleScene(baseUV + offset * (1.0 - uDispersion * uAberrationB)).b;\n  return result;\n}\n\nvec3 sampleFrostedColor(vec2 baseUV, vec2 offset){\n  float radius = uRoughness * uBlurSpread;\n  vec3 accum = vec3(0.0);\n  float totalWeight = 0.0;\n  int samples = int(uBlurSamples);\n\n  // Golden angle spiral for better sample distribution\n  float goldenAngle = 2.39996323;\n\n  // Directional blur rotation matrix\n  float ca = cos(uBlurAngle);\n  float sa = sin(uBlurAngle);\n\n  for(int i=0;i<32;i++){\n    if(i >= samples) break;\n\n    // Normalized distance from center (0 to 1)\n    float t = float(i) / float(samples - 1);\n\n    // Apply gamma curve to sample distribution\n    float curvedT = pow(t, uBlurGamma);\n    float r = curvedT * radius;\n\n    float angle = float(i) * goldenAngle;\n    vec2 dir = vec2(cos(angle), sin(angle));\n\n    // Apply anisotropy (stretch in one direction)\n    if(uBlurAnisotropy > 0.001){\n      // Rotate to blur angle, apply stretch, rotate back\n      vec2 rotated = vec2(ca * dir.x + sa * dir.y, -sa * dir.x + ca * dir.y);\n      rotated.y *= (1.0 - uBlurAnisotropy);\n      dir = vec2(ca * rotated.x - sa * rotated.y, sa * rotated.x + ca * rotated.y);\n    }\n\n    vec2 sampleOffset = dir * r * uInvResolution;\n\n    // Weight samples by distance (softer falloff)\n    float w = 1.0 - curvedT * 0.5;\n    accum += sampleDispersion(baseUV, offset + sampleOffset) * w;\n    totalWeight += w;\n  }\n  return accum / max(totalWeight, 1.0);\n}\n\n// Apply a tactic based on edge mask value\n// Returns a factor in [0, 1] based on mask position within tactic range\n// mask: 0 at edge, 1 at center\n// rangeStart/rangeEnd: define the mask region where effect applies (0=edge, 1=center)\nfloat applyTactic(vec4 tactic, float mask) {\n  float rangeStart = tactic.x;\n  float rangeEnd = tactic.y;\n  float strength = tactic.z;\n  float opacity = tactic.w;\n\n  // Effect is full (1.0) when mask < rangeStart\n  // Effect fades to 0 as mask approaches rangeEnd\n  // Effect is 0 when mask > rangeEnd\n  float t = 1.0 - smoothstep(rangeStart, rangeEnd, mask);\n\n  // Apply strength and opacity\n  return t * strength * opacity;\n}\n\n// Calculate edge distance mask from shape mask (0 at edges, 1 at center)\n// Uses sampling to find distance to nearest edge of the shape\nfloat calculateEdgeMask(vec2 uv, sampler2D normalMap) {\n  // Sample in multiple directions to find distance to edge\n  float minDist = 1.0;\n\n  // Check 8 directions for coverage\n  for (int i = 0; i < 8; i++) {\n    float angle = float(i) * 0.785398; // PI/4\n    vec2 dir = vec2(cos(angle), sin(angle));\n\n    // March along direction with fine steps (0-30% of distance to center)\n    for (int step = 1; step <= 512; step++) {\n      float t = float(step) / 512.0 * 0.15; // Max 0.15 in UV space (30% of 0.5)\n      vec2 sampleUV = uv + dir * t;\n\n      // Check bounds\n      if (sampleUV.x < 0.0 || sampleUV.x > 1.0 || sampleUV.y < 0.0 || sampleUV.y > 1.0) {\n        minDist = min(minDist, t);\n        break;\n      }\n\n      // Check shape mask\n      float mask = texture2D(normalMap, sampleUV).a;\n      if (mask < 0.5) {\n        minDist = min(minDist, t);\n        break;\n      }\n    }\n  }\n\n  // Normalize to 0-1 range (0 at edge, 1 when dist >= 0.15)\n  return clamp(minDist / 0.15, 0.0, 1.0);\n}\n\nvoid main(){\n  vec2 screenUV = gl_FragCoord.xy * uInvResolution;\n\n  vec4 normalSample = texture2D(uNormalMap, vUv);\n  float shapeMask = normalSample.a;\n\n  // Discard pixels outside the shape (border radius) - skip when in debug mode\n  if (shapeMask < 0.5 && uDebugMode < 0.5) {\n    discard;\n  }\n\n  // Get edge distance from pre-computed JFA distance field (0 at edges, 1 at center)\n  float edgeDist = texture2D(uDistanceField, vUv).r;\n\n  // Optionally blur the edge distance\n  if (uEdgeMaskBlur > 0.0) {\n    float blurredDist = 0.0;\n    float blurWeight = 0.0;\n    float blurSize = uEdgeMaskBlur * 0.01;\n    for (int x = -2; x <= 2; x++) {\n      for (int y = -2; y <= 2; y++) {\n        vec2 offset = vec2(float(x), float(y)) * blurSize;\n        float sampleDist = texture2D(uDistanceField, vUv + offset).r;\n        float weight = 1.0 - length(vec2(float(x), float(y))) * 0.2;\n        blurredDist += sampleDist * weight;\n        blurWeight += weight;\n      }\n    }\n    edgeDist = blurredDist / blurWeight;\n  }\n\n  // Optionally invert the edge distance\n  if (uEdgeMaskInvert) {\n    edgeDist = 1.0 - edgeDist;\n  }\n\n  // Debug modes (early exit)\n  if (uDebugMode > 0.5) {\n    if (uDebugMode < 1.5) {\n      // Mode 1: Edge distance (black at edges, white at center)\n      gl_FragColor = vec4(vec3(edgeDist), 1.0);\n    } else if (uDebugMode < 2.5) {\n      // Mode 2: Shape mask (border radius alpha)\n      gl_FragColor = vec4(vec3(shapeMask), 1.0);\n    } else {\n      // Mode 3: Normal map visualization\n      gl_FragColor = vec4(normalSample.rgb, 1.0);\n    }\n    return;\n  }\n\n  // Simple refraction offset based on normal map\n  vec2 normal = normalSample.xy * 2.0 - 1.0;\n\n  // Calculate edge factors for each tactic\n  float smoothingFactor = uEnableSmoothing ? applyTactic(uEdgeSmoothing, edgeDist) : 0.0;\n  float contrastFactor = uEnableContrast ? applyTactic(uEdgeContrast, edgeDist) : 0.0;\n  float alphaFactor = uEnableAlpha ? applyTactic(uEdgeAlpha, edgeDist) : 0.0;\n  float tintFactor = uEnableTint ? applyTactic(uEdgeTint, edgeDist) : 0.0;\n  float darkenFactor = uEnableDarken ? applyTactic(uEdgeDarken, edgeDist) : 0.0;\n  float desaturateFactor = uEnableDesaturate ? applyTactic(uEdgeDesaturate, edgeDist) : 0.0;\n\n  // Apply noise distortion to normal (anchored to container via vUv)\n  if (uNoiseIntensity > 0.001) {\n    vec2 noiseUV = rotateUV(vUv * uNoiseScale, uNoiseRotation * 3.14159 / 180.0);\n    float n = valueNoise(noiseUV);\n    float n2 = valueNoise(noiseUV + vec2(100.0, 100.0));\n    // Apply threshold\n    n = smoothstep(uNoiseThreshold, 1.0, n) * (1.0 - uNoiseThreshold) + n * uNoiseThreshold;\n    n2 = smoothstep(uNoiseThreshold, 1.0, n2) * (1.0 - uNoiseThreshold) + n2 * uNoiseThreshold;\n    vec2 noiseNormal = (vec2(n, n2) - 0.5) * 2.0 * uNoiseIntensity;\n    normal += noiseNormal;\n  }\n\n  // Attenuate IOR effect at edges to prevent harsh distortion\n  float effectiveIOR = uIOR;\n  if (uEdgeIor.w > 0.5) {\n    // Apply tactic: reduce IOR at edges based on range and strength\n    float iorFactor = 1.0 - smoothstep(uEdgeIor.x, uEdgeIor.y, edgeDist);\n    effectiveIOR = mix(uIOR, 1.0, iorFactor * uEdgeIor.z);\n  }\n  vec2 offset = normal * uThickness * 0.1 * (effectiveIOR - 1.0);\n\n  vec3 refracted;\n  if (uGlassSupersampling > 1.0) {\n    // Supersample the entire glass panel\n    vec3 ssColor = vec3(0.0);\n    int samples = int(uGlassSupersampling * uGlassSupersampling);\n    float ssStep = 1.0 / uGlassSupersampling;\n    int sampleIdx = 0;\n    for (int x = 0; x < 4; x++) {\n      if (x >= int(uGlassSupersampling)) break;\n      for (int y = 0; y < 4; y++) {\n        if (y >= int(uGlassSupersampling)) break;\n        vec2 ssOffset = (vec2(float(x), float(y)) * ssStep - 0.5 + ssStep * 0.5) * uInvResolution;\n        ssColor += sampleFrostedColor(screenUV + ssOffset, offset);\n        sampleIdx++;\n      }\n    }\n    refracted = ssColor / float(sampleIdx);\n  } else {\n    refracted = sampleFrostedColor(screenUV, offset);\n  }\n  // Apply tint as color mix instead of multiply to preserve visibility\n  float tintStrength = 0.3;\n  refracted = mix(refracted, refracted * uTint + uTint * 0.1, tintStrength);\n\n  // Calculate lighting from normal map (now includes noise)\n  vec3 N = normalize(vec3(normal, normalSample.b * 2.0 - 1.0));\n  float NdotL = max(0.0, dot(N, normalize(uLightDir)));\n\n  // Specular highlight (Blinn-Phong)\n  vec3 viewDir = vec3(0.0, 0.0, 1.0);\n  vec3 halfDir = normalize(normalize(uLightDir) + viewDir);\n  float spec = pow(max(0.0, dot(N, halfDir)), uShininess) * uSpecular;\n\n  // Shadow from normal facing away from light\n  float shadowFactor = 1.0 - uShadow * (1.0 - NdotL);\n\n  // Ambient occlusion based on normal length (darker at edges/outside)\n  float normalDist = length(normal);\n  float aoFactor = 1.0 - uAO * smoothstep(0.0, uAORadius, normalDist);\n\n  // Apply lighting\n  refracted = refracted * shadowFactor * aoFactor + vec3(spec);\n\n  // Apply modular edge tactics\n\n  // Smoothing: reduce sharpness at edges by blending toward grey\n  if (uEnableSmoothing && smoothingFactor > 0.0) {\n    float lum = dot(refracted, vec3(0.299, 0.587, 0.114));\n    refracted = mix(refracted, vec3(lum), smoothingFactor * 0.5);\n  }\n\n  // Contrast reduction at edges\n  if (uEnableContrast && contrastFactor > 0.0) {\n    float contrastMult = 1.0 - contrastFactor * 0.5;\n    refracted *= contrastMult;\n  }\n\n  // Darken edges (vignette effect)\n  if (uEnableDarken && darkenFactor > 0.0) {\n    refracted *= (1.0 - darkenFactor * 0.7);\n  }\n\n  // Desaturate edges\n  if (uEnableDesaturate && desaturateFactor > 0.0) {\n    float luma = dot(refracted, vec3(0.299, 0.587, 0.114));\n    refracted = mix(refracted, vec3(luma), desaturateFactor);\n  }\n\n  // Tint opacity at edges\n  if (uEnableTint && tintFactor > 0.0) {\n    refracted = mix(refracted, refracted * uTint, tintFactor);\n  }\n\n  // Alpha falloff at edges\n  float finalAlpha = 1.0;\n  if (uEnableAlpha && alphaFactor > 0.0) {\n    finalAlpha = 1.0 - alphaFactor;\n  }\n\n  gl_FragColor = vec4(refracted, finalAlpha);\n}\n`;\n\nexport const revealageFragment = `\nprecision mediump float;\nvarying vec2 vUv;\nuniform sampler2D uNormalMap;\nuniform float uOpacity;\nvoid main(){\n  vec4 normalSample = texture2D(uNormalMap, vUv);\n  float mask = normalSample.a;\n\n  // Discard pixels outside the masked area (border radius)\n  if (mask < 0.01) {\n    discard;\n  }\n\n  float alpha = uOpacity * mask;\n  float revealage = exp(-3.0 * alpha);\n  gl_FragColor = vec4(revealage);\n}\n`;\n\nexport const compositeFragment = `\nprecision mediump float;\nvarying vec2 vUv;\nuniform sampler2D uSceneColor;\nuniform sampler2D uAccum;\nuniform sampler2D uReveal;\nvoid main(){\n  vec4 accum = texture2D(uAccum, vUv);\n  vec3 scene = texture2D(uSceneColor, vUv).rgb;\n\n  // Simple alpha blend: accum.a is opacity\n  vec3 result = mix(scene, accum.rgb, accum.a);\n  gl_FragColor = vec4(result, 1.0);\n}\n`;\n","import {\n  Container,\n  Mesh,\n  MeshGeometry,\n  RenderTexture,\n  Shader,\n  Sprite,\n  State,\n  Texture,\n  UniformGroup,\n} from 'pixi.js';\nimport type { Renderer } from 'pixi.js';\nimport { SceneRTManager } from '../core/SceneRTManager.js';\nimport type { GlassPanel } from '../panels/GlassPanel.js';\nimport {\n  compositeFragment,\n  fullscreenVertex,\n  jfaDistanceFragment,\n  jfaFloodFragment,\n  jfaSeedFragment,\n  panelVertex,\n  refractionFragment,\n  revealageFragment,\n} from '../shaders/webgl2.js';\nimport type { Pipeline, PipelineContext } from './BasePipeline.js';\nimport type { RenderQualityOptions } from '../core/types.js';\nimport { hexToVec3 } from '../utils/index.js';\n\n// Fullscreen quad with 0..1 positions for clip space mapping\nconst QUAD_GEOMETRY = new MeshGeometry({\n  positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n  uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n  indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n// Cache entry for JFA distance field per panel\ninterface JFACache {\n  distanceField: RenderTexture;\n  normalMapId: number; // Track which normal map was used\n  normalMapUpdateId: number; // Track texture updates\n  width: number;\n  height: number;\n}\n\nexport class WebGL2Pipeline implements Pipeline {\n  readonly id = 'webgl2';\n  private readonly rtManager: SceneRTManager;\n  private readonly refractShader: Shader;\n  private readonly revealageShader: Shader;\n  private readonly compositeShader: Shader;\n  private readonly fullScreenQuad: Mesh<MeshGeometry, Shader>;\n  private readonly shadowSprite: Sprite;\n  private readonly panelParent: Container;\n  private compositeRT?: RenderTexture;\n  private readonly compositeSprite: Sprite;\n  private accumRT?: RenderTexture;\n  private revealRT?: RenderTexture;\n\n  // JFA shaders and cache\n  private readonly jfaSeedShader: Shader;\n  private readonly jfaFloodShader: Shader;\n  private readonly jfaDistanceShader: Shader;\n  private jfaPingRT?: RenderTexture;\n  private jfaPongRT?: RenderTexture;\n  private readonly jfaCache: Map<GlassPanel, JFACache> = new Map();\n\n  constructor(\n    private readonly renderer: Renderer,\n    useDepth: boolean,\n  ) {\n    this.rtManager = new SceneRTManager(renderer, useDepth);\n    const refractUniforms = new UniformGroup({\n      uPosition: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n      uScale: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uResolution: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uInvResolution: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uIOR: { value: 1, type: 'f32' },\n      uThickness: { value: 1, type: 'f32' },\n      uDispersion: { value: 0, type: 'f32' },\n      uRoughness: { value: 0, type: 'f32' },\n      uOpacity: { value: 1, type: 'f32' },\n      uEnableDispersion: { value: 0, type: 'f32' },\n      uEnableCaustics: { value: 0, type: 'f32' },\n      uTint: { value: new Float32Array([1, 1, 1]), type: 'vec3<f32>' },\n      uSpecular: { value: 0, type: 'f32' },\n      uShininess: { value: 32, type: 'f32' },\n      uShadow: { value: 0, type: 'f32' },\n      uLightDir: { value: new Float32Array([0.5, 0.5, 1]), type: 'vec3<f32>' },\n      uBlurSamples: { value: 8, type: 'f32' },\n      uBlurSpread: { value: 4, type: 'f32' },\n      uBlurAngle: { value: 0, type: 'f32' },\n      uBlurAnisotropy: { value: 0, type: 'f32' },\n      uBlurGamma: { value: 1, type: 'f32' },\n      uAberrationR: { value: 1, type: 'f32' },\n      uAberrationB: { value: 1, type: 'f32' },\n      uAO: { value: 0, type: 'f32' },\n      uAORadius: { value: 0.5, type: 'f32' },\n      uNoiseScale: { value: 20, type: 'f32' },\n      uNoiseIntensity: { value: 0, type: 'f32' },\n      uNoiseRotation: { value: 0, type: 'f32' },\n      uNoiseThreshold: { value: 0, type: 'f32' },\n      uEdgeSupersampling: { value: 1, type: 'f32' },\n      uGlassSupersampling: { value: 1, type: 'f32' },\n      uEdgeIor: { value: new Float32Array([0, 0.15, 1, 1]), type: 'vec4<f32>' }, // rangeStart, rangeEnd, strength, enabled\n      uPanelSize: { value: new Float32Array([200, 200]), type: 'vec2<f32>' },\n      // Edge mask system\n      uEdgeMaskCutoff: { value: 0.001, type: 'f32' },\n      uEdgeMaskBlur: { value: 0, type: 'f32' },\n      uEdgeMaskInvert: { value: 0, type: 'f32' },\n      // Edge tactics: vec4(rangeStart, rangeEnd, strength, opacity)\n      uEdgeSmoothing: { value: new Float32Array([0, 0.3, 1, 1]), type: 'vec4<f32>' },\n      uEdgeContrast: { value: new Float32Array([0, 0.3, 0.7, 1]), type: 'vec4<f32>' },\n      uEdgeAlpha: { value: new Float32Array([0, 0.2, 1, 1]), type: 'vec4<f32>' },\n      uEdgeTint: { value: new Float32Array([0, 0.5, 0.5, 1]), type: 'vec4<f32>' },\n      uEdgeDarken: { value: new Float32Array([0, 0.3, 0.3, 1]), type: 'vec4<f32>' },\n      uEdgeDesaturate: { value: new Float32Array([0, 0.4, 0.5, 1]), type: 'vec4<f32>' },\n      // Tactic enables\n      uEnableSmoothing: { value: 0, type: 'f32' },\n      uEnableContrast: { value: 0, type: 'f32' },\n      uEnableAlpha: { value: 0, type: 'f32' },\n      uEnableTint: { value: 0, type: 'f32' },\n      uEnableDarken: { value: 0, type: 'f32' },\n      uEnableDesaturate: { value: 0, type: 'f32' },\n      uDebugMode: { value: 0, type: 'f32' },\n    });\n    this.refractShader = Shader.from({\n      gl: { vertex: panelVertex, fragment: refractionFragment },\n      resources: {\n        uSceneColor: Texture.WHITE.source,\n        uNormalMap: Texture.WHITE.source,\n        uCausticsMap: Texture.WHITE.source,\n        uDistanceField: Texture.WHITE.source,\n        panelUniforms: refractUniforms,\n      },\n    });\n    const revealUniforms = new UniformGroup({\n      uPosition: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n      uScale: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uResolution: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uOpacity: { value: 1, type: 'f32' },\n    });\n    this.revealageShader = Shader.from({\n      gl: { vertex: panelVertex, fragment: revealageFragment },\n      resources: {\n        uNormalMap: Texture.WHITE.source,\n        panelUniforms: revealUniforms,\n      },\n    });\n    this.compositeShader = Shader.from({\n      gl: { vertex: fullscreenVertex, fragment: compositeFragment },\n      resources: {\n        uSceneColor: Texture.WHITE.source,\n        uAccum: Texture.WHITE.source,\n        uReveal: Texture.WHITE.source,\n      },\n    });\n    this.fullScreenQuad = new Mesh({\n      geometry: QUAD_GEOMETRY,\n      shader: this.compositeShader,\n    });\n    this.fullScreenQuad.state = State.for2d();\n    this.fullScreenQuad.state.culling = false; // Disable culling\n    this.shadowSprite = new Sprite(Texture.WHITE);\n    this.panelParent = new Container();\n    this.panelParent.alpha = 1;\n    this.compositeSprite = new Sprite(Texture.EMPTY);\n    // Ensure composite sprite is visible and on top\n    this.compositeSprite.position.set(0, 0);\n    this.compositeSprite.visible = true;\n    this.compositeSprite.alpha = 1;\n    this.compositeSprite.zIndex = 9999; // Force on top\n\n    // JFA shaders\n    const jfaSeedUniforms = new UniformGroup({\n      uTexelSize: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n    });\n    this.jfaSeedShader = Shader.from({\n      gl: { vertex: fullscreenVertex, fragment: jfaSeedFragment },\n      resources: {\n        uNormalMap: Texture.WHITE.source,\n        jfaUniforms: jfaSeedUniforms,\n      },\n    });\n\n    const jfaFloodUniforms = new UniformGroup({\n      uTexelSize: { value: new Float32Array([1, 1]), type: 'vec2<f32>' },\n      uStepSize: { value: 1, type: 'f32' },\n    });\n    this.jfaFloodShader = Shader.from({\n      gl: { vertex: fullscreenVertex, fragment: jfaFloodFragment },\n      resources: {\n        uPrevPass: Texture.WHITE.source,\n        jfaUniforms: jfaFloodUniforms,\n      },\n    });\n\n    const jfaDistanceUniforms = new UniformGroup({\n      uMaxDistance: { value: 0.15, type: 'f32' },\n    });\n    this.jfaDistanceShader = Shader.from({\n      gl: { vertex: fullscreenVertex, fragment: jfaDistanceFragment },\n      resources: {\n        uSeedMap: Texture.WHITE.source,\n        jfaUniforms: jfaDistanceUniforms,\n      },\n    });\n  }\n\n  setup(): void {}\n\n  render(context: PipelineContext): void {\n    const { renderer, panels, quality, drawOpaqueScene } = context;\n    const width = renderer.screen.width;\n    const height = renderer.screen.height;\n    const targets = this.rtManager.ensure(width, height, quality.renderScale);\n    this.ensureAccumTargets(width, height);\n    this.ensureCompositeTarget(width, height);\n\n    drawOpaqueScene(targets.sceneColor);\n\n    this.clearTarget(this.accumRT, 0, 0, 0, 0);\n    this.clearTarget(this.revealRT, 1, 1, 1, 1);\n\n    for (const panel of panels) {\n      this.renderPanel(panel, quality, targets.sceneColor);\n    }\n\n    this.fullScreenQuad.shader = this.compositeShader;\n    (this.compositeShader as any).resources.uSceneColor = targets.sceneColor.source;\n    (this.compositeShader as any).resources.uAccum = this.accumRT?.source;\n    (this.compositeShader as any).resources.uReveal = this.revealRT?.source;\n\n    this.fullScreenQuad.width = renderer.screen.width;\n    this.fullScreenQuad.height = renderer.screen.height;\n\n    this.fullScreenQuad.updateLocalTransform();\n    this.fullScreenQuad.worldTransform.copyFrom(this.fullScreenQuad.localTransform);\n\n    // Render composite quad to texture\n    renderer.render({ container: this.fullScreenQuad, target: this.compositeRT, clear: true });\n\n    if (this.compositeRT) {\n      this.compositeSprite.texture = this.compositeRT;\n      this.compositeSprite.width = width;\n      this.compositeSprite.height = height;\n      this.compositeSprite.visible = true;\n    }\n\n    this.renderContactShadows(panels, quality);\n  }\n\n  dispose(): void {\n    this.rtManager.dispose();\n    this.accumRT?.destroy(true);\n    this.revealRT?.destroy(true);\n    this.compositeRT?.destroy(true);\n    this.jfaPingRT?.destroy(true);\n    this.jfaPongRT?.destroy(true);\n    for (const cache of this.jfaCache.values()) {\n      cache.distanceField.destroy(true);\n    }\n    this.jfaCache.clear();\n  }\n\n  // Compute JFA distance field for a panel's normal map\n  private computeDistanceField(panel: GlassPanel): RenderTexture {\n    const normalMap = panel.normalMap ?? Texture.WHITE;\n    const width = normalMap.width;\n    const height = normalMap.height;\n    const normalMapId = (normalMap.source as any).uid ?? 0;\n    const normalMapUpdateId = (normalMap.source as any)._updateID ?? (normalMap.source as any).updateId ?? 0;\n\n    // Check cache\n    const cached = this.jfaCache.get(panel);\n    if (cached && cached.normalMapId === normalMapId && cached.normalMapUpdateId === normalMapUpdateId && cached.width === width && cached.height === height) {\n      return cached.distanceField;\n    }\n\n    // Ensure ping-pong textures\n    if (!this.jfaPingRT || this.jfaPingRT.width !== width || this.jfaPingRT.height !== height) {\n      this.jfaPingRT?.destroy(true);\n      this.jfaPongRT?.destroy(true);\n      this.jfaPingRT = RenderTexture.create({ width, height, resolution: 1 });\n      this.jfaPongRT = RenderTexture.create({ width, height, resolution: 1 });\n    }\n\n    // Create or reuse distance field texture\n    let distanceField = cached?.distanceField;\n    if (!distanceField || distanceField.width !== width || distanceField.height !== height) {\n      distanceField?.destroy(true);\n      distanceField = RenderTexture.create({ width, height, resolution: 1 });\n    }\n\n    const texelSize = [1 / width, 1 / height];\n\n    // Step 1: Seed pass\n    const seedResources = (this.jfaSeedShader as any).resources;\n    seedResources.uNormalMap = normalMap.source;\n    const seedUniforms = seedResources.jfaUniforms?.uniforms;\n    if (seedUniforms) {\n      seedUniforms.uTexelSize[0] = texelSize[0];\n      seedUniforms.uTexelSize[1] = texelSize[1];\n    }\n\n    this.fullScreenQuad.shader = this.jfaSeedShader;\n    this.fullScreenQuad.width = 1;\n    this.fullScreenQuad.height = 1;\n    this.fullScreenQuad.updateLocalTransform();\n    this.fullScreenQuad.worldTransform.copyFrom(this.fullScreenQuad.localTransform);\n    this.renderer.render({ container: this.fullScreenQuad, target: this.jfaPingRT, clear: true });\n\n    // Step 2: Flood passes (log2 iterations)\n    const maxDim = Math.max(width, height);\n    const passes = Math.ceil(Math.log2(maxDim));\n    let readRT: RenderTexture = this.jfaPingRT!;\n    let writeRT: RenderTexture = this.jfaPongRT!;\n\n    const floodResources = (this.jfaFloodShader as any).resources;\n    const floodUniforms = floodResources.jfaUniforms?.uniforms;\n\n    for (let i = 0; i < passes; i++) {\n      const stepSize = Math.pow(2, passes - i - 1);\n\n      floodResources.uPrevPass = readRT.source;\n      if (floodUniforms) {\n        floodUniforms.uTexelSize[0] = texelSize[0];\n        floodUniforms.uTexelSize[1] = texelSize[1];\n        floodUniforms.uStepSize = stepSize;\n      }\n\n      this.fullScreenQuad.shader = this.jfaFloodShader;\n      this.renderer.render({ container: this.fullScreenQuad, target: writeRT, clear: true });\n\n      // Swap\n      const temp = readRT;\n      readRT = writeRT;\n      writeRT = temp;\n    }\n\n    // Step 3: Distance pass\n    const distResources = (this.jfaDistanceShader as any).resources;\n    distResources.uSeedMap = readRT.source;\n    const distUniforms = distResources.jfaUniforms?.uniforms;\n    if (distUniforms) {\n      distUniforms.uMaxDistance = 0.05; // Smaller = more detail in edge gradient\n    }\n\n    this.fullScreenQuad.shader = this.jfaDistanceShader;\n    this.renderer.render({ container: this.fullScreenQuad, target: distanceField, clear: true });\n\n\n    // Cache result\n    this.jfaCache.set(panel, {\n      distanceField,\n      normalMapId,\n      normalMapUpdateId,\n      width,\n      height,\n    });\n\n    return distanceField;\n  }\n\n  private ensureAccumTargets(width: number, height: number): void {\n    const targetResolution = this.renderer.resolution;\n    if (!this.accumRT || this.accumRT.width !== width || this.accumRT.height !== height || this.accumRT.source.resolution !== targetResolution) {\n      this.accumRT?.destroy(true);\n      this.accumRT = RenderTexture.create({\n        width,\n        height,\n        resolution: targetResolution,\n      });\n    }\n    if (!this.revealRT || this.revealRT.width !== width || this.revealRT.height !== height || this.revealRT.source.resolution !== targetResolution) {\n      this.revealRT?.destroy(true);\n      this.revealRT = RenderTexture.create({\n        width,\n        height,\n        resolution: targetResolution,\n      });\n    }\n  }\n\n  private clearTarget(\n    target: RenderTexture | undefined,\n    r: number,\n    g: number,\n    b: number,\n    a: number,\n  ): void {\n    if (!target) return;\n    const dummy = new Container();\n    this.renderer.render({ container: dummy, target, clear: true, clearColor: [r, g, b, a] });\n  }\n\n  private renderPanel(\n    panel: GlassPanel,\n    quality: RenderQualityOptions,\n    sceneTarget: RenderTexture,\n  ): void {\n    if (!this.accumRT || !this.revealRT) return;\n    const normal = panel.normalMap ?? Texture.WHITE;\n    const screenWidth = this.renderer.screen.width;\n    const screenHeight = this.renderer.screen.height;\n\n    // Compute JFA distance field for this panel\n    const distanceField = this.computeDistanceField(panel);\n\n    const resources = (this.refractShader as any).resources;\n    if (resources) {\n      resources.uSceneColor = sceneTarget.source;\n      resources.uNormalMap = normal.source;\n      resources.uCausticsMap = (panel.causticsAtlas ?? Texture.WHITE).source;\n      resources.uDistanceField = distanceField.source;\n\n      // Update uniforms through UniformGroup in v8\n      const uniforms = resources.panelUniforms?.uniforms;\n      if (uniforms) {\n        // Use accumRT resolution since gl_FragCoord is in accumRT pixel space\n        const res = this.accumRT?.source?._resolution ?? this.renderer.resolution;\n        uniforms.uPosition[0] = panel.position.x;\n        uniforms.uPosition[1] = panel.position.y;\n        uniforms.uScale[0] = panel.scale.x;\n        uniforms.uScale[1] = panel.scale.y;\n        uniforms.uResolution[0] = screenWidth;\n        uniforms.uResolution[1] = screenHeight;\n        uniforms.uInvResolution[0] = 1 / (screenWidth * res);\n        uniforms.uInvResolution[1] = 1 / (screenHeight * res);\n        uniforms.uIOR = panel.glassMaterial.ior;\n        uniforms.uThickness = panel.glassMaterial.thickness;\n        uniforms.uDispersion = panel.glassMaterial.dispersion;\n        uniforms.uRoughness = panel.glassMaterial.roughness;\n        uniforms.uOpacity = panel.glassMaterial.opacity ?? 1;\n        uniforms.uEnableDispersion =\n          quality.enableDispersion && panel.glassMaterial.dispersion > 0.001 ? 1 : 0;\n        uniforms.uEnableCaustics = quality.enableCaustics && Boolean(panel.causticsAtlas) ? 1 : 0;\n        const tint = hexToVec3(panel.glassMaterial.tint ?? 0xffffff);\n        uniforms.uTint[0] = tint[0];\n        uniforms.uTint[1] = tint[1];\n        uniforms.uTint[2] = tint[2];\n        uniforms.uSpecular = panel.glassMaterial.specular ?? 0;\n        uniforms.uShininess = panel.glassMaterial.shininess ?? 32;\n        uniforms.uShadow = panel.glassMaterial.shadow ?? 0;\n        const lightDir = panel.glassMaterial.lightDir ?? [0.5, 0.5, 1];\n        uniforms.uLightDir[0] = -lightDir[0];\n        uniforms.uLightDir[1] = -lightDir[1];\n        uniforms.uLightDir[2] = lightDir[2];\n        uniforms.uBlurSamples = panel.glassMaterial.blurSamples ?? 8;\n        uniforms.uBlurSpread = panel.glassMaterial.blurSpread ?? 4;\n        uniforms.uBlurAngle = (panel.glassMaterial.blurAngle ?? 0) * Math.PI / 180;\n        uniforms.uBlurAnisotropy = panel.glassMaterial.blurAnisotropy ?? 0;\n        uniforms.uBlurGamma = panel.glassMaterial.blurGamma ?? 1;\n        uniforms.uAberrationR = panel.glassMaterial.aberrationR ?? 1;\n        uniforms.uAberrationB = panel.glassMaterial.aberrationB ?? 1;\n        uniforms.uAO = panel.glassMaterial.ao ?? 0;\n        uniforms.uAORadius = panel.glassMaterial.aoRadius ?? 0.5;\n        uniforms.uNoiseScale = panel.glassMaterial.noiseScale ?? 20;\n        uniforms.uNoiseIntensity = panel.glassMaterial.noiseIntensity ?? 0;\n        uniforms.uNoiseRotation = panel.glassMaterial.noiseRotation ?? 0;\n        uniforms.uNoiseThreshold = panel.glassMaterial.noiseThreshold ?? 0;\n        uniforms.uEdgeSupersampling = quality.edgeSupersampling ?? 1;\n        uniforms.uGlassSupersampling = panel.glassMaterial.glassSupersampling ?? 1;\n        uniforms.uEdgeIor[0] = panel.glassMaterial.edgeIorRangeStart ?? 0;\n        uniforms.uEdgeIor[1] = panel.glassMaterial.edgeIorRangeEnd ?? 0.15;\n        uniforms.uEdgeIor[2] = panel.glassMaterial.edgeIorStrength ?? 1;\n        uniforms.uEdgeIor[3] = panel.glassMaterial.edgeIorEnabled ? 1 : 0;\n        uniforms.uPanelSize[0] = panel.scale.x;\n        uniforms.uPanelSize[1] = panel.scale.y;\n\n        // Edge mask system\n        const edgeMask = panel.glassMaterial.edgeMask;\n        if (edgeMask) {\n          uniforms.uEdgeMaskCutoff = edgeMask.cutoff;\n          uniforms.uEdgeMaskBlur = edgeMask.blur;\n          uniforms.uEdgeMaskInvert = edgeMask.invert ? 1 : 0;\n\n          // Set tactic uniforms\n          const setTactic = (uniform: Float32Array, tactic: any) => {\n            uniform[0] = tactic.rangeStart;\n            uniform[1] = tactic.rangeEnd;\n            uniform[2] = tactic.strength;\n            uniform[3] = tactic.opacity;\n          };\n\n          setTactic(uniforms.uEdgeSmoothing, edgeMask.smoothing);\n          setTactic(uniforms.uEdgeContrast, edgeMask.contrast);\n          setTactic(uniforms.uEdgeAlpha, edgeMask.alpha);\n          setTactic(uniforms.uEdgeTint, edgeMask.tint);\n          setTactic(uniforms.uEdgeDarken, edgeMask.darken);\n          setTactic(uniforms.uEdgeDesaturate, edgeMask.desaturate);\n\n          uniforms.uEnableSmoothing = edgeMask.smoothing.enabled ? 1 : 0;\n          uniforms.uEnableContrast = edgeMask.contrast.enabled ? 1 : 0;\n          uniforms.uEnableAlpha = edgeMask.alpha.enabled ? 1 : 0;\n          uniforms.uEnableTint = edgeMask.tint.enabled ? 1 : 0;\n          uniforms.uEnableDarken = edgeMask.darken.enabled ? 1 : 0;\n          uniforms.uEnableDesaturate = edgeMask.desaturate.enabled ? 1 : 0;\n          uniforms.uDebugMode = (edgeMask as any).debugMode ?? 0;\n        } else {\n          // Legacy fallback\n          uniforms.uEdgeMaskCutoff = panel.glassMaterial.edgeMaskCutoff ?? 0.001;\n          uniforms.uEdgeMaskBlur = panel.glassMaterial.edgeBlur ?? 0;\n          uniforms.uEdgeMaskInvert = 0;\n          uniforms.uEnableSmoothing = 0;\n          uniforms.uEnableContrast = 0;\n          uniforms.uEnableAlpha = 0;\n          uniforms.uEnableTint = 0;\n          uniforms.uEnableDarken = 0;\n          uniforms.uEnableDesaturate = 0;\n        }\n      }\n    }\n\n    const prevShader = panel.shader;\n    panel.shader = this.refractShader as any;\n    this.drawPanelToTarget(panel, this.accumRT);\n\n    panel.shader = this.revealageShader as any;\n\n    const revealResources = (this.revealageShader as any).resources;\n    if (revealResources) {\n      revealResources.uNormalMap = normal.source;\n\n      const revealUniforms = revealResources.panelUniforms?.uniforms;\n      if (revealUniforms) {\n        revealUniforms.uPosition[0] = panel.position.x;\n        revealUniforms.uPosition[1] = panel.position.y;\n        revealUniforms.uScale[0] = panel.scale.x;\n        revealUniforms.uScale[1] = panel.scale.y;\n        revealUniforms.uResolution[0] = screenWidth;\n        revealUniforms.uResolution[1] = screenHeight;\n        revealUniforms.uOpacity = panel.glassMaterial.opacity;\n      }\n    }\n\n    this.drawPanelToTarget(panel, this.revealRT);\n    panel.shader = prevShader;\n  }\n\n  private renderContactShadows(panels: GlassPanel[], quality: RenderQualityOptions): void {\n    if (!quality.enableContactShadows) return;\n    for (const panel of panels) {\n      if (!panel.sdfShadow) continue;\n      this.shadowSprite.texture = panel.sdfShadow;\n      this.shadowSprite.position.copyFrom(panel.position);\n      this.shadowSprite.scale.copyFrom(panel.scale);\n      this.shadowSprite.rotation = panel.rotation;\n      this.shadowSprite.alpha = Math.min(panel.glassMaterial.opacity + 0.2, 0.9);\n      // this.shadowSprite.state.blendMode = BLEND_MODES.MULTIPLY;\n      this.renderer.render(this.shadowSprite);\n    }\n  }\n\n  getCompositeDisplay(): Container | undefined {\n    return this.compositeSprite;\n  }\n\n  private drawPanelToTarget(panel: GlassPanel, target: RenderTexture): void {\n    const renderer = this.renderer;\n    const gl = (renderer as any).gl as WebGL2RenderingContext;\n\n    // Clear parent and add only this panel\n    this.panelParent.removeChildren();\n    this.panelParent.addChild(panel);\n\n    // Update transforms for detached container in v8\n    panel.updateLocalTransform();\n    panel.worldTransform.copyFrom(panel.localTransform);\n\n    // Use standard alpha blending\n    if (gl) {\n      gl.enable(gl.BLEND);\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n    }\n\n    renderer.render({ container: this.panelParent, target, clear: false });\n\n    // Reset blend state\n    if (gl) {\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    }\n  }\n\n  private ensureCompositeTarget(width: number, height: number): void {\n    const targetResolution = this.renderer.resolution;\n    if (\n      !this.compositeRT ||\n      this.compositeRT.width !== width ||\n      this.compositeRT.height !== height ||\n      this.compositeRT.source.resolution !== targetResolution\n    ) {\n      this.compositeRT?.destroy(true);\n      this.compositeRT = RenderTexture.create({\n        width,\n        height,\n        resolution: targetResolution,\n      });\n      this.compositeSprite.texture = this.compositeRT;\n    }\n  }\n}\n","import type { Container, RenderTexture, Renderer, WebGLRenderer } from 'pixi.js';\nimport { AdaptiveQualityController } from '../core/AdaptiveQualityController.js';\nimport { CapabilityProbe } from '../core/CapabilityProbe.js';\nimport { EventBus } from '../core/EventBus.js';\nimport type {\n  AdaptiveDecision,\n  FallbackEvent,\n  GlassPanelProps,\n  GlassSystemOptions,\n  RenderQualityOptions,\n} from '../core/types.js';\nimport type { GlassPanel } from '../panels/GlassPanel.js';\nimport { GlassPanel as GlassPanelImpl } from '../panels/GlassPanel.js';\nimport type { Pipeline } from '../pipelines/BasePipeline.js';\nimport { WebGL1Pipeline } from '../pipelines/WebGL1Pipeline.js';\nimport { WebGL2Pipeline } from '../pipelines/WebGL2Pipeline.js';\n\ninterface GlassSystemEvents {\n  'quality:decision': AdaptiveDecision;\n  fallback: FallbackEvent;\n  [key: string]: any; // Add index signature to satisfy EventMap\n}\n\nexport class GlassSystem {\n  private pipeline: Pipeline;\n  private readonly panels: GlassPanel[] = [];\n  private readonly quality = new AdaptiveQualityController();\n  private drawOpaqueScene: (target: RenderTexture) => void = () => {};\n  private readonly events = new EventBus<GlassSystemEvents>();\n\n  constructor(\n    private readonly renderer: Renderer,\n    _options: GlassSystemOptions = {},\n  ) {\n    const gl = (renderer as WebGLRenderer).gl;\n    const capability = new CapabilityProbe(gl).run();\n    this.pipeline =\n      capability.tier === 'webgl2'\n        ? new WebGL2Pipeline(renderer, true)\n        : new WebGL1Pipeline(renderer);\n    if (capability.tier === 'webgl1') {\n      this.emitFallback('webgl', 'MRT unavailable, using compatibility pipeline');\n    }\n  }\n\n  setOpaqueSceneCallback(draw: (target: RenderTexture) => void): void {\n    this.drawOpaqueScene = draw;\n  }\n\n  createPanel(props: GlassPanelProps): GlassPanel {\n    const panel = new GlassPanelImpl(props);\n    this.panels.push(panel);\n    return panel;\n  }\n\n  removePanel(panel: GlassPanel): void {\n    const idx = this.panels.indexOf(panel);\n    if (idx >= 0) {\n      this.panels.splice(idx, 1);\n      panel.destroy({ children: true, texture: false, textureSource: false });\n    }\n  }\n\n  render(): void {\n    const start = performance.now();\n    const quality = this.quality.getQuality();\n    this.pipeline.render({\n      renderer: this.renderer,\n      panels: this.panels,\n      quality,\n      drawOpaqueScene: this.drawOpaqueScene,\n    });\n    const duration = performance.now() - start;\n    this.quality.record({ cpuMs: duration, timestamp: start });\n    const decision = this.quality.evaluate();\n    if (decision) {\n      this.events.emit('quality:decision', decision);\n    }\n  }\n\n  setQuality(options: Partial<RenderQualityOptions>): void {\n    this.quality.setOverrides(options);\n  }\n\n  destroy(): void {\n    for (const panel of this.panels) {\n      panel.destroy({ children: true, texture: false, textureSource: false });\n    }\n    this.panels.length = 0;\n    this.pipeline.dispose();\n    this.events.removeAll();\n  }\n\n  on<K extends keyof GlassSystemEvents>(\n    event: K,\n    listener: (payload: GlassSystemEvents[K]) => void,\n  ): void {\n    this.events.on(event, listener);\n  }\n\n  off<K extends keyof GlassSystemEvents>(\n    event: K,\n    listener: (payload: GlassSystemEvents[K]) => void,\n  ): void {\n    this.events.off(event, listener);\n  }\n\n  getPipelineId(): string {\n    return this.pipeline.id;\n  }\n\n  getCompositeDisplay(): Container | undefined {\n    if (typeof this.pipeline.getCompositeDisplay === 'function') {\n      return this.pipeline.getCompositeDisplay();\n    }\n    return undefined;\n  }\n\n  private emitFallback(target: string, message: string): void {\n    const event: FallbackEvent = { target, message, timestamp: performance.now() };\n    console.warn(`GlassSystem fallback: ${target} - ${message}`);\n    this.events.emit('fallback', event);\n  }\n}\n","import { Container, Graphics, Text } from 'pixi.js';\nimport type { Renderer } from 'pixi.js';\nimport type { AdaptiveDecision, RenderQualityOptions, TelemetrySample } from '../core/types.js';\n\ninterface HudMetrics {\n  quality: RenderQualityOptions;\n  fps: number;\n  lastDecision?: AdaptiveDecision;\n  telemetry: TelemetrySample[];\n}\n\nexport class GlassHUD {\n  readonly container = new Container();\n  private readonly panel: Graphics;\n  private readonly text: Text;\n  private visible = false;\n\n  constructor(private readonly renderer: Renderer) {\n    this.panel = new Graphics()\n      .beginFill(0x000000, 0.65)\n      .drawRoundedRect(0, 0, 260, 120, 8)\n      .endFill();\n    this.text = new Text('Glass HUD', { fontSize: 12, fill: 0xffffff });\n    this.text.position.set(12, 10);\n    this.container.addChild(this.panel, this.text);\n    this.container.visible = this.visible;\n    this.container.position.set(12, 12);\n  }\n\n  setVisible(visible: boolean): void {\n    this.visible = visible;\n    this.container.visible = visible;\n  }\n\n  update(metrics: HudMetrics): void {\n    if (!this.visible) return;\n    const { quality, fps, lastDecision } = metrics;\n    const lines = [\n      `FPS: ${fps.toFixed(1)}`,\n      `Scale: ${(quality.renderScale * 100).toFixed(0)}%`,\n      `Blur taps: ${quality.maxBlurTaps}`,\n      `Dispersion: ${quality.enableDispersion ? 'on' : 'off'}`,\n      `Caustics: ${quality.enableCaustics ? 'on' : 'off'}`,\n    ];\n    if (lastDecision) {\n      lines.push(`Action: ${lastDecision.action}`);\n    }\n    this.text.text = lines.join('\\n');\n  }\n}\n","import type { Renderer } from 'pixi.js';\nimport type { LightFollowParams, TrackedItem } from './types.js';\n\nexport class LightFollowController {\n  private params?: LightFollowParams;\n  private currentDir: [number, number, number] = [0, 0, 0.15];\n  private targetDir: [number, number, number] = [0, 0, 0.15];\n  private delayedDir: [number, number, number] = [0, 0, 0.15];\n  private boundMouseMove?: (e: MouseEvent) => void;\n  private renderer: Renderer;\n\n  constructor(renderer: Renderer) {\n    this.renderer = renderer;\n  }\n\n  setParams(params: LightFollowParams): void {\n    this.params = params;\n\n    if (params.followCursor && !this.boundMouseMove) {\n      this.boundMouseMove = (e: MouseEvent) => {\n        const curve = params.curve ?? 1.5;\n        const zMin = params.zMin ?? 0.05;\n        const zMax = params.zMax ?? 0.20;\n        const edgeStretch = params.edgeStretch ?? 0.5;\n\n        // Get canvas bounds for proper coordinate mapping\n        const canvas = this.renderer.canvas as HTMLCanvasElement;\n        const rect = canvas.getBoundingClientRect();\n\n        // Convert cursor position to -1 to 1 range relative to canvas\n        let x = 1 - ((e.clientX - rect.left) / rect.width) * 2; // X: left=1, right=-1\n        let y = 1 - ((e.clientY - rect.top) / rect.height) * 2; // Y: top=1, bottom=-1\n\n        // Apply edge stretch - power curve controls how values spread\n        // < 1 = stretch toward edges, > 1 = compress toward center\n        x = Math.sign(x) * Math.pow(Math.abs(x), edgeStretch);\n        y = Math.sign(y) * Math.pow(Math.abs(y), edgeStretch);\n\n        // Z decreases toward edges based on curve, capped at zMax (0.20)\n        const dist = Math.sqrt(x * x + y * y);\n        const z = Math.max(zMin, Math.min(zMax, zMax - Math.pow(dist, curve) * zMax * 0.5));\n\n        this.targetDir = [x, y, z];\n      };\n      window.addEventListener('mousemove', this.boundMouseMove);\n    } else if (!params.followCursor && this.boundMouseMove) {\n      window.removeEventListener('mousemove', this.boundMouseMove);\n      this.boundMouseMove = undefined;\n    }\n  }\n\n  update(tracked: Map<HTMLElement, TrackedItem>): void {\n    if (!this.params?.followCursor) return;\n\n    // Delay: lerp delayed toward target (0 = instant, 1 = very slow)\n    const delay = this.params.delay ?? 0.5;\n    const delayFactor = 1 - delay * 0.97; // Convert to lerp factor (0.03 to 1)\n    this.delayedDir[0] += (this.targetDir[0] - this.delayedDir[0]) * delayFactor;\n    this.delayedDir[1] += (this.targetDir[1] - this.delayedDir[1]) * delayFactor;\n    this.delayedDir[2] += (this.targetDir[2] - this.delayedDir[2]) * delayFactor;\n\n    // Smoothing: lerp current toward delayed (0 = instant, 1 = very slow)\n    const smoothing = this.params.smoothing ?? 0.9;\n    const smoothFactor = 1 - smoothing * 0.97; // Convert to lerp factor (0.03 to 1)\n    this.currentDir[0] += (this.delayedDir[0] - this.currentDir[0]) * smoothFactor;\n    this.currentDir[1] += (this.delayedDir[1] - this.currentDir[1]) * smoothFactor;\n    this.currentDir[2] += (this.delayedDir[2] - this.currentDir[2]) * smoothFactor;\n\n    // Apply to all panels\n    for (const [, item] of tracked) {\n      item.panel.glassMaterial.lightDir = [...this.currentDir];\n    }\n  }\n\n  destroy(): void {\n    if (this.boundMouseMove) {\n      window.removeEventListener('mousemove', this.boundMouseMove);\n      this.boundMouseMove = undefined;\n    }\n  }\n}\n","import type { GlassPanel } from '../panels/GlassPanel.js';\nimport type { TrackedItem } from './types.js';\n\nexport type SyncElementFn = (element: HTMLElement, panel: GlassPanel) => void;\nexport type UpdateGeometryFn = (element: HTMLElement, item: TrackedItem) => void;\nexport type IsCssVisibleFn = (element: HTMLElement) => boolean;\nexport type ParseBorderRadiusFn = (element: HTMLElement, rect: DOMRect) => number;\n\nexport interface DomTrackingCallbacks {\n  syncElement: SyncElementFn;\n  updateGeometry: UpdateGeometryFn;\n  isCssVisible: IsCssVisibleFn;\n  parseBorderRadius: ParseBorderRadiusFn;\n}\n\nexport class DomTrackingController {\n  private resizeObserver?: ResizeObserver;\n  private intersectionObserver?: IntersectionObserver;\n  private observer?: MutationObserver;\n  private tracked: Map<HTMLElement, TrackedItem>;\n  private callbacks: DomTrackingCallbacks;\n\n  constructor(tracked: Map<HTMLElement, TrackedItem>, callbacks: DomTrackingCallbacks) {\n    this.tracked = tracked;\n    this.callbacks = callbacks;\n  }\n\n  setupObservers(selector: string, trackFn: (el: HTMLElement) => void, untrackFn: (el: HTMLElement) => void, cleanupFn: () => void): void {\n    // Set up ResizeObserver for size changes\n    this.resizeObserver = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const element = entry.target as HTMLElement;\n        const item = this.tracked.get(element);\n        if (!item) continue;\n\n        const rect = element.getBoundingClientRect();\n        const lastRect = item.lastRect;\n\n        // Check if size changed significantly (more than 1px)\n        if (lastRect && (\n          Math.abs(rect.width - lastRect.width) > 1 ||\n          Math.abs(rect.height - lastRect.height) > 1\n        )) {\n          this.callbacks.updateGeometry(element, item);\n        }\n        item.lastRect = rect;\n      }\n    });\n\n    // Set up IntersectionObserver for visibility\n    this.intersectionObserver = new IntersectionObserver((entries) => {\n      for (const entry of entries) {\n        const element = entry.target as HTMLElement;\n        const item = this.tracked.get(element);\n        if (!item) continue;\n\n        item.visible = entry.isIntersecting;\n        const cssVisible = this.callbacks.isCssVisible(element);\n        item.panel.visible = item.visible && cssVisible;\n      }\n    });\n\n    // Mount existing elements\n    const existing = document.querySelectorAll<HTMLElement>(selector);\n    existing.forEach((el) => trackFn(el));\n\n    // Set up MutationObserver\n    this.observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.type === 'childList') {\n          mutation.addedNodes.forEach((node) => {\n            if (node instanceof HTMLElement && node.matches(selector)) {\n              trackFn(node);\n            }\n            if (node instanceof HTMLElement) {\n              const children = node.querySelectorAll<HTMLElement>(selector);\n              children.forEach((child) => trackFn(child));\n            }\n          });\n          mutation.removedNodes.forEach((node) => {\n            if (node instanceof HTMLElement && this.tracked.has(node)) {\n              untrackFn(node);\n            }\n          });\n        } else if (mutation.type === 'attributes') {\n          const target = mutation.target as HTMLElement;\n          if (mutation.attributeName === 'class') {\n            if (target.matches(selector)) {\n              trackFn(target);\n            } else {\n              untrackFn(target);\n            }\n          } else if (mutation.attributeName === 'style') {\n            const item = this.tracked.get(target);\n            if (item) {\n              // Check for visibility changes\n              const cssVisible = this.callbacks.isCssVisible(target);\n              item.panel.visible = cssVisible && item.visible;\n\n              // Check for border-radius changes\n              const rect = target.getBoundingClientRect();\n              const newRadius = this.callbacks.parseBorderRadius(target, rect);\n              if (Math.abs(newRadius - item.lastRadius) > 0.5) {\n                this.callbacks.updateGeometry(target, item);\n              }\n            }\n          } else if (mutation.attributeName === 'hidden') {\n            const item = this.tracked.get(target);\n            if (item) {\n              const cssVisible = this.callbacks.isCssVisible(target);\n              item.panel.visible = cssVisible && item.visible;\n            }\n          }\n        }\n      }\n      cleanupFn();\n    });\n\n    this.observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: ['class', 'style', 'hidden'],\n    });\n  }\n\n  observeElement(element: HTMLElement): void {\n    this.resizeObserver?.observe(element);\n    this.intersectionObserver?.observe(element);\n  }\n\n  unobserveElement(element: HTMLElement): void {\n    this.resizeObserver?.unobserve(element);\n    this.intersectionObserver?.unobserve(element);\n  }\n\n  destroy(): void {\n    this.observer?.disconnect();\n    this.resizeObserver?.disconnect();\n    this.intersectionObserver?.disconnect();\n  }\n}\n\n// Animation polling helpers\nexport function createAnimationHandlers(\n  tracked: Map<HTMLElement, TrackedItem>,\n  syncElement: SyncElementFn,\n  updateGeometry: UpdateGeometryFn\n) {\n  const startPolling = (element: HTMLElement): void => {\n    const item = tracked.get(element);\n    if (!item || item.polling) return;\n\n    item.polling = true;\n    const poll = () => {\n      if (!item.polling) return;\n      syncElement(element, item.panel);\n      requestAnimationFrame(poll);\n    };\n    requestAnimationFrame(poll);\n  };\n\n  const stopPolling = (element: HTMLElement): void => {\n    const item = tracked.get(element);\n    if (!item) return;\n\n    item.polling = false;\n    updateGeometry(element, item);\n  };\n\n  const handleAnimationStart = (e: Event) => {\n    const element = e.currentTarget as HTMLElement;\n    startPolling(element);\n  };\n\n  const handleAnimationEnd = (e: Event) => {\n    const element = e.currentTarget as HTMLElement;\n    // Check if any animations are still running\n    const animations = element.getAnimations();\n    if (animations.length === 0) {\n      stopPolling(element);\n    }\n  };\n\n  return { handleAnimationStart, handleAnimationEnd };\n}\n","// Calculate signed distance to rounded rect boundary (positive = inside)\nexport function getDistanceToBoundary(\n  px: number, py: number,\n  w: number, h: number,\n  radius: number\n): number {\n  const cx = w / 2;\n  const cy = h / 2;\n  const relX = Math.abs(px + 0.5 - cx);\n  const relY = Math.abs(py + 0.5 - cy);\n\n  const innerW = cx - radius;\n  const innerH = cy - radius;\n\n  if (relX <= innerW && relY <= innerH) {\n    return Math.min(innerW + radius - relX, innerH + radius - relY);\n  } else if (relX > innerW && relY <= innerH) {\n    return radius - (relX - innerW);\n  } else if (relY > innerH && relX <= innerW) {\n    return radius - (relY - innerH);\n  } else {\n    const dx = relX - innerW;\n    const dy = relY - innerH;\n    return radius - Math.sqrt(dx * dx + dy * dy);\n  }\n}\n","import { Texture } from 'pixi.js';\nimport type { SurfaceShape } from '../core/types.js';\nimport { getDistanceToBoundary } from './distance.js';\nimport { distanceToT, getHeightAndDerivative } from './height-functions.js';\n\nexport function createRoundedRectNormalMap(\n  width: number,\n  height: number,\n  radius: number,\n  bevel: number,\n  shape: SurfaceShape,\n  invertNormals: boolean = false,\n): Texture {\n  const w = Math.ceil(width);\n  const h = Math.ceil(height);\n  const data = new Uint8Array(w * h * 4);\n\n  // Subpixel offsets for 4x MSAA pattern\n  const subpixelOffsets = [\n    [-0.25, -0.25],\n    [0.25, -0.25],\n    [-0.25, 0.25],\n    [0.25, 0.25],\n  ];\n\n  for (let y = 0; y < h; y++) {\n    for (let x = 0; x < w; x++) {\n      let nx = 0;\n      let ny = 0;\n      let nz = 1;\n\n      // Subpixel sampling for alpha\n      let alphaSum = 0;\n      for (const [ox, oy] of subpixelOffsets) {\n        const dist = getDistanceToBoundary(x + ox, y + oy, w, h, radius);\n        alphaSum += dist >= 0 ? 1 : 0;\n      }\n      const alpha = (alphaSum / subpixelOffsets.length) * 255;\n\n      // Use pixel center for normal calculation\n      const cx = w / 2;\n      const cy = h / 2;\n      const relX = Math.abs(x + 0.5 - cx);\n      const relY = Math.abs(y + 0.5 - cy);\n\n      const innerW = cx - radius;\n      const innerH = cy - radius;\n\n      // Calculate distance to boundary and direction\n      let distToBoundary = 0;\n      let dirX = 0;\n      let dirY = 0;\n      let closestX = relX;\n      let closestY = relY;\n\n      if (relX <= innerW && relY <= innerH) {\n        const toEdgeX = innerW + radius;\n        const toEdgeY = innerH + radius;\n        if (toEdgeX - relX < toEdgeY - relY) {\n          closestX = innerW + radius;\n          closestY = relY;\n        } else {\n          closestX = relX;\n          closestY = innerH + radius;\n        }\n        distToBoundary = Math.min(toEdgeX - relX, toEdgeY - relY);\n      } else if (relX > innerW && relY <= innerH) {\n        closestX = innerW + radius;\n        closestY = relY;\n        distToBoundary = radius - (relX - innerW);\n      } else if (relY > innerH && relX <= innerW) {\n        closestX = relX;\n        closestY = innerH + radius;\n        distToBoundary = radius - (relY - innerH);\n      } else {\n        const dx = relX - innerW;\n        const dy = relY - innerH;\n        const cornerDist = Math.sqrt(dx * dx + dy * dy);\n        distToBoundary = radius - cornerDist;\n        if (cornerDist > 0) {\n          closestX = innerW + (dx / cornerDist) * radius;\n          closestY = innerH + (dy / cornerDist) * radius;\n        }\n      }\n\n      // Direction points from pixel toward closest boundary point\n      const toDirX = closestX - relX;\n      const toDirY = closestY - relY;\n      const dirLen = Math.sqrt(toDirX * toDirX + toDirY * toDirY);\n      if (dirLen > 0.001) {\n        dirX = (x > cx ? 1 : -1) * (toDirX / dirLen);\n        dirY = (y > cy ? 1 : -1) * (toDirY / dirLen);\n      }\n\n      // Apply bevel based on distance to boundary\n      if (bevel > 0 && distToBoundary < bevel && distToBoundary >= 0) {\n        const t = distanceToT(distToBoundary, bevel);\n        const { derivative } = getHeightAndDerivative(t, shape);\n        nx = dirX * derivative * 0.5;\n        ny = dirY * derivative * 0.5;\n        if (invertNormals) {\n          nx = -nx;\n          ny = -ny;\n        }\n      }\n\n      const len = Math.sqrt(nx * nx + ny * ny + nz * nz);\n      nx /= len;\n      ny /= len;\n      nz /= len;\n\n      const index = (y * w + x) * 4;\n      data[index] = ((nx * 0.5 + 0.5) * 255) | 0;\n      data[index + 1] = ((ny * 0.5 + 0.5) * 255) | 0;\n      data[index + 2] = ((nz * 0.5 + 0.5) * 255) | 0;\n      data[index + 3] = alpha;\n    }\n  }\n  return Texture.from({\n    resource: data,\n    width: w,\n    height: h,\n  });\n}\n\nexport function createDisplacementMapData(\n  width: number,\n  height: number,\n  radius: number,\n  bevel: number,\n  shape: SurfaceShape = 'squircle',\n): { data: Uint8Array; width: number; height: number } {\n  const w = Math.ceil(width);\n  const h = Math.ceil(height);\n  const data = new Uint8Array(w * h * 4);\n\n  for (let y = 0; y < h; y++) {\n    for (let x = 0; x < w; x++) {\n      const dist = getDistanceToBoundary(x, y, w, h, radius);\n      const alpha = dist >= 0 ? 255 : 0;\n\n      let displacement = 0; // Center is min height (black)\n      if (bevel > 0 && dist >= 0 && dist < bevel) {\n        const t = distanceToT(dist, bevel);\n        const { height: ht } = getHeightAndDerivative(t, shape);\n        displacement = (1 - ht) * 255; // Inverted: white at edge, black at center\n      } else if (dist < 0) {\n        displacement = 0; // Outside shape\n      }\n\n      const index = (y * w + x) * 4;\n      data[index] = displacement;\n      data[index + 1] = displacement;\n      data[index + 2] = displacement;\n      data[index + 3] = alpha;\n    }\n  }\n\n  return { data, width: w, height: h };\n}\n\nexport function createDisplacementMap(\n  width: number,\n  height: number,\n  radius: number,\n  bevel: number,\n  shape: SurfaceShape = 'squircle',\n): Texture {\n  const result = createDisplacementMapData(width, height, radius, bevel, shape);\n  return Texture.from({\n    resource: result.data,\n    width: result.width,\n    height: result.height,\n  });\n}\n","import { Texture } from 'pixi.js';\nimport type { Renderer } from 'pixi.js';\nimport { GlassSystem } from './system/GlassSystem.js';\nimport { GlassPresets } from './materials/GlassPresets.js';\nimport type { GlassPanel } from './panels/GlassPanel.js';\n\n// Re-export types for external consumers\nexport type {\n  PositionTransform,\n  PositionTransformFn,\n  LightFollowParams,\n  GlassOverlayOptions,\n  GlassItemConfig,\n} from './overlay/types.js';\n\nimport type {\n  PositionTransformFn,\n  LightFollowParams,\n  GlassOverlayOptions,\n  GlassItemConfig,\n  TrackedItem,\n} from './overlay/types.js';\n\nimport { LightFollowController } from './overlay/light-follow.js';\nimport { DomTrackingController, createAnimationHandlers } from './overlay/dom-tracking.js';\nimport { createRoundedRectNormalMap, createDisplacementMap } from './geometry/normal-map.js';\n\n// Re-export geometry functions for external use\nexport {\n  heightCircle,\n  heightSquircle,\n  smootherstep,\n  getHeightAndDerivative,\n} from './geometry/height-functions.js';\n\nexport { getDistanceToBoundary } from './geometry/distance.js';\n\nexport {\n  createRoundedRectNormalMap,\n  createDisplacementMapData,\n  createDisplacementMap,\n} from './geometry/normal-map.js';\n\n/**\n * A high-level wrapper for GlassSystem that synchronizes GlassPanels with DOM elements.\n * Ideal for adding glass effects to existing UI overlays in Nuxt/Vue/React projects.\n */\nexport class GlassOverlay {\n  public readonly system: GlassSystem;\n  private readonly tracked = new Map<HTMLElement, TrackedItem>();\n  private positionTransform?: PositionTransformFn;\n  private lightFollow: LightFollowController;\n  private domTracking: DomTrackingController;\n  private animationHandlers: ReturnType<typeof createAnimationHandlers>;\n\n  constructor(renderer: Renderer, options: GlassOverlayOptions) {\n    this.system = new GlassSystem(renderer, options.systemOptions);\n\n    this.system.setOpaqueSceneCallback((target) => {\n      renderer.render({ container: options.background, target, clear: true });\n    });\n\n    const composite = this.system.getCompositeDisplay();\n    if (composite) {\n      options.stage.addChild(composite);\n    }\n\n    // Initialize controllers\n    this.lightFollow = new LightFollowController(renderer);\n    this.domTracking = new DomTrackingController(this.tracked, {\n      syncElement: this.syncElement.bind(this),\n      updateGeometry: this.updatePanelGeometry.bind(this),\n      isCssVisible: this.isCssVisible.bind(this),\n      parseBorderRadius: this.parseBorderRadius.bind(this),\n    });\n\n    this.animationHandlers = createAnimationHandlers(\n      this.tracked,\n      this.syncElement.bind(this),\n      this.updatePanelGeometry.bind(this)\n    );\n\n    // Set up light follow cursor\n    if (options.lightFollowParams) {\n      this.setLightFollowParams(options.lightFollowParams);\n    }\n  }\n\n  setLightFollowParams(params: LightFollowParams): void {\n    this.lightFollow.setParams(params);\n  }\n\n  autoMount(selector: string = '.glass-panel'): void {\n    this.domTracking.setupObservers(\n      selector,\n      (el) => this.track(el),\n      (el) => this.untrack(el),\n      () => this.cleanup()\n    );\n  }\n\n  track(element: HTMLElement, config: GlassItemConfig = {}): GlassPanel {\n    if (this.tracked.has(element)) {\n      return this.tracked.get(element)!.panel;\n    }\n\n    const material = this.createMaterial(element, config);\n    const rect = element.getBoundingClientRect();\n    const isCircle = this.detectCircleMode(element, config);\n    const radius = this.calculateRadius(element, rect, config, isCircle);\n    const normalMap = this.createNormalMap(rect, radius, config, isCircle);\n\n    const panel = this.system.createPanel({ material, normalMap });\n    const item: TrackedItem = {\n      panel,\n      config,\n      lastRect: rect,\n      lastRadius: radius,\n      visible: true,\n      isCircle,\n      polling: false,\n    };\n\n    this.tracked.set(element, item);\n\n    // Set up observers\n    this.domTracking.observeElement(element);\n\n    // Set up animation listeners\n    element.addEventListener('transitionrun', this.animationHandlers.handleAnimationStart);\n    element.addEventListener('transitionend', this.animationHandlers.handleAnimationEnd);\n    element.addEventListener('transitioncancel', this.animationHandlers.handleAnimationEnd);\n    element.addEventListener('animationstart', this.animationHandlers.handleAnimationStart);\n    element.addEventListener('animationend', this.animationHandlers.handleAnimationEnd);\n    element.addEventListener('animationcancel', this.animationHandlers.handleAnimationEnd);\n\n    this.syncElement(element, panel);\n\n    return panel;\n  }\n\n  untrack(element: HTMLElement): void {\n    const item = this.tracked.get(element);\n    if (!item) return;\n\n    item.polling = false;\n    this.domTracking.unobserveElement(element);\n\n    element.removeEventListener('transitionrun', this.animationHandlers.handleAnimationStart);\n    element.removeEventListener('transitionend', this.animationHandlers.handleAnimationEnd);\n    element.removeEventListener('transitioncancel', this.animationHandlers.handleAnimationEnd);\n    element.removeEventListener('animationstart', this.animationHandlers.handleAnimationStart);\n    element.removeEventListener('animationend', this.animationHandlers.handleAnimationEnd);\n    element.removeEventListener('animationcancel', this.animationHandlers.handleAnimationEnd);\n\n    this.system.removePanel(item.panel);\n    this.tracked.delete(element);\n  }\n\n  update(): void {\n    this.lightFollow.update(this.tracked);\n\n    for (const [element, item] of this.tracked) {\n      this.syncElement(element, item.panel);\n    }\n    this.system.render();\n  }\n\n  resize(): void {\n    this.update();\n  }\n\n  setPositionTransform(transform: PositionTransformFn | undefined): void {\n    this.positionTransform = transform;\n  }\n\n  cleanup(): void {\n    for (const [element] of this.tracked) {\n      if (!document.body.contains(element)) {\n        this.untrack(element);\n      }\n    }\n  }\n\n  destroy(): void {\n    this.lightFollow.destroy();\n    this.domTracking.destroy();\n    this.system.destroy();\n    this.tracked.clear();\n  }\n\n  private createMaterial(element: HTMLElement, config: GlassItemConfig) {\n    const dataIor = element.dataset.glassIor ? parseFloat(element.dataset.glassIor) : undefined;\n    const dataRoughness = element.dataset.glassRoughness\n      ? parseFloat(element.dataset.glassRoughness)\n      : undefined;\n\n    const material = {\n      ...GlassPresets.clear(),\n      ...config.material,\n    };\n\n    if (dataIor !== undefined) material.ior = dataIor;\n    if (dataRoughness !== undefined) material.roughness = dataRoughness;\n\n    return material;\n  }\n\n  private detectCircleMode(element: HTMLElement, config: GlassItemConfig): boolean {\n    return config.isCircle ||\n           element.classList.contains('glass-circle') ||\n           element.hasAttribute('data-glass-circle');\n  }\n\n  private calculateRadius(element: HTMLElement, rect: DOMRect, config: GlassItemConfig, isCircle: boolean): number {\n    if (isCircle) {\n      return Math.min(rect.width, rect.height) / 2;\n    }\n    const cssRadius = this.parseBorderRadius(element, rect);\n    return config.cornerRadius ?? cssRadius;\n  }\n\n  private createNormalMap(rect: DOMRect, radius: number, config: GlassItemConfig, isCircle: boolean): Texture {\n    if (config.normalMap) return config.normalMap;\n\n    const bevel = config.bevelSize ?? 12;\n    const shape = config.surfaceShape ?? 'squircle';\n    const invertNormals = config.invertNormals ?? false;\n    const useDisplacementMap = config.useDisplacementMap ?? false;\n\n    const dpr = window.devicePixelRatio || 1;\n    const circleSize = Math.floor(Math.min(rect.width, rect.height) * dpr);\n    const mapWidth = isCircle ? circleSize : rect.width * dpr;\n    const mapHeight = isCircle ? circleSize : rect.height * dpr;\n\n    return useDisplacementMap\n      ? createDisplacementMap(mapWidth, mapHeight, radius * dpr, bevel * dpr, shape)\n      : createRoundedRectNormalMap(mapWidth, mapHeight, radius * dpr, bevel * dpr, shape, invertNormals);\n  }\n\n  private syncElement(element: HTMLElement, panel: GlassPanel): void {\n    const item = this.tracked.get(element);\n    const rect = element.getBoundingClientRect();\n\n    // Round to whole pixels to avoid subpixel blurring\n    const width = item?.isCircle ? Math.floor(Math.min(rect.width, rect.height)) : Math.round(rect.width);\n    const height = item?.isCircle ? width : Math.round(rect.height);\n    const x = Math.round(rect.left) + width / 2;\n    const y = Math.round(rect.top) + height / 2;\n\n    if (this.positionTransform) {\n      const t = this.positionTransform(x, y, width, height);\n      panel.position.set(Math.round(t.x), Math.round(t.y));\n      panel.scale.set(Math.round(width * t.scaleX), Math.round(height * t.scaleY));\n      panel.rotation = t.rotation;\n    } else {\n      panel.position.set(x, y);\n      panel.scale.set(width, height);\n      panel.rotation = 0;\n    }\n  }\n\n  private parseBorderRadius(element: HTMLElement, rect: DOMRect): number {\n    const style = window.getComputedStyle(element);\n\n    const topLeft = style.borderTopLeftRadius;\n    const topRight = style.borderTopRightRadius;\n    const bottomRight = style.borderBottomRightRadius;\n    const bottomLeft = style.borderBottomLeftRadius;\n\n    const parseValue = (value: string, dimension: number): number => {\n      if (value.endsWith('%')) {\n        return (parseFloat(value) / 100) * dimension;\n      }\n      return parseFloat(value) || 0;\n    };\n\n    const getFirstValue = (radius: string): string => {\n      return radius.split(' ')[0];\n    };\n\n    const avgDimension = (rect.width + rect.height) / 2;\n\n    const radii = [\n      parseValue(getFirstValue(topLeft), avgDimension),\n      parseValue(getFirstValue(topRight), avgDimension),\n      parseValue(getFirstValue(bottomRight), avgDimension),\n      parseValue(getFirstValue(bottomLeft), avgDimension),\n    ];\n\n    const avg = radii.reduce((a, b) => a + b, 0) / 4;\n    return avg || 20;\n  }\n\n  private isCssVisible(element: HTMLElement): boolean {\n    if (element.hidden) return false;\n    const style = window.getComputedStyle(element);\n    return style.display !== 'none' &&\n           style.visibility !== 'hidden';\n  }\n\n  private updatePanelGeometry(element: HTMLElement, item: TrackedItem): void {\n    const rect = element.getBoundingClientRect();\n    const isCircle = this.detectCircleMode(element, item.config);\n    const radius = this.calculateRadius(element, rect, item.config, isCircle);\n    const normalMap = this.createNormalMap(rect, radius, item.config, isCircle);\n\n    item.panel.setTextures({ normalMap });\n    item.lastRect = rect;\n    item.lastRadius = radius;\n  }\n}\n"],"names":["CapabilityProbe","gl","isWebGL2","extensions","tier","names","map","name","ext","param","DEFAULT_QUALITY","DEGRADATION_STEPS","q","AdaptiveQualityController","targetFrameMs","sample","overrides","avgCpu","sum","s","avgGpu","step","SceneRTManager","renderer","useDepth","Rectangle","width","height","scale","targetResolution","RenderTexture","_a","_c","_b","EventBus","event","listener","listeners","payload","key","make","material","GlassPresets","ior","clamped","PANEL_COUNTER","QUAD_GEOMETRY","MeshGeometry","BASIC_VERT","BASIC_FRAG","GlassPanel","Mesh","props","state","State","Shader","partial","textures","distanceToT","distToBoundary","bevel","heightCircle","t","heightCircleDerivative","h","heightSquircle","inner","heightSquircleDerivative","smootherstep","x","getHeightAndDerivative","shape","d","createPillGeometry","radius","expansion","segments","halfExpansion","vertexCount","positions","uvs","totalWidth","totalHeight","i","angle","idx","y","triangleCount","indices","triIdx","updatePillGeometry","geometry","posAttr","uvAttr","createPillNormalMap","invertNormals","w","data","nx","ny","nz","alpha","cx","cy","relX","relY","dirX","dirY","absX","absY","capCenterX","dx","dy","distFromCapCenter","derivative","len","index","Texture","hexToVec3","hex","createDefaultEdgeTactic","createDefaultEdgeMask","CompatibilityFilter","Filter","fragment","GlProgram","WebGL1Pipeline","Sprite","context","panels","quality","drawOpaqueScene","targets","orderedPanels","a","b","panel","sceneTexture","resources","uniforms","fullscreenVertex","jfaSeedFragment","jfaFloodFragment","jfaDistanceFragment","panelVertex","refractionFragment","revealageFragment","compositeFragment","WebGL2Pipeline","refractUniforms","UniformGroup","revealUniforms","Container","jfaSeedUniforms","jfaFloodUniforms","jfaDistanceUniforms","_d","_e","cache","normalMap","normalMapId","normalMapUpdateId","cached","distanceField","texelSize","seedResources","seedUniforms","maxDim","passes","readRT","writeRT","floodResources","floodUniforms","stepSize","temp","distResources","distUniforms","target","r","g","dummy","sceneTarget","normal","screenWidth","screenHeight","res","tint","lightDir","edgeMask","setTactic","uniform","tactic","prevShader","revealResources","GlassSystem","_options","capability","draw","GlassPanelImpl","start","duration","decision","options","message","GlassHUD","Graphics","Text","visible","metrics","fps","lastDecision","lines","LightFollowController","params","e","curve","zMin","zMax","edgeStretch","rect","dist","z","tracked","delayFactor","smoothFactor","item","DomTrackingController","callbacks","selector","trackFn","untrackFn","cleanupFn","entries","entry","element","lastRect","cssVisible","el","mutations","mutation","node","child","newRadius","createAnimationHandlers","syncElement","updateGeometry","startPolling","poll","stopPolling","getDistanceToBoundary","px","py","innerW","innerH","createRoundedRectNormalMap","subpixelOffsets","alphaSum","ox","oy","closestX","closestY","toEdgeX","toEdgeY","cornerDist","toDirX","toDirY","dirLen","createDisplacementMapData","displacement","ht","createDisplacementMap","result","GlassOverlay","composite","config","isCircle","transform","dataIor","dataRoughness","cssRadius","useDisplacementMap","dpr","circleSize","mapWidth","mapHeight","style","topLeft","topRight","bottomRight","bottomLeft","parseValue","value","dimension","getFirstValue","avgDimension"],"mappings":"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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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"}