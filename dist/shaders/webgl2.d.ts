export declare const fullscreenVertex = "\nprecision mediump float;\nattribute vec2 aPosition;\nattribute vec2 aUV;\nvarying vec2 vUv;\nvoid main(void){\n  vUv = aUV;\n  vec2 pos = aPosition * 2.0 - 1.0;\n  gl_Position = vec4(pos, 0.0, 1.0);\n}\n";
export declare const jfaSeedFragment = "\nprecision highp float;\nvarying vec2 vUv;\nuniform sampler2D uNormalMap;\nuniform vec2 uTexelSize;\n\nvoid main() {\n  float center = texture2D(uNormalMap, vUv).a;\n\n  // Check if this is an edge pixel (shape mask transitions)\n  bool isEdge = false;\n\n  // Sample 8 neighbors for better edge detection\n  for (int dy = -1; dy <= 1; dy++) {\n    for (int dx = -1; dx <= 1; dx++) {\n      if (dx == 0 && dy == 0) continue;\n      vec2 offset = vec2(float(dx), float(dy)) * uTexelSize;\n      float neighbor = texture2D(uNormalMap, vUv + offset).a;\n\n      // Edge if center is inside shape but any neighbor is outside\n      if (center > 0.5 && neighbor < 0.5) {\n        isEdge = true;\n        break;\n      }\n    }\n    if (isEdge) break;\n  }\n\n  // Also check UV boundaries as edges\n  if (center > 0.5) {\n    if (vUv.x < uTexelSize.x || vUv.x > 1.0 - uTexelSize.x ||\n        vUv.y < uTexelSize.y || vUv.y > 1.0 - uTexelSize.y) {\n      isEdge = true;\n    }\n  }\n\n  if (isEdge) {\n    // Store own position as seed (normalized 0-1)\n    gl_FragColor = vec4(vUv, 0.0, 1.0);\n  } else if (center > 0.5) {\n    // Inside shape but not edge - mark as needing distance calc\n    gl_FragColor = vec4(-1.0, -1.0, 0.0, 1.0);\n  } else {\n    // Outside shape\n    gl_FragColor = vec4(-1.0, -1.0, 0.0, 0.0);\n  }\n}\n";
export declare const jfaFloodFragment = "\nprecision highp float;\nvarying vec2 vUv;\nuniform sampler2D uPrevPass;\nuniform vec2 uTexelSize;\nuniform float uStepSize;\n\nvoid main() {\n  vec4 bestSeed = texture2D(uPrevPass, vUv);\n  float bestDist = 999999.0;\n\n  // Calculate distance to current best seed\n  if (bestSeed.x >= 0.0) {\n    vec2 diff = vUv - bestSeed.xy;\n    bestDist = dot(diff, diff);\n  }\n\n  // Check 8 neighbors at current step size\n  for (int dy = -1; dy <= 1; dy++) {\n    for (int dx = -1; dx <= 1; dx++) {\n      if (dx == 0 && dy == 0) continue;\n\n      vec2 neighborUV = vUv + vec2(float(dx), float(dy)) * uStepSize * uTexelSize;\n\n      // Bounds check\n      if (neighborUV.x < 0.0 || neighborUV.x > 1.0 || neighborUV.y < 0.0 || neighborUV.y > 1.0) {\n        continue;\n      }\n\n      vec4 neighborSeed = texture2D(uPrevPass, neighborUV);\n\n      // If neighbor has a valid seed\n      if (neighborSeed.x >= 0.0) {\n        vec2 diff = vUv - neighborSeed.xy;\n        float dist = dot(diff, diff);\n\n        if (dist < bestDist) {\n          bestDist = dist;\n          bestSeed = neighborSeed;\n        }\n      }\n    }\n  }\n\n  gl_FragColor = bestSeed;\n}\n";
export declare const jfaDistanceFragment = "\nprecision highp float;\nvarying vec2 vUv;\nuniform sampler2D uSeedMap;\nuniform float uMaxDistance;\n\nvoid main() {\n  vec4 seed = texture2D(uSeedMap, vUv);\n\n  if (seed.x < 0.0) {\n    // No seed found (outside shape or error)\n    gl_FragColor = vec4(0.0, 0.0, 0.0, seed.a);\n    return;\n  }\n\n  // Calculate actual distance\n  vec2 diff = vUv - seed.xy;\n  float dist = length(diff);\n\n  // Normalize to 0-1 range based on max distance\n  float normalizedDist = clamp(dist / uMaxDistance, 0.0, 1.0);\n\n  gl_FragColor = vec4(normalizedDist, normalizedDist, normalizedDist, seed.a);\n}\n";
export declare const panelVertex = "\nprecision mediump float;\nattribute vec2 aPosition;\nattribute vec2 aUV;\nvarying vec2 vUv;\nuniform vec2 uPosition;\nuniform vec2 uScale;\nuniform vec2 uResolution;\nvoid main(void){\n  vUv = aUV;\n  vec2 worldPos = aPosition * uScale + uPosition;\n  vec2 clipPos = (worldPos / uResolution) * 2.0 - 1.0;\n  gl_Position = vec4(clipPos, 0.0, 1.0);\n}\n";
export declare const refractionFragment = "\nprecision highp float;\nvarying vec2 vUv;\nuniform sampler2D uSceneColor;\nuniform sampler2D uNormalMap;\nuniform sampler2D uCausticsMap;\nuniform sampler2D uDistanceField;\nuniform vec2 uInvResolution;\nuniform float uIOR;\nuniform float uThickness;\nuniform float uDispersion;\nuniform float uRoughness;\nuniform float uOpacity;\nuniform bool uEnableDispersion;\nuniform bool uEnableCaustics;\nuniform vec3 uTint;\nuniform float uSpecular;\nuniform float uShininess;\nuniform float uShadow;\nuniform vec3 uLightDir;\nuniform float uBlurSamples;\nuniform float uBlurSpread;\nuniform float uBlurAngle;\nuniform float uBlurAnisotropy;\nuniform float uBlurGamma;\nuniform float uAberrationR;\nuniform float uAberrationB;\nuniform float uAO;\nuniform float uAORadius;\nuniform float uNoiseScale;\nuniform float uNoiseIntensity;\nuniform float uNoiseRotation;\nuniform float uNoiseThreshold;\nuniform float uEdgeSupersampling;\nuniform float uGlassSupersampling;\nuniform vec4 uEdgeIor; // rangeStart, rangeEnd, strength, enabled\nuniform vec2 uPanelSize;\n\n// Edge mask system\nuniform float uEdgeMaskCutoff;\nuniform float uEdgeMaskBlur;\nuniform bool uEdgeMaskInvert;\n\n// Edge tactics: vec4(rangeStart, rangeEnd, strength, opacity)\nuniform vec4 uEdgeSmoothing;\nuniform vec4 uEdgeContrast;\nuniform vec4 uEdgeAlpha;\nuniform vec4 uEdgeTint;\nuniform vec4 uEdgeDarken;\nuniform vec4 uEdgeDesaturate;\n\n// Tactic enable flags\nuniform bool uEnableSmoothing;\nuniform bool uEnableContrast;\nuniform bool uEnableAlpha;\nuniform bool uEnableTint;\nuniform bool uEnableDarken;\nuniform bool uEnableDesaturate;\n// Debug mode: 0=off, 1=edgeDist, 2=shapeMask, 3=normals\nuniform float uDebugMode;\n\n// Simple value noise\nfloat hash(vec2 p) {\n  return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat valueNoise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  f = f * f * (3.0 - 2.0 * f); // smoothstep\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n  return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nvec2 rotateUV(vec2 uv, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\n}\n\nvec3 sampleScene(vec2 uv){\n  return texture2D(uSceneColor, clamp(uv, vec2(0.001), vec2(0.999))).rgb;\n}\n\nvec3 sampleDispersion(vec2 baseUV, vec2 offset){\n  if(!uEnableDispersion){\n    return sampleScene(baseUV + offset);\n  }\n  vec3 result;\n  result.r = sampleScene(baseUV + offset * (1.0 + uDispersion * uAberrationR)).r;\n  result.g = sampleScene(baseUV + offset).g;\n  result.b = sampleScene(baseUV + offset * (1.0 - uDispersion * uAberrationB)).b;\n  return result;\n}\n\nvec3 sampleFrostedColor(vec2 baseUV, vec2 offset){\n  float radius = uRoughness * uBlurSpread;\n  vec3 accum = vec3(0.0);\n  float totalWeight = 0.0;\n  int samples = int(uBlurSamples);\n\n  // Golden angle spiral for better sample distribution\n  float goldenAngle = 2.39996323;\n\n  // Directional blur rotation matrix\n  float ca = cos(uBlurAngle);\n  float sa = sin(uBlurAngle);\n\n  for(int i=0;i<32;i++){\n    if(i >= samples) break;\n\n    // Normalized distance from center (0 to 1)\n    float t = float(i) / float(samples - 1);\n\n    // Apply gamma curve to sample distribution\n    float curvedT = pow(t, uBlurGamma);\n    float r = curvedT * radius;\n\n    float angle = float(i) * goldenAngle;\n    vec2 dir = vec2(cos(angle), sin(angle));\n\n    // Apply anisotropy (stretch in one direction)\n    if(uBlurAnisotropy > 0.001){\n      // Rotate to blur angle, apply stretch, rotate back\n      vec2 rotated = vec2(ca * dir.x + sa * dir.y, -sa * dir.x + ca * dir.y);\n      rotated.y *= (1.0 - uBlurAnisotropy);\n      dir = vec2(ca * rotated.x - sa * rotated.y, sa * rotated.x + ca * rotated.y);\n    }\n\n    vec2 sampleOffset = dir * r * uInvResolution;\n\n    // Weight samples by distance (softer falloff)\n    float w = 1.0 - curvedT * 0.5;\n    accum += sampleDispersion(baseUV, offset + sampleOffset) * w;\n    totalWeight += w;\n  }\n  return accum / max(totalWeight, 1.0);\n}\n\n// Apply a tactic based on edge mask value\n// Returns a factor in [0, 1] based on mask position within tactic range\n// mask: 0 at edge, 1 at center\n// rangeStart/rangeEnd: define the mask region where effect applies (0=edge, 1=center)\nfloat applyTactic(vec4 tactic, float mask) {\n  float rangeStart = tactic.x;\n  float rangeEnd = tactic.y;\n  float strength = tactic.z;\n  float opacity = tactic.w;\n\n  // Effect is full (1.0) when mask < rangeStart\n  // Effect fades to 0 as mask approaches rangeEnd\n  // Effect is 0 when mask > rangeEnd\n  float t = 1.0 - smoothstep(rangeStart, rangeEnd, mask);\n\n  // Apply strength and opacity\n  return t * strength * opacity;\n}\n\n// Calculate edge distance mask from shape mask (0 at edges, 1 at center)\n// Uses sampling to find distance to nearest edge of the shape\nfloat calculateEdgeMask(vec2 uv, sampler2D normalMap) {\n  // Sample in multiple directions to find distance to edge\n  float minDist = 1.0;\n\n  // Check 8 directions for coverage\n  for (int i = 0; i < 8; i++) {\n    float angle = float(i) * 0.785398; // PI/4\n    vec2 dir = vec2(cos(angle), sin(angle));\n\n    // March along direction with fine steps (0-30% of distance to center)\n    for (int step = 1; step <= 512; step++) {\n      float t = float(step) / 512.0 * 0.15; // Max 0.15 in UV space (30% of 0.5)\n      vec2 sampleUV = uv + dir * t;\n\n      // Check bounds\n      if (sampleUV.x < 0.0 || sampleUV.x > 1.0 || sampleUV.y < 0.0 || sampleUV.y > 1.0) {\n        minDist = min(minDist, t);\n        break;\n      }\n\n      // Check shape mask\n      float mask = texture2D(normalMap, sampleUV).a;\n      if (mask < 0.5) {\n        minDist = min(minDist, t);\n        break;\n      }\n    }\n  }\n\n  // Normalize to 0-1 range (0 at edge, 1 when dist >= 0.15)\n  return clamp(minDist / 0.15, 0.0, 1.0);\n}\n\nvoid main(){\n  vec2 screenUV = gl_FragCoord.xy * uInvResolution;\n\n  vec4 normalSample = texture2D(uNormalMap, vUv);\n  float shapeMask = normalSample.a;\n\n  // Discard pixels outside the shape (border radius) - skip when in debug mode\n  if (shapeMask < 0.5 && uDebugMode < 0.5) {\n    discard;\n  }\n\n  // Get edge distance from pre-computed JFA distance field (0 at edges, 1 at center)\n  float edgeDist = texture2D(uDistanceField, vUv).r;\n\n  // Optionally blur the edge distance\n  if (uEdgeMaskBlur > 0.0) {\n    float blurredDist = 0.0;\n    float blurWeight = 0.0;\n    float blurSize = uEdgeMaskBlur * 0.01;\n    for (int x = -2; x <= 2; x++) {\n      for (int y = -2; y <= 2; y++) {\n        vec2 offset = vec2(float(x), float(y)) * blurSize;\n        float sampleDist = texture2D(uDistanceField, vUv + offset).r;\n        float weight = 1.0 - length(vec2(float(x), float(y))) * 0.2;\n        blurredDist += sampleDist * weight;\n        blurWeight += weight;\n      }\n    }\n    edgeDist = blurredDist / blurWeight;\n  }\n\n  // Optionally invert the edge distance\n  if (uEdgeMaskInvert) {\n    edgeDist = 1.0 - edgeDist;\n  }\n\n  // Debug modes (early exit)\n  if (uDebugMode > 0.5) {\n    if (uDebugMode < 1.5) {\n      // Mode 1: Edge distance (black at edges, white at center)\n      gl_FragColor = vec4(vec3(edgeDist), 1.0);\n    } else if (uDebugMode < 2.5) {\n      // Mode 2: Shape mask (border radius alpha)\n      gl_FragColor = vec4(vec3(shapeMask), 1.0);\n    } else {\n      // Mode 3: Normal map visualization\n      gl_FragColor = vec4(normalSample.rgb, 1.0);\n    }\n    return;\n  }\n\n  // Simple refraction offset based on normal map\n  vec2 normal = normalSample.xy * 2.0 - 1.0;\n\n  // Calculate edge factors for each tactic\n  float smoothingFactor = uEnableSmoothing ? applyTactic(uEdgeSmoothing, edgeDist) : 0.0;\n  float contrastFactor = uEnableContrast ? applyTactic(uEdgeContrast, edgeDist) : 0.0;\n  float alphaFactor = uEnableAlpha ? applyTactic(uEdgeAlpha, edgeDist) : 0.0;\n  float tintFactor = uEnableTint ? applyTactic(uEdgeTint, edgeDist) : 0.0;\n  float darkenFactor = uEnableDarken ? applyTactic(uEdgeDarken, edgeDist) : 0.0;\n  float desaturateFactor = uEnableDesaturate ? applyTactic(uEdgeDesaturate, edgeDist) : 0.0;\n\n  // Apply noise distortion to normal (anchored to container via vUv)\n  if (uNoiseIntensity > 0.001) {\n    vec2 noiseUV = rotateUV(vUv * uNoiseScale, uNoiseRotation * 3.14159 / 180.0);\n    float n = valueNoise(noiseUV);\n    float n2 = valueNoise(noiseUV + vec2(100.0, 100.0));\n    // Apply threshold\n    n = smoothstep(uNoiseThreshold, 1.0, n) * (1.0 - uNoiseThreshold) + n * uNoiseThreshold;\n    n2 = smoothstep(uNoiseThreshold, 1.0, n2) * (1.0 - uNoiseThreshold) + n2 * uNoiseThreshold;\n    vec2 noiseNormal = (vec2(n, n2) - 0.5) * 2.0 * uNoiseIntensity;\n    normal += noiseNormal;\n  }\n\n  // Attenuate IOR effect at edges to prevent harsh distortion\n  float effectiveIOR = uIOR;\n  if (uEdgeIor.w > 0.5) {\n    // Apply tactic: reduce IOR at edges based on range and strength\n    float iorFactor = 1.0 - smoothstep(uEdgeIor.x, uEdgeIor.y, edgeDist);\n    effectiveIOR = mix(uIOR, 1.0, iorFactor * uEdgeIor.z);\n  }\n  vec2 offset = normal * uThickness * 0.1 * (effectiveIOR - 1.0);\n\n  vec3 refracted;\n  if (uGlassSupersampling > 1.0) {\n    // Supersample the entire glass panel\n    vec3 ssColor = vec3(0.0);\n    int samples = int(uGlassSupersampling * uGlassSupersampling);\n    float ssStep = 1.0 / uGlassSupersampling;\n    int sampleIdx = 0;\n    for (int x = 0; x < 4; x++) {\n      if (x >= int(uGlassSupersampling)) break;\n      for (int y = 0; y < 4; y++) {\n        if (y >= int(uGlassSupersampling)) break;\n        vec2 ssOffset = (vec2(float(x), float(y)) * ssStep - 0.5 + ssStep * 0.5) * uInvResolution;\n        ssColor += sampleFrostedColor(screenUV + ssOffset, offset);\n        sampleIdx++;\n      }\n    }\n    refracted = ssColor / float(sampleIdx);\n  } else {\n    refracted = sampleFrostedColor(screenUV, offset);\n  }\n  // Apply tint as color mix instead of multiply to preserve visibility\n  float tintStrength = 0.3;\n  refracted = mix(refracted, refracted * uTint + uTint * 0.1, tintStrength);\n\n  // Calculate lighting from normal map (now includes noise)\n  vec3 N = normalize(vec3(normal, normalSample.b * 2.0 - 1.0));\n  float NdotL = max(0.0, dot(N, normalize(uLightDir)));\n\n  // Specular highlight (Blinn-Phong)\n  vec3 viewDir = vec3(0.0, 0.0, 1.0);\n  vec3 halfDir = normalize(normalize(uLightDir) + viewDir);\n  float spec = pow(max(0.0, dot(N, halfDir)), uShininess) * uSpecular;\n\n  // Shadow from normal facing away from light\n  float shadowFactor = 1.0 - uShadow * (1.0 - NdotL);\n\n  // Ambient occlusion based on normal length (darker at edges/outside)\n  float normalDist = length(normal);\n  float aoFactor = 1.0 - uAO * smoothstep(0.0, uAORadius, normalDist);\n\n  // Apply lighting\n  refracted = refracted * shadowFactor * aoFactor + vec3(spec);\n\n  // Apply modular edge tactics\n\n  // Smoothing: reduce sharpness at edges by blending toward grey\n  if (uEnableSmoothing && smoothingFactor > 0.0) {\n    float lum = dot(refracted, vec3(0.299, 0.587, 0.114));\n    refracted = mix(refracted, vec3(lum), smoothingFactor * 0.5);\n  }\n\n  // Contrast reduction at edges\n  if (uEnableContrast && contrastFactor > 0.0) {\n    float contrastMult = 1.0 - contrastFactor * 0.5;\n    refracted *= contrastMult;\n  }\n\n  // Darken edges (vignette effect)\n  if (uEnableDarken && darkenFactor > 0.0) {\n    refracted *= (1.0 - darkenFactor * 0.7);\n  }\n\n  // Desaturate edges\n  if (uEnableDesaturate && desaturateFactor > 0.0) {\n    float luma = dot(refracted, vec3(0.299, 0.587, 0.114));\n    refracted = mix(refracted, vec3(luma), desaturateFactor);\n  }\n\n  // Tint opacity at edges\n  if (uEnableTint && tintFactor > 0.0) {\n    refracted = mix(refracted, refracted * uTint, tintFactor);\n  }\n\n  // Alpha falloff at edges\n  float finalAlpha = 1.0;\n  if (uEnableAlpha && alphaFactor > 0.0) {\n    finalAlpha = 1.0 - alphaFactor;\n  }\n\n  gl_FragColor = vec4(refracted, finalAlpha);\n}\n";
export declare const revealageFragment = "\nprecision mediump float;\nvarying vec2 vUv;\nuniform sampler2D uNormalMap;\nuniform float uOpacity;\nvoid main(){\n  vec4 normalSample = texture2D(uNormalMap, vUv);\n  float mask = normalSample.a;\n\n  // Discard pixels outside the masked area (border radius)\n  if (mask < 0.01) {\n    discard;\n  }\n\n  float alpha = uOpacity * mask;\n  float revealage = exp(-3.0 * alpha);\n  gl_FragColor = vec4(revealage);\n}\n";
export declare const compositeFragment = "\nprecision mediump float;\nvarying vec2 vUv;\nuniform sampler2D uSceneColor;\nuniform sampler2D uAccum;\nuniform sampler2D uReveal;\nvoid main(){\n  vec4 accum = texture2D(uAccum, vUv);\n  vec3 scene = texture2D(uSceneColor, vUv).rgb;\n\n  // Simple alpha blend: accum.a is opacity\n  vec3 result = mix(scene, accum.rgb, accum.a);\n  gl_FragColor = vec4(result, 1.0);\n}\n";
