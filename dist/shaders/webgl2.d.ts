export declare const fullscreenVertex = "\nprecision mediump float;\nattribute vec2 aPosition;\nattribute vec2 aUV;\nvarying vec2 vUv;\nvoid main(void){\n  vUv = aUV;\n  vec2 pos = aPosition * 2.0 - 1.0;\n  gl_Position = vec4(pos, 0.0, 1.0);\n}\n";
export declare const panelVertex = "\nprecision mediump float;\nattribute vec2 aPosition;\nattribute vec2 aUV;\nvarying vec2 vUv;\nuniform vec2 uPosition;\nuniform vec2 uScale;\nuniform vec2 uResolution;\nvoid main(void){\n  vUv = aUV;\n  vec2 worldPos = aPosition * uScale + uPosition;\n  vec2 clipPos = (worldPos / uResolution) * 2.0 - 1.0;\n  gl_Position = vec4(clipPos, 0.0, 1.0);\n}\n";
export declare const refractionFragment = "\nprecision highp float;\nvarying vec2 vUv;\nuniform sampler2D uSceneColor;\nuniform sampler2D uNormalMap;\nuniform sampler2D uCausticsMap;\nuniform vec2 uInvResolution;\nuniform float uIOR;\nuniform float uThickness;\nuniform float uDispersion;\nuniform float uRoughness;\nuniform float uOpacity;\nuniform bool uEnableDispersion;\nuniform bool uEnableCaustics;\nuniform vec3 uTint;\nuniform float uSpecular;\nuniform float uShininess;\nuniform float uShadow;\nuniform vec3 uLightDir;\nuniform float uBlurSamples;\nuniform float uBlurSpread;\nuniform float uBlurAngle;\nuniform float uBlurAnisotropy;\nuniform float uBlurGamma;\nuniform float uSpecularNoise;\nuniform float uSurfaceWarp;\nuniform float uLightJitter;\nuniform float uAberrationR;\nuniform float uAberrationB;\nuniform float uAO;\nuniform float uAORadius;\nuniform float uNoiseScale;\nuniform float uNoiseIntensity;\nuniform float uNoiseRotation;\nuniform float uNoiseThreshold;\nuniform float uEdgeSupersampling;\nuniform float uEdgeSmoothWidth;\nuniform float uEdgeContrast;\nuniform float uEdgeAlphaFalloff;\nuniform float uEdgeMaskCutoff;\nuniform bool uEnableEdgeSmoothing;\nuniform bool uEnableContrastReduction;\nuniform bool uEnableAlphaFalloff;\nuniform bool uEnableTintOpacity;\nuniform float uEdgeBlur;\nuniform float uGlassSupersampling;\nuniform vec2 uPanelSize;\n\n// Simple value noise\nfloat hash(vec2 p) {\n  return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat valueNoise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  f = f * f * (3.0 - 2.0 * f); // smoothstep\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n  return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nvec2 rotateUV(vec2 uv, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\n}\n\nvec3 sampleScene(vec2 uv){\n  return texture2D(uSceneColor, clamp(uv, vec2(0.001), vec2(0.999))).rgb;\n}\n\nvec3 sampleDispersion(vec2 baseUV, vec2 offset){\n  if(!uEnableDispersion){\n    return sampleScene(baseUV + offset);\n  }\n  vec3 result;\n  result.r = sampleScene(baseUV + offset * (1.0 + uDispersion * uAberrationR)).r;\n  result.g = sampleScene(baseUV + offset).g;\n  result.b = sampleScene(baseUV + offset * (1.0 - uDispersion * uAberrationB)).b;\n  return result;\n}\n\nvec3 sampleFrostedColor(vec2 baseUV, vec2 offset){\n  // Scale blur by panel size relative to reference (200px)\n  float referenceSize = 200.0;\n  float avgPanelSize = (uPanelSize.x + uPanelSize.y) * 0.5;\n  float sizeScale = avgPanelSize / referenceSize;\n\n  float radius = uRoughness * uBlurSpread * sizeScale;\n  vec3 accum = vec3(0.0);\n  float totalWeight = 0.0;\n  int samples = int(uBlurSamples);\n\n  // Golden angle spiral for better sample distribution\n  float goldenAngle = 2.39996323;\n\n  // Directional blur rotation matrix\n  float ca = cos(uBlurAngle);\n  float sa = sin(uBlurAngle);\n\n  for(int i=0;i<32;i++){\n    if(i >= samples) break;\n\n    // Normalized distance from center (0 to 1)\n    float t = float(i) / float(samples - 1);\n\n    // Apply gamma curve to sample distribution\n    float curvedT = pow(t, uBlurGamma);\n    float r = curvedT * radius;\n\n    float angle = float(i) * goldenAngle;\n    vec2 dir = vec2(cos(angle), sin(angle));\n\n    // Apply anisotropy (stretch in one direction)\n    if(uBlurAnisotropy > 0.001){\n      // Rotate to blur angle, apply stretch, rotate back\n      vec2 rotated = vec2(ca * dir.x + sa * dir.y, -sa * dir.x + ca * dir.y);\n      rotated.y *= (1.0 - uBlurAnisotropy);\n      dir = vec2(ca * rotated.x - sa * rotated.y, sa * rotated.x + ca * rotated.y);\n    }\n\n    vec2 sampleOffset = dir * r * uInvResolution;\n\n    // Weight samples by distance (softer falloff)\n    float w = 1.0 - curvedT * 0.5;\n    accum += sampleDispersion(baseUV, offset + sampleOffset) * w;\n    totalWeight += w;\n  }\n  return accum / max(totalWeight, 1.0);\n}\n\nvoid main(){\n  vec2 screenUV = gl_FragCoord.xy * uInvResolution;\n\n  vec4 normalSample = texture2D(uNormalMap, vUv);\n  float mask = normalSample.a;\n\n  // Blur the mask at edges for softer borders\n  if (uEdgeBlur > 0.0 && mask < 0.9) {\n    float blurredMask = 0.0;\n    float blurWeight = 0.0;\n    vec2 texelSize = uInvResolution * uEdgeBlur;\n    for (int x = -2; x <= 2; x++) {\n      for (int y = -2; y <= 2; y++) {\n        vec2 offset = vec2(float(x), float(y)) * texelSize;\n        float sampleMask = texture2D(uNormalMap, vUv + offset).a;\n        float weight = 1.0 - length(vec2(float(x), float(y))) * 0.2;\n        blurredMask += sampleMask * weight;\n        blurWeight += weight;\n      }\n    }\n    mask = blurredMask / blurWeight;\n  }\n\n  // Discard pixels outside the masked area (border radius)\n  if (mask < uEdgeMaskCutoff) {\n    discard;\n  }\n\n  // Simple refraction offset based on normal map\n  vec2 normal = normalSample.xy * 2.0 - 1.0;\n\n  // Edge smoothing with configurable width\n  float edgeSmoothness = 1.0;\n  if (uEnableEdgeSmoothing) {\n    float smoothWidth = uEdgeSmoothWidth * (0.5 + 0.5 * uEdgeSupersampling);\n    edgeSmoothness = smoothstep(0.0, smoothWidth, mask);\n  }\n\n  float contrastReduction = 1.0;\n  if (uEnableContrastReduction) {\n    contrastReduction = mix(uEdgeContrast, 1.0, edgeSmoothness);\n  }\n\n  // Apply noise distortion to normal (anchored to container via vUv)\n  if (uNoiseIntensity > 0.001) {\n    vec2 noiseUV = rotateUV(vUv * uNoiseScale, uNoiseRotation * 3.14159 / 180.0);\n    float n = valueNoise(noiseUV);\n    float n2 = valueNoise(noiseUV + vec2(100.0, 100.0));\n    // Apply threshold\n    n = smoothstep(uNoiseThreshold, 1.0, n) * (1.0 - uNoiseThreshold) + n * uNoiseThreshold;\n    n2 = smoothstep(uNoiseThreshold, 1.0, n2) * (1.0 - uNoiseThreshold) + n2 * uNoiseThreshold;\n    vec2 noiseNormal = (vec2(n, n2) - 0.5) * 2.0 * uNoiseIntensity;\n    normal += noiseNormal;\n  }\n\n  vec2 offset = normal * uThickness * 0.1 * (uIOR - 1.0);\n\n  vec3 refracted;\n  if (uGlassSupersampling > 1.0) {\n    // Supersample the entire glass panel\n    vec3 ssColor = vec3(0.0);\n    int samples = int(uGlassSupersampling * uGlassSupersampling);\n    float ssStep = 1.0 / uGlassSupersampling;\n    int sampleIdx = 0;\n    for (int x = 0; x < 4; x++) {\n      if (x >= int(uGlassSupersampling)) break;\n      for (int y = 0; y < 4; y++) {\n        if (y >= int(uGlassSupersampling)) break;\n        vec2 ssOffset = (vec2(float(x), float(y)) * ssStep - 0.5 + ssStep * 0.5) * uInvResolution;\n        ssColor += sampleFrostedColor(screenUV + ssOffset, offset);\n        sampleIdx++;\n      }\n    }\n    refracted = ssColor / float(sampleIdx);\n  } else {\n    refracted = sampleFrostedColor(screenUV, offset);\n  }\n  // Apply tint as color mix instead of multiply to preserve visibility\n  float tintStrength = 0.3;\n  refracted = mix(refracted, refracted * uTint + uTint * 0.1, tintStrength);\n\n  // Apply surface warp for organic distortion\n  if (uSurfaceWarp > 0.001) {\n    vec2 warpUV = vUv * 3.0 + vec2(17.3, 31.7);\n    float warp1 = valueNoise(warpUV) - 0.5;\n    float warp2 = valueNoise(warpUV + vec2(50.0, 50.0)) - 0.5;\n    normal += vec2(warp1, warp2) * uSurfaceWarp * 0.3;\n  }\n\n  // Calculate lighting from normal map (now includes noise and warp)\n  vec3 N = normalize(vec3(normal, normalSample.b * 2.0 - 1.0));\n\n  // Apply light jitter for less perfect lighting\n  vec3 lightDir = normalize(uLightDir);\n  if (uLightJitter > 0.001) {\n    vec2 jitterUV = gl_FragCoord.xy * 0.01;\n    float jx = (valueNoise(jitterUV) - 0.5) * uLightJitter;\n    float jy = (valueNoise(jitterUV + vec2(100.0, 0.0)) - 0.5) * uLightJitter;\n    lightDir = normalize(lightDir + vec3(jx, jy, 0.0));\n  }\n\n  float NdotL = max(0.0, dot(N, lightDir));\n\n  // Specular highlight (Blinn-Phong) with noise variation\n  vec3 viewDir = vec3(0.0, 0.0, 1.0);\n  vec3 halfDir = normalize(lightDir + viewDir);\n  float spec = pow(max(0.0, dot(N, halfDir)), uShininess) * uSpecular;\n\n  // Add specular noise for imperfect highlights\n  if (uSpecularNoise > 0.001) {\n    float specNoise = valueNoise(vUv * 8.0 + vec2(73.1, 19.3));\n    spec *= 1.0 - uSpecularNoise * (1.0 - specNoise);\n  }\n\n  // Shadow from normal facing away from light\n  float shadowFactor = 1.0 - uShadow * (1.0 - NdotL);\n\n  // Ambient occlusion based on edge distance (darker at edges/outside)\n  float edgeDist = length(normal);\n  float aoFactor = 1.0 - uAO * smoothstep(0.0, uAORadius, edgeDist);\n\n  // Apply lighting\n  refracted = refracted * shadowFactor * aoFactor + vec3(spec);\n\n  // Apply contrast reduction at edges and tint intensity to overall opacity\n  if (uEnableContrastReduction) {\n    refracted *= contrastReduction;\n  }\n\n  // Use normal map alpha as shape mask\n  float shapeMask = normalSample.a;\n  if (shapeMask < 0.5) discard;\n\n  gl_FragColor = vec4(refracted, 1.0);\n}\n";
export declare const revealageFragment = "\nprecision mediump float;\nvarying vec2 vUv;\nuniform sampler2D uNormalMap;\nuniform float uOpacity;\nvoid main(){\n  vec4 normalSample = texture2D(uNormalMap, vUv);\n  float mask = normalSample.a;\n\n  // Discard pixels outside the masked area (border radius)\n  if (mask < 0.01) {\n    discard;\n  }\n\n  float alpha = uOpacity * mask;\n  float revealage = exp(-3.0 * alpha);\n  gl_FragColor = vec4(revealage);\n}\n";
export declare const compositeFragment = "\nprecision mediump float;\nvarying vec2 vUv;\nuniform sampler2D uSceneColor;\nuniform sampler2D uAccum;\nuniform sampler2D uReveal;\nvoid main(){\n  vec4 accum = texture2D(uAccum, vUv);\n  vec3 scene = texture2D(uSceneColor, vUv).rgb;\n\n  // Simple alpha blend: accum.a is opacity\n  vec3 result = mix(scene, accum.rgb, accum.a);\n  gl_FragColor = vec4(result, 1.0);\n}\n";
